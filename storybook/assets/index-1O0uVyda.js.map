{"version":3,"file":"index-1O0uVyda.js","sources":["../../../../../node_modules/.pnpm/@floating-ui+utils@0.1.6/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","../../../../../node_modules/.pnpm/@floating-ui+core@1.5.0/node_modules/@floating-ui/core/dist/floating-ui.core.mjs","../../../../../node_modules/.pnpm/@floating-ui+utils@0.1.6/node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs","../../../../../node_modules/.pnpm/@floating-ui+dom@1.5.3/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","../../../../../node_modules/.pnpm/@floating-ui+vue@1.0.2_vue@3.4.15/node_modules/@floating-ui/vue/dist/floating-ui.vue.esm.js","../../../../../node_modules/.pnpm/radix-vue@1.2.4_vue@3.4.15/node_modules/radix-vue/dist/index.js"],"sourcesContent":["const sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element â€”\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        const maximumClippingWidth = width - overflow.left - overflow.right;\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        const maximumClippingHeight = height - overflow.top - overflow.bottom;\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","function getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const webkit = isWebKit();\n  const css = getComputedStyle(element);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isWebKit };\n","import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nconst getElementRects = async function (_ref) {\n  let {\n    reference,\n    floating,\n    strategy\n  } = _ref;\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  return {\n    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...(await getDimensionsFn(floating))\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    clearTimeout(timeoutId);\n    io && io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          resizeObserver && resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo && cleanupIo();\n    resizeObserver && resizeObserver.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { autoUpdate, computePosition, platform };\n","import { arrow as arrow$1, computePosition } from '@floating-ui/dom';\nexport { autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/dom';\nimport { unref, computed, ref, shallowRef, watch, getCurrentScope, onScopeDispose, shallowReadonly } from 'vue-demi';\n\nfunction unwrapElement(element) {\n  var _$el;\n  return (_$el = element == null ? void 0 : element.$el) != null ? _$el : element;\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered to the reference element.\n * @param options The arrow options.\n * @see https://floating-ui.com/docs/arrow\n */\nfunction arrow(options) {\n  return {\n    name: 'arrow',\n    options,\n    fn(args) {\n      const element = unwrapElement(unref(options.element));\n      if (element == null) {\n        return {};\n      }\n      return arrow$1({\n        element,\n        padding: options.padding\n      }).fn(args);\n    }\n  };\n}\n\nfunction getDPR(element) {\n  if (typeof window === 'undefined') {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\n\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element next to a reference element when it is given a certain CSS positioning strategy.\n * @param reference The reference template ref.\n * @param floating The floating template ref.\n * @param options The floating options.\n * @see https://floating-ui.com/docs/vue\n */\nfunction useFloating(reference, floating, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const whileElementsMountedOption = options.whileElementsMounted;\n  const openOption = computed(() => {\n    var _unref;\n    return (_unref = unref(options.open)) != null ? _unref : true;\n  });\n  const middlewareOption = computed(() => unref(options.middleware));\n  const placementOption = computed(() => {\n    var _unref2;\n    return (_unref2 = unref(options.placement)) != null ? _unref2 : 'bottom';\n  });\n  const strategyOption = computed(() => {\n    var _unref3;\n    return (_unref3 = unref(options.strategy)) != null ? _unref3 : 'absolute';\n  });\n  const transformOption = computed(() => {\n    var _unref4;\n    return (_unref4 = unref(options.transform)) != null ? _unref4 : true;\n  });\n  const referenceElement = computed(() => unwrapElement(reference.value));\n  const floatingElement = computed(() => unwrapElement(floating.value));\n  const x = ref(0);\n  const y = ref(0);\n  const strategy = ref(strategyOption.value);\n  const placement = ref(placementOption.value);\n  const middlewareData = shallowRef({});\n  const isPositioned = ref(false);\n  const floatingStyles = computed(() => {\n    const initialStyles = {\n      position: strategy.value,\n      left: '0',\n      top: '0'\n    };\n    if (!floatingElement.value) {\n      return initialStyles;\n    }\n    const xVal = roundByDPR(floatingElement.value, x.value);\n    const yVal = roundByDPR(floatingElement.value, y.value);\n    if (transformOption.value) {\n      return {\n        ...initialStyles,\n        transform: \"translate(\" + xVal + \"px, \" + yVal + \"px)\",\n        ...(getDPR(floatingElement.value) >= 1.5 && {\n          willChange: 'transform'\n        })\n      };\n    }\n    return {\n      position: strategy.value,\n      left: xVal + \"px\",\n      top: yVal + \"px\"\n    };\n  });\n  let whileElementsMountedCleanup;\n  function update() {\n    if (referenceElement.value == null || floatingElement.value == null) {\n      return;\n    }\n    computePosition(referenceElement.value, floatingElement.value, {\n      middleware: middlewareOption.value,\n      placement: placementOption.value,\n      strategy: strategyOption.value\n    }).then(position => {\n      x.value = position.x;\n      y.value = position.y;\n      strategy.value = position.strategy;\n      placement.value = position.placement;\n      middlewareData.value = position.middlewareData;\n      isPositioned.value = true;\n    });\n  }\n  function cleanup() {\n    if (typeof whileElementsMountedCleanup === 'function') {\n      whileElementsMountedCleanup();\n      whileElementsMountedCleanup = undefined;\n    }\n  }\n  function attach() {\n    cleanup();\n    if (whileElementsMountedOption === undefined) {\n      update();\n      return;\n    }\n    if (referenceElement.value != null && floatingElement.value != null) {\n      whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);\n      return;\n    }\n  }\n  function reset() {\n    if (!openOption.value) {\n      isPositioned.value = false;\n    }\n  }\n  watch([middlewareOption, placementOption, strategyOption], update, {\n    flush: 'sync'\n  });\n  watch([referenceElement, floatingElement], attach, {\n    flush: 'sync'\n  });\n  watch(openOption, reset, {\n    flush: 'sync'\n  });\n  if (getCurrentScope()) {\n    onScopeDispose(cleanup);\n  }\n  return {\n    x: shallowReadonly(x),\n    y: shallowReadonly(y),\n    strategy: shallowReadonly(strategy),\n    placement: shallowReadonly(placement),\n    middlewareData: shallowReadonly(middlewareData),\n    isPositioned: shallowReadonly(isPositioned),\n    floatingStyles,\n    update\n  };\n}\n\nexport { arrow, useFloating };\n","import { inject as pn, provide as fn, shallowRef as vn, watchEffect as ee, readonly as it, ref as B, watch as Y, customRef as uo, effectScope as Pa, computed as S, nextTick as G, getCurrentScope as Sa, onScopeDispose as Ta, unref as a, toRef as Da, getCurrentInstance as Fe, onMounted as U, Fragment as ie, defineComponent as g, toRefs as z, renderSlot as y, onBeforeUnmount as co, onBeforeUpdate as Oa, onUpdated as Ia, toHandlerKey as Aa, camelize as mn, onUnmounted as fe, mergeProps as T, h as Re, cloneVNode as Ma, openBlock as h, createBlock as b, withCtx as v, createVNode as k, createCommentVNode as J, withKeys as le, Teleport as Ue, normalizeProps as R, guardReactiveProps as N, reactive as hn, normalizeStyle as ae, withModifiers as ne, createElementBlock as Q, mergeDefaults as yn, createElementVNode as rt, renderList as po, markRaw as en, withDirectives as fo, vShow as gn, resolveDynamicComponent as $e, createTextVNode as ue, toDisplayString as Le, isRef as ut, onBeforeMount as bn, vModelSelect as ka, useSlots as Cn } from \"vue\";\nimport { useFloating as Ra, autoUpdate as Va, offset as Fa, shift as La, limitShift as Ka, flip as Na, size as Ha, arrow as Wa, hide as ja } from \"@floating-ui/vue\";\nfunction H(o, t) {\n  const e = typeof o == \"string\" && !t ? `${o}Context` : t, n = Symbol(e);\n  return [(i) => {\n    const r = pn(n, i);\n    if (r || r === null)\n      return r;\n    throw new Error(\n      `Injection \\`${n.toString()}\\` not found. Component must be used within ${Array.isArray(o) ? `one of the following components: ${o.join(\n        \", \"\n      )}` : `\\`${o}\\``}`\n    );\n  }, (i) => (fn(n, i), i)];\n}\nfunction vo(o, t, e) {\n  const n = e.originalEvent.target, s = new CustomEvent(o, {\n    bubbles: !1,\n    cancelable: !0,\n    detail: e\n  });\n  t && n.addEventListener(o, t, { once: !0 }), n.dispatchEvent(s);\n}\nfunction za(o, t) {\n  var e;\n  const n = vn();\n  return ee(() => {\n    n.value = o();\n  }, {\n    ...t,\n    flush: (e = t == null ? void 0 : t.flush) != null ? e : \"sync\"\n  }), it(n);\n}\nfunction mo(o, t) {\n  let e, n, s;\n  const l = B(!0), i = () => {\n    l.value = !0, s();\n  };\n  Y(o, i, { flush: \"sync\" });\n  const r = typeof t == \"function\" ? t : t.get, u = typeof t == \"function\" ? void 0 : t.set, d = uo((c, p) => (n = c, s = p, {\n    get() {\n      return l.value && (e = r(), l.value = !1), n(), e;\n    },\n    set(f) {\n      u == null || u(f);\n    }\n  }));\n  return Object.isExtensible(d) && (d.trigger = i), d;\n}\nfunction dt(o) {\n  return Sa() ? (Ta(o), !0) : !1;\n}\nfunction Tt(o) {\n  let t = !1, e;\n  const n = Pa(!0);\n  return (...s) => (t || (e = n.run(() => o(...s)), t = !0), e);\n}\nfunction ge(o) {\n  return typeof o == \"function\" ? o() : a(o);\n}\nconst Be = typeof window < \"u\" && typeof document < \"u\", Ua = (o) => typeof o < \"u\", qa = Object.prototype.toString, Ga = (o) => qa.call(o) === \"[object Object]\", tn = (o, t, e) => Math.min(e, Math.max(t, o)), at = () => {\n};\nfunction Ya(o, t) {\n  function e(...n) {\n    return new Promise((s, l) => {\n      Promise.resolve(o(() => t.apply(this, n), { fn: t, thisArg: this, args: n })).then(s).catch(l);\n    });\n  }\n  return e;\n}\nfunction Xa(o, t = {}) {\n  let e, n, s = at;\n  const l = (r) => {\n    clearTimeout(r), s(), s = at;\n  };\n  return (r) => {\n    const u = ge(o), d = ge(t.maxWait);\n    return e && l(e), u <= 0 || d !== void 0 && d <= 0 ? (n && (l(n), n = null), Promise.resolve(r())) : new Promise((c, p) => {\n      s = t.rejectOnCancel ? p : c, d && !n && (n = setTimeout(() => {\n        e && l(e), n = null, c(r());\n      }, d)), e = setTimeout(() => {\n        n && l(n), n = null, c(r());\n      }, u);\n    });\n  };\n}\nfunction Ja(...o) {\n  if (o.length !== 1)\n    return Da(...o);\n  const t = o[0];\n  return typeof t == \"function\" ? it(uo(() => ({ get: t, set: at }))) : B(t);\n}\nfunction ho(o, t = 1e4) {\n  return uo((e, n) => {\n    let s = ge(o), l;\n    const i = () => setTimeout(() => {\n      s = ge(o), n();\n    }, ge(t));\n    return dt(() => {\n      clearTimeout(l);\n    }), {\n      get() {\n        return e(), s;\n      },\n      set(r) {\n        s = r, n(), clearTimeout(l), l = i();\n      }\n    };\n  });\n}\nfunction yo(o, t = 200, e = {}) {\n  return Ya(\n    Xa(t, e),\n    o\n  );\n}\nfunction go(o, t, e = {}) {\n  const {\n    immediate: n = !0\n  } = e, s = B(!1);\n  let l = null;\n  function i() {\n    l && (clearTimeout(l), l = null);\n  }\n  function r() {\n    s.value = !1, i();\n  }\n  function u(...d) {\n    i(), s.value = !0, l = setTimeout(() => {\n      s.value = !1, l = null, o(...d);\n    }, ge(t));\n  }\n  return n && (s.value = !0, Be && u()), dt(r), {\n    isPending: it(s),\n    start: u,\n    stop: r\n  };\n}\nfunction Za(o = 1e3, t = {}) {\n  const {\n    controls: e = !1,\n    callback: n\n  } = t, s = go(\n    n ?? at,\n    o,\n    t\n  ), l = S(() => !s.isPending.value);\n  return e ? {\n    ready: l,\n    ...s\n  } : l;\n}\nfunction Qa(o, t, e) {\n  const n = Y(o, (...s) => (G(() => n()), t(...s)), e);\n}\nfunction ve(o) {\n  var t;\n  const e = ge(o);\n  return (t = e == null ? void 0 : e.$el) != null ? t : e;\n}\nconst ct = Be ? window : void 0;\nfunction Ve(...o) {\n  let t, e, n, s;\n  if (typeof o[0] == \"string\" || Array.isArray(o[0]) ? ([e, n, s] = o, t = ct) : [t, e, n, s] = o, !t)\n    return at;\n  Array.isArray(e) || (e = [e]), Array.isArray(n) || (n = [n]);\n  const l = [], i = () => {\n    l.forEach((c) => c()), l.length = 0;\n  }, r = (c, p, f, m) => (c.addEventListener(p, f, m), () => c.removeEventListener(p, f, m)), u = Y(\n    () => [ve(t), ge(s)],\n    ([c, p]) => {\n      if (i(), !c)\n        return;\n      const f = Ga(p) ? { ...p } : p;\n      l.push(\n        ...e.flatMap((m) => n.map((C) => r(c, m, C, f)))\n      );\n    },\n    { immediate: !0, flush: \"post\" }\n  ), d = () => {\n    u(), i();\n  };\n  return dt(d), d;\n}\nfunction es(o) {\n  return typeof o == \"function\" ? o : typeof o == \"string\" ? (t) => t.key === o : Array.isArray(o) ? (t) => o.includes(t.key) : () => !0;\n}\nfunction bo(...o) {\n  let t, e, n = {};\n  o.length === 3 ? (t = o[0], e = o[1], n = o[2]) : o.length === 2 ? typeof o[1] == \"object\" ? (t = !0, e = o[0], n = o[1]) : (t = o[0], e = o[1]) : (t = !0, e = o[0]);\n  const {\n    target: s = ct,\n    eventName: l = \"keydown\",\n    passive: i = !1,\n    dedupe: r = !1\n  } = n, u = es(t);\n  return Ve(s, l, (c) => {\n    c.repeat && ge(r) || u(c) && e(c);\n  }, i);\n}\nfunction ts(o = {}) {\n  var t;\n  const {\n    window: e = ct,\n    deep: n = !0\n  } = o, s = (t = o.document) != null ? t : e == null ? void 0 : e.document, l = () => {\n    var r;\n    let u = s == null ? void 0 : s.activeElement;\n    if (n)\n      for (; u != null && u.shadowRoot; )\n        u = (r = u == null ? void 0 : u.shadowRoot) == null ? void 0 : r.activeElement;\n    return u;\n  }, i = mo(\n    () => null,\n    () => l()\n  );\n  return e && (Ve(e, \"blur\", (r) => {\n    r.relatedTarget === null && i.trigger();\n  }, !0), Ve(e, \"focus\", i.trigger, !0)), i;\n}\nfunction Dt() {\n  const o = B(!1);\n  return Fe() && U(() => {\n    o.value = !0;\n  }), o;\n}\nfunction os(o) {\n  const t = Dt();\n  return S(() => (t.value, !!o()));\n}\nfunction ns(o, t = {}) {\n  const {\n    immediate: e = !0,\n    fpsLimit: n = void 0,\n    window: s = ct\n  } = t, l = B(!1), i = n ? 1e3 / n : null;\n  let r = 0, u = null;\n  function d(f) {\n    if (!l.value || !s)\n      return;\n    const m = f - (r || f);\n    if (i && m < i) {\n      u = s.requestAnimationFrame(d);\n      return;\n    }\n    o({ delta: m, timestamp: f }), r = f, u = s.requestAnimationFrame(d);\n  }\n  function c() {\n    !l.value && s && (l.value = !0, u = s.requestAnimationFrame(d));\n  }\n  function p() {\n    l.value = !1, u != null && s && (s.cancelAnimationFrame(u), u = null);\n  }\n  return e && c(), dt(p), {\n    isActive: it(l),\n    pause: p,\n    resume: c\n  };\n}\nfunction as(o) {\n  return JSON.parse(JSON.stringify(o));\n}\nfunction _e(o, t, e = {}) {\n  const { window: n = ct, ...s } = e;\n  let l;\n  const i = os(() => n && \"ResizeObserver\" in n), r = () => {\n    l && (l.disconnect(), l = void 0);\n  }, u = S(() => Array.isArray(o) ? o.map((p) => ve(p)) : [ve(o)]), d = Y(\n    u,\n    (p) => {\n      if (r(), i.value && n) {\n        l = new ResizeObserver(t);\n        for (const f of p)\n          f && l.observe(f, s);\n      }\n    },\n    { immediate: !0, flush: \"post\", deep: !0 }\n  ), c = () => {\n    r(), d();\n  };\n  return dt(c), {\n    isSupported: i,\n    stop: c\n  };\n}\nfunction ss(o, t = {}) {\n  const e = ts(t), n = S(() => ve(o));\n  return { focused: S(() => n.value && e.value ? n.value.contains(e.value) : !1) };\n}\nfunction ls(o, t) {\n  const e = vn(t);\n  return Y(\n    Ja(o),\n    (n, s) => {\n      e.value = s;\n    },\n    { flush: \"sync\" }\n  ), it(e);\n}\nfunction X(o, t, e, n = {}) {\n  var s, l, i;\n  const {\n    clone: r = !1,\n    passive: u = !1,\n    eventName: d,\n    deep: c = !1,\n    defaultValue: p,\n    shouldEmit: f\n  } = n, m = Fe(), C = e || (m == null ? void 0 : m.emit) || ((s = m == null ? void 0 : m.$emit) == null ? void 0 : s.bind(m)) || ((i = (l = m == null ? void 0 : m.proxy) == null ? void 0 : l.$emit) == null ? void 0 : i.bind(m == null ? void 0 : m.proxy));\n  let w = d;\n  t || (t = \"modelValue\"), w = w || `update:${t.toString()}`;\n  const $ = (x) => r ? typeof r == \"function\" ? r(x) : as(x) : x, _ = () => Ua(o[t]) ? $(o[t]) : p, E = (x) => {\n    f ? f(x) && C(w, x) : C(w, x);\n  };\n  if (u) {\n    const x = _(), P = B(x);\n    let I = !1;\n    return Y(\n      () => o[t],\n      (A) => {\n        I || (I = !0, P.value = $(A), G(() => I = !1));\n      }\n    ), Y(\n      P,\n      (A) => {\n        !I && (A !== o[t] || c) && E(A);\n      },\n      { deep: c }\n    ), P;\n  } else\n    return S({\n      get() {\n        return _();\n      },\n      set(x) {\n        E(x);\n      }\n    });\n}\nfunction Ot(o) {\n  return o ? o.flatMap((t) => t.type === ie ? Ot(t.children) : [t]) : [];\n}\nfunction qe(o, t, e, n = {}) {\n  if (!t)\n    return null;\n  const {\n    arrowKeyOptions: s = \"both\",\n    attributeName: l = \"data-radix-vue-collection-item\",\n    itemsArray: i = [],\n    loop: r = !0,\n    dir: u = \"ltr\",\n    preventScroll: d = !0,\n    focus: c = !1\n  } = n, [p, f, m, C, w, $] = [\n    o.key === \"ArrowRight\",\n    o.key === \"ArrowLeft\",\n    o.key === \"ArrowUp\",\n    o.key === \"ArrowDown\",\n    o.key === \"Home\",\n    o.key === \"End\"\n  ], _ = m || C, E = p || f;\n  if (!w && !$ && (!_ && !E || s === \"vertical\" && E || s === \"horizontal\" && _))\n    return null;\n  const x = e ? Array.from(e.querySelectorAll(`[${l}]`)) : i;\n  if (!x.length)\n    return null;\n  d && o.preventDefault();\n  let P = null;\n  return E || _ ? P = _n(x, t, {\n    goForward: _ ? C : u === \"ltr\" ? p : f,\n    loop: r\n  }) : w ? P = x.at(0) || null : $ && (P = x.at(-1) || null), c && (P == null || P.focus()), P;\n}\nfunction _n(o, t, { goForward: e, loop: n }, s = o.length) {\n  if (--s === 0)\n    return null;\n  const l = o.indexOf(t), i = e ? l + 1 : l - 1;\n  if (!n && (i < 0 || i >= o.length))\n    return null;\n  const r = (i + o.length) % o.length, u = o[r];\n  return u ? u.hasAttribute(\"disabled\") && u.getAttribute(\"disabled\") !== \"false\" ? _n(\n    o,\n    u,\n    { goForward: e, loop: n },\n    s\n  ) : u : null;\n}\nfunction Jt(o) {\n  return o !== null && typeof o == \"object\";\n}\nfunction oo(o, t, e = \".\", n) {\n  if (!Jt(t))\n    return oo(o, {}, e, n);\n  const s = Object.assign({}, t);\n  for (const l in o) {\n    if (l === \"__proto__\" || l === \"constructor\")\n      continue;\n    const i = o[l];\n    i != null && (n && n(s, l, i, e) || (Array.isArray(i) && Array.isArray(s[l]) ? s[l] = [...i, ...s[l]] : Jt(i) && Jt(s[l]) ? s[l] = oo(\n      i,\n      s[l],\n      (e ? `${e}.` : \"\") + l.toString(),\n      n\n    ) : s[l] = i));\n  }\n  return s;\n}\nfunction is(o) {\n  return (...t) => (\n    // eslint-disable-next-line unicorn/no-array-reduce\n    t.reduce((e, n) => oo(e, n, \"\", o), {})\n  );\n}\nconst rs = is(), [wn, us] = H(\"ConfigProvider\"), qr = /* @__PURE__ */ g({\n  __name: \"ConfigProvider\",\n  props: {\n    dir: { default: \"ltr\" },\n    scrollBody: { type: [Boolean, Object], default: !0 }\n  },\n  setup(o) {\n    const t = o, { dir: e, scrollBody: n } = z(t);\n    return us({\n      dir: e,\n      scrollBody: n\n    }), (s, l) => y(s.$slots, \"default\");\n  }\n}), ds = Tt(() => B()), cs = Tt(() => B(0));\nfunction pt(o) {\n  const t = wn({\n    scrollBody: B(!0)\n  }), e = cs(), n = ds(), s = B(o), l = () => {\n    document.body.style.paddingRight = \"\", document.body.style.marginRight = \"\", document.body.style.pointerEvents = \"\", document.body.style.removeProperty(\"--scrollbar-width\"), document.body.style.overflow = n.value ?? \"\", n.value = void 0;\n  };\n  return o && e.value++, Y(s, (i) => {\n    var r;\n    if (Be && i) {\n      n.value === void 0 && (n.value = document.body.style.overflow);\n      const u = window.innerWidth - document.documentElement.clientWidth, d = { padding: u, margin: 0 }, c = (r = t.scrollBody) != null && r.value ? typeof t.scrollBody.value == \"object\" ? rs({\n        padding: t.scrollBody.value.padding === !0 ? u : t.scrollBody.value.padding,\n        margin: t.scrollBody.value.margin === !0 ? u : t.scrollBody.value.margin\n      }, d) : d : { padding: 0, margin: 0 };\n      u > 0 && (document.body.style.paddingRight = `${c.padding}px`, document.body.style.marginRight = `${c.margin}px`, document.body.style.setProperty(\"--scrollbar-width\", `${u}px`), document.body.style.overflow = \"hidden\"), G(() => {\n        document.body.style.pointerEvents = \"none\", document.body.style.overflow = \"hidden\";\n      });\n    }\n  }, { immediate: !0 }), co(() => {\n    o && e.value--, e.value === 0 && l();\n  }), s;\n}\nconst ps = \"data-radix-vue-collection-item\";\nfunction re(o, t = ps) {\n  const e = o ?? Symbol();\n  return { createCollection: (l) => {\n    const i = B([]);\n    function r() {\n      const u = ve(l);\n      return u ? i.value = Array.from(\n        u.querySelectorAll(`[${t}]:not([data-disabled=true])`)\n      ) : i.value = [];\n    }\n    return Oa(() => {\n      i.value = [];\n    }), U(r), Ia(r), Y(() => l == null ? void 0 : l.value, r, { immediate: !0 }), fn(e, i), i;\n  }, injectCollection: () => pn(e, B([])) };\n}\nfunction de(o) {\n  const t = wn({\n    dir: B(\"ltr\")\n  });\n  return S(() => {\n    var e;\n    return (o == null ? void 0 : o.value) || ((e = t.dir) == null ? void 0 : e.value) || \"ltr\";\n  });\n}\nfunction ce(o) {\n  const t = Fe(), e = t == null ? void 0 : t.type.emits, n = {};\n  return e != null && e.length || console.warn(\n    `No emitted event found. Please check component: ${t == null ? void 0 : t.type.__name}`\n  ), e == null || e.forEach((s) => {\n    n[Aa(mn(s))] = (...l) => o(s, ...l);\n  }), n;\n}\nlet Zt = 0;\nfunction Co() {\n  ee((o) => {\n    if (!Be)\n      return;\n    const t = document.querySelectorAll(\"[data-radix-focus-guard]\");\n    document.body.insertAdjacentElement(\n      \"afterbegin\",\n      t[0] ?? on()\n    ), document.body.insertAdjacentElement(\n      \"beforeend\",\n      t[1] ?? on()\n    ), Zt++, o(() => {\n      Zt === 1 && document.querySelectorAll(\"[data-radix-focus-guard]\").forEach((e) => e.remove()), Zt--;\n    });\n  });\n}\nfunction on() {\n  const o = document.createElement(\"span\");\n  return o.setAttribute(\"data-radix-focus-guard\", \"\"), o.tabIndex = 0, o.style.cssText = \"outline: none; opacity: 0; position: fixed; pointer-events: none\", o;\n}\nfunction Ke(o) {\n  return S(() => {\n    var t;\n    return ge(o) ? !!((t = ve(o)) != null && t.closest(\"form\")) : !0;\n  });\n}\nfunction It(o) {\n  const t = Fe(), e = Object.keys((t == null ? void 0 : t.type.props) ?? {}).reduce((n, s) => {\n    const l = (t == null ? void 0 : t.type.props[s]).default;\n    return l !== void 0 && (n[s] = l), n;\n  }, {});\n  return mo(() => ({ ...o }), () => {\n    const n = {}, s = (t == null ? void 0 : t.vnode.props) ?? {};\n    return Object.keys(s).forEach((l) => {\n      n[mn(l)] = s[l];\n    }), Object.keys({ ...e, ...n }).reduce((l, i) => (o[i] !== void 0 && (l[i] = o[i]), l), {});\n  });\n}\nfunction pe(o, t) {\n  const e = It(o), n = t ? ce(t) : {};\n  return S(() => ({\n    ...e.value,\n    ...n\n  }));\n}\nfunction be() {\n  const o = Fe();\n  function t(e) {\n    typeof e == \"object\" && (o.exposed = e, o.exposeProxy = e);\n  }\n  return t;\n}\nvar fs = function(o) {\n  if (typeof document > \"u\")\n    return null;\n  var t = Array.isArray(o) ? o[0] : o;\n  return t.ownerDocument.body;\n}, ze = /* @__PURE__ */ new WeakMap(), bt = /* @__PURE__ */ new WeakMap(), Ct = {}, Qt = 0, En = function(o) {\n  return o && (o.host || En(o.parentNode));\n}, vs = function(o, t) {\n  return t.map(function(e) {\n    if (o.contains(e))\n      return e;\n    var n = En(e);\n    return n && o.contains(n) ? n : (console.error(\"aria-hidden\", e, \"in not contained inside\", o, \". Doing nothing\"), null);\n  }).filter(function(e) {\n    return !!e;\n  });\n}, ms = function(o, t, e, n) {\n  var s = vs(t, Array.isArray(o) ? o : [o]);\n  Ct[e] || (Ct[e] = /* @__PURE__ */ new WeakMap());\n  var l = Ct[e], i = [], r = /* @__PURE__ */ new Set(), u = new Set(s), d = function(p) {\n    !p || r.has(p) || (r.add(p), d(p.parentNode));\n  };\n  s.forEach(d);\n  var c = function(p) {\n    !p || u.has(p) || Array.prototype.forEach.call(p.children, function(f) {\n      if (r.has(f))\n        c(f);\n      else {\n        var m = f.getAttribute(n), C = m !== null && m !== \"false\", w = (ze.get(f) || 0) + 1, $ = (l.get(f) || 0) + 1;\n        ze.set(f, w), l.set(f, $), i.push(f), w === 1 && C && bt.set(f, !0), $ === 1 && f.setAttribute(e, \"true\"), C || f.setAttribute(n, \"true\");\n      }\n    });\n  };\n  return c(t), r.clear(), Qt++, function() {\n    i.forEach(function(p) {\n      var f = ze.get(p) - 1, m = l.get(p) - 1;\n      ze.set(p, f), l.set(p, m), f || (bt.has(p) || p.removeAttribute(n), bt.delete(p)), m || p.removeAttribute(e);\n    }), Qt--, Qt || (ze = /* @__PURE__ */ new WeakMap(), ze = /* @__PURE__ */ new WeakMap(), bt = /* @__PURE__ */ new WeakMap(), Ct = {});\n  };\n}, hs = function(o, t, e) {\n  e === void 0 && (e = \"data-aria-hidden\");\n  var n = Array.from(Array.isArray(o) ? o : [o]), s = t || fs(o);\n  return s ? (n.push.apply(n, Array.from(s.querySelectorAll(\"[aria-live]\"))), ms(n, s, e, \"aria-hidden\")) : function() {\n    return null;\n  };\n};\nfunction ft(o) {\n  let t;\n  Y(() => ve(o), (e) => {\n    e ? t = hs(e) : t && t();\n  }), fe(() => {\n    t && t();\n  });\n}\nconst ys = Tt(() => ({ count: B(0) }));\nfunction te(o) {\n  const { count: t } = ys();\n  return o || t.value++, o || `radix-${t.value}`;\n}\nfunction xn(o) {\n  const t = B(), e = S(() => {\n    var s;\n    return ((s = t.value) == null ? void 0 : s.width) ?? 0;\n  }), n = S(() => {\n    var s;\n    return ((s = t.value) == null ? void 0 : s.height) ?? 0;\n  });\n  return U(() => {\n    const s = ve(o);\n    if (s) {\n      t.value = { width: s.offsetWidth, height: s.offsetHeight };\n      const l = new ResizeObserver((i) => {\n        if (!Array.isArray(i) || !i.length)\n          return;\n        const r = i[0];\n        let u, d;\n        if (\"borderBoxSize\" in r) {\n          const c = r.borderBoxSize, p = Array.isArray(c) ? c[0] : c;\n          u = p.inlineSize, d = p.blockSize;\n        } else\n          u = s.offsetWidth, d = s.offsetHeight;\n        t.value = { width: u, height: d };\n      });\n      return l.observe(s, { box: \"border-box\" }), () => l.unobserve(s);\n    } else\n      t.value = void 0;\n  }), {\n    width: e,\n    height: n\n  };\n}\nfunction $n(o, t) {\n  const e = B(o);\n  function n(l) {\n    return t[e.value][l] ?? e.value;\n  }\n  return {\n    state: e,\n    dispatch: (l) => {\n      e.value = n(l);\n    }\n  };\n}\nfunction _o(o) {\n  const t = ho(\"\", 1e3);\n  return {\n    search: t,\n    handleTypeaheadSearch: (s) => {\n      var p, f;\n      t.value = t.value + s;\n      const l = o.value, i = document.activeElement, r = ((f = (p = l.find((m) => m === i)) == null ? void 0 : p.textContent) == null ? void 0 : f.trim()) ?? \"\", u = l.map((m) => {\n        var C;\n        return ((C = m.textContent) == null ? void 0 : C.trim()) ?? \"\";\n      }), d = gs(u, t.value, r), c = l.find(\n        (m) => {\n          var C;\n          return ((C = m.textContent) == null ? void 0 : C.trim()) === d;\n        }\n      );\n      c && c.focus();\n    },\n    resetTypeahead: () => {\n      t.value = \"\";\n    }\n  };\n}\nfunction wo(o, t) {\n  return o.map((e, n) => o[(t + n) % o.length]);\n}\nfunction gs(o, t, e) {\n  const s = t.length > 1 && Array.from(t).every((d) => d === t[0]) ? t[0] : t, l = e ? o.indexOf(e) : -1;\n  let i = wo(o, Math.max(l, 0));\n  s.length === 1 && (i = i.filter((d) => d !== e));\n  const u = i.find(\n    (d) => d.toLowerCase().startsWith(s.toLowerCase())\n  );\n  return u !== e ? u : void 0;\n}\nfunction Gr(o, t) {\n  return {\n    inheritAttrs: !1,\n    name: `${o.__name ?? \"\"}Wrapper`,\n    setup(e, n) {\n      return () => {\n        const s = typeof (t == null ? void 0 : t.props) == \"function\" ? t == null ? void 0 : t.props(n.attrs) : t == null ? void 0 : t.props, l = be(), i = T(s, n.attrs);\n        return Re(o, { ...i, ref: l }, n.slots);\n      };\n    }\n  };\n}\nconst Eo = g({\n  name: \"PrimitiveSlot\",\n  inheritAttrs: !1,\n  setup(o, { attrs: t, slots: e }) {\n    return () => {\n      var i, r;\n      if (!e.default)\n        return null;\n      const n = Ot(e.default()), [s, ...l] = n;\n      if (Object.keys(t).length > 0) {\n        (i = s.props) == null || delete i.ref;\n        const u = T(t, s.props ?? {});\n        t.class && ((r = s.props) != null && r.class) && delete s.props.class;\n        const d = Ma(s, u);\n        for (const c in u)\n          c.startsWith(\"on\") && (d.props || (d.props = {}), d.props[c] = u[c]);\n        return n.length === 1 ? d : [d, ...l];\n      }\n      return n;\n    };\n  }\n}), D = g({\n  name: \"Primitive\",\n  inheritAttrs: !1,\n  props: {\n    asChild: {\n      type: Boolean,\n      default: !1\n    },\n    as: {\n      type: [String, Object],\n      default: \"div\"\n    }\n  },\n  setup(o, { attrs: t, slots: e }) {\n    return (o.asChild ? \"template\" : o.as) !== \"template\" ? () => Re(o.as, t, { default: e.default }) : () => Re(Eo, t, { default: e.default });\n  }\n});\nfunction V() {\n  const o = B(), t = S(() => {\n    var e, n;\n    return [\"#text\", \"#comment\"].includes((e = o.value) == null ? void 0 : e.$el.nodeName) ? (n = o.value) == null ? void 0 : n.$el.nextElementSibling : ve(o);\n  });\n  return {\n    primitiveElement: o,\n    currentElement: t\n  };\n}\nconst [Bn, bs] = H(\"CollapsibleRoot\"), Cs = /* @__PURE__ */ g({\n  __name: \"CollapsibleRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:open\"],\n  setup(o, { expose: t, emit: e }) {\n    const n = o, l = X(n, \"open\", e, {\n      defaultValue: n.defaultOpen,\n      passive: n.open === void 0\n    }), i = X(n, \"disabled\");\n    return bs({\n      contentId: te(),\n      disabled: i,\n      open: l,\n      onOpenToggle: () => {\n        l.value = !l.value;\n      }\n    }), t({ open: l }), (r, u) => (h(), b(a(D), {\n      as: r.as,\n      \"as-child\": n.asChild,\n      \"data-state\": n.open ? \"open\" : \"closed\",\n      \"data-disabled\": n.disabled ? \"\" : void 0\n    }, {\n      default: v(() => [\n        y(r.$slots, \"default\", { open: a(l) })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-state\", \"data-disabled\"]));\n  }\n}), _s = /* @__PURE__ */ g({\n  __name: \"CollapsibleTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = Bn();\n    return (n, s) => {\n      var l, i;\n      return h(), b(a(D), {\n        type: n.as === \"button\" ? \"button\" : void 0,\n        as: n.as,\n        \"as-child\": t.asChild,\n        \"aria-controls\": a(e).contentId,\n        \"aria-expanded\": a(e).open.value,\n        \"data-state\": a(e).open.value ? \"open\" : \"closed\",\n        \"data-disabled\": (l = a(e).disabled) != null && l.value ? \"\" : void 0,\n        disabled: (i = a(e).disabled) == null ? void 0 : i.value,\n        onClick: a(e).onOpenToggle\n      }, {\n        default: v(() => [\n          y(n.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"type\", \"as\", \"as-child\", \"aria-controls\", \"aria-expanded\", \"data-state\", \"data-disabled\", \"disabled\", \"onClick\"]);\n    };\n  }\n});\nfunction ws(o, t) {\n  const e = B({}), n = B(\"none\"), s = o.value ? \"mounted\" : \"unmounted\", { state: l, dispatch: i } = $n(s, {\n    mounted: {\n      UNMOUNT: \"unmounted\",\n      ANIMATION_OUT: \"unmountSuspended\"\n    },\n    unmountSuspended: {\n      MOUNT: \"mounted\",\n      ANIMATION_END: \"unmounted\"\n    },\n    unmounted: {\n      MOUNT: \"mounted\"\n    }\n  });\n  Y(\n    o,\n    async (f, m) => {\n      var w;\n      const C = m !== f;\n      if (await G(), C) {\n        const $ = n.value, _ = _t(t.value);\n        f ? i(\"MOUNT\") : _ === \"none\" || ((w = e.value) == null ? void 0 : w.display) === \"none\" ? i(\"UNMOUNT\") : i(m && $ !== _ ? \"ANIMATION_OUT\" : \"UNMOUNT\");\n      }\n    },\n    { immediate: !0 }\n  );\n  const r = (f) => {\n    const m = _t(t.value), C = m.includes(\n      f.animationName\n    );\n    f.target === t.value && C && i(\"ANIMATION_END\"), f.target === t.value && m === \"none\" && i(\"ANIMATION_END\");\n  }, u = (f) => {\n    f.target === t.value && (n.value = _t(t.value));\n  }, d = Y(\n    t,\n    (f, m) => {\n      f ? (e.value = getComputedStyle(f), f.addEventListener(\"animationstart\", u), f.addEventListener(\"animationcancel\", r), f.addEventListener(\"animationend\", r)) : (i(\"ANIMATION_END\"), m == null || m.removeEventListener(\"animationstart\", u), m == null || m.removeEventListener(\"animationcancel\", r), m == null || m.removeEventListener(\"animationend\", r));\n    },\n    { immediate: !0 }\n  ), c = Y(l, () => {\n    const f = _t(t.value);\n    n.value = l.value === \"mounted\" ? f : \"none\";\n  });\n  return fe(() => {\n    d(), c();\n  }), {\n    isPresent: S(\n      () => [\"mounted\", \"unmountSuspended\"].includes(l.value)\n    )\n  };\n}\nfunction _t(o) {\n  return o && getComputedStyle(o).animationName || \"none\";\n}\nconst se = g({\n  name: \"Presence\",\n  props: {\n    present: {\n      type: Boolean,\n      required: !0\n    },\n    forceMount: {\n      type: Boolean\n    }\n  },\n  slots: {},\n  setup(o, { slots: t, expose: e }) {\n    var d;\n    const { present: n, forceMount: s } = z(o), l = B(), { isPresent: i } = ws(n, l);\n    e({ present: i });\n    let r = t.default({ present: i });\n    r = Ot(r || []);\n    const u = Fe();\n    if (r && (r == null ? void 0 : r.length) > 1) {\n      const c = (d = u == null ? void 0 : u.parent) != null && d.type.name ? `<${u.parent.type.name} />` : \"component\";\n      throw new Error(\n        [\n          `Detected an invalid children for \\`${c}\\` for  \\`Presence\\` component.`,\n          \"\",\n          \"Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.\",\n          \"You can apply a few solutions:\",\n          [\n            \"Provide a single child element so that `presence` directive attach correctly.rv\",\n            \"Ensure the first child is an actual element instead of a raw text node or comment node.\"\n          ].map((p) => `  - ${p}`).join(`\n`)\n        ].join(`\n`)\n      );\n    }\n    return () => s.value || n.value || i.value ? Re(t.default({ present: i })[0], {\n      ref: (c) => {\n        const p = ve(c);\n        return typeof (p == null ? void 0 : p.hasAttribute) > \"u\" || (p != null && p.hasAttribute(\"data-radix-popper-content-wrapper\") ? l.value = p.firstChild : l.value = p), p;\n      }\n    }) : null;\n  }\n}), Es = /* @__PURE__ */ g({\n  inheritAttrs: !1,\n  __name: \"CollapsibleContent\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = Bn(), n = B(), { primitiveElement: s, currentElement: l } = V(), i = B(0), r = B(0), u = S(() => e.open.value), d = B(u.value), c = B();\n    return Y(\n      () => {\n        var p;\n        return [u.value, (p = n.value) == null ? void 0 : p.present];\n      },\n      async () => {\n        await G();\n        const p = l.value;\n        if (!p)\n          return;\n        c.value = c.value || {\n          transitionDuration: p.style.transitionDuration,\n          animationName: p.style.animationName\n        }, p.style.transitionDuration = \"0s\", p.style.animationName = \"none\";\n        const f = p.getBoundingClientRect();\n        r.value = f.height, i.value = f.width, d.value || (p.style.transitionDuration = c.value.transitionDuration, p.style.animationName = c.value.animationName);\n      },\n      {\n        immediate: !0\n      }\n    ), U(() => {\n      requestAnimationFrame(() => {\n        d.value = !1;\n      });\n    }), (p, f) => (h(), b(a(se), {\n      ref_key: \"presentRef\",\n      ref: n,\n      present: p.forceMount || a(e).open.value,\n      \"force-mount\": !0\n    }, {\n      default: v(() => {\n        var m, C;\n        return [\n          k(a(D), T(p.$attrs, {\n            id: a(e).contentId,\n            ref_key: \"primitiveElement\",\n            ref: s,\n            \"as-child\": t.asChild,\n            as: p.as,\n            \"data-state\": a(e).open.value ? \"open\" : \"closed\",\n            \"data-disabled\": (m = a(e).disabled) != null && m.value ? \"true\" : void 0,\n            hidden: !((C = n.value) != null && C.present),\n            style: {\n              \"--radix-collapsible-content-height\": `${r.value}px`,\n              \"--radix-collapsible-content-width\": `${i.value}px`\n            }\n          }), {\n            default: v(() => {\n              var w;\n              return [\n                (w = n.value) != null && w.present ? y(p.$slots, \"default\", { key: 0 }) : J(\"\", !0)\n              ];\n            }),\n            _: 3\n          }, 16, [\"id\", \"as-child\", \"as\", \"data-state\", \"data-disabled\", \"hidden\", \"style\"])\n        ];\n      }),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n});\nfunction xs(o, t) {\n  if (o === \"single\") {\n    if (Array.isArray(t)) {\n      console.error(`Invalid prop \\`value\\` of value \\`${t}\\` supplied to \\`AccordionRoot\\`, which type is \\`single\\`. The \\`value\\` prop must be:\n  - a string\n  - \\`undefined\\`\n\nIf you want to use multiple values, use the \\`AccordionRoot\\` with type \\`multiple\\`.\n\nDefaulting to \\`undefined\\`.`);\n      return;\n    }\n  } else if (o === \"multiple\" && (typeof t == \"string\" || typeof t > \"u\"))\n    return console.error(`Invalid prop \\`value\\` of value \\`${t}\\` supplied to \\`AccordionRoot\\`, which type is \\`multiple\\`. The \\`value\\` prop must be:\n- an array of strings\n- empty array (\\`[]\\`)\n\nIf you want to use just one value, use the \\`AccordionRoot\\` with type \\`single\\`.\n\nDefaulting to empty array (\\`[]\\`).`), [];\n  return t;\n}\nfunction $s({ type: o, defaultValue: t }) {\n  if (o === \"multiple\")\n    return Array.isArray(t) ? t : t === void 0 ? [] : (console.error(\n      `Invalid prop \\`defaultValue\\` of value \\`${t}\\` supplied to \\`AccordionRoot\\`, which type is \\`multiple\\`. The \\`defaultValue\\` prop must be:\n  - an array of strings\n  - empty array (\\`[]\\`)\n\nIf you want to use just one value, use the \\`AccordionRoot\\` with type \\`single\\`.\n\nDefaulting to empty array (\\`[]\\`).`\n    ), []);\n  if (o === \"single\") {\n    if (typeof t == \"string\")\n      return t;\n    if (t === void 0)\n      return;\n    console.error(\n      `Invalid prop \\`defaultValue\\` of value \\`${t}\\` supplied to \\`AccordionRoot\\`, which type is \\`single\\`. The \\`defaultValue\\` prop must be:\n  - a string\n  - \\`undefined\\`\n\nDefaulting to \\`undefined\\`.`\n    );\n    return;\n  }\n}\nfunction Pn(o, t) {\n  const e = X(o, \"modelValue\", t, {\n    defaultValue: $s(o),\n    passive: o.modelValue === void 0\n  });\n  Y(\n    () => [o.type, o.modelValue],\n    () => {\n      const s = xs(o.type, e.value);\n      e.value !== s && (e.value = s);\n    },\n    { immediate: !0 }\n  );\n  function n(s) {\n    if (o.type === \"single\")\n      e.value = s === e.value ? void 0 : s;\n    else {\n      const l = e.value || [];\n      if (l.includes(s)) {\n        const i = l.findIndex((r) => r === s);\n        l.splice(i, 1);\n      } else\n        l.push(s);\n      e.value = l, t(\"update:modelValue\", e.value);\n    }\n  }\n  return {\n    modelValue: e,\n    changeModelValue: n\n  };\n}\nconst [At, Bs] = H(\"AccordionRoot\"), Yr = /* @__PURE__ */ g({\n  __name: \"AccordionRoot\",\n  props: {\n    type: {},\n    modelValue: {},\n    defaultValue: {},\n    collapsible: { type: Boolean, default: !1 },\n    disabled: { type: Boolean, default: !1 },\n    dir: {},\n    orientation: { default: \"vertical\" },\n    asChild: { type: Boolean, default: !1 },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { expose: t, emit: e }) {\n    const n = o, s = e, { dir: l, disabled: i } = z(n), r = de(l), { modelValue: u, changeModelValue: d } = Pn(n, s), { primitiveElement: c, currentElement: p } = V();\n    return Bs({\n      disabled: i,\n      direction: r,\n      orientation: n.orientation,\n      parentElement: p,\n      isSingle: S(() => n.type === \"single\"),\n      collapsible: n.collapsible,\n      modelValue: u,\n      changeModelValue: d\n    }), t({\n      modelValue: u\n    }), (f, m) => (h(), b(a(D), {\n      ref_key: \"primitiveElement\",\n      ref: c,\n      \"as-child\": f.asChild,\n      as: f.as\n    }, {\n      default: v(() => [\n        y(f.$slots, \"default\", { modelValue: a(u) })\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"]));\n  }\n}), [xo, Ps] = H(\"AccordionItem\"), Xr = /* @__PURE__ */ g({\n  __name: \"AccordionItem\",\n  props: {\n    disabled: { type: Boolean },\n    value: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o, { expose: t }) {\n    const e = o, n = At(), s = S(\n      () => n.isSingle.value ? e.value === n.modelValue.value : Array.isArray(n.modelValue.value) && n.modelValue.value.includes(e.value)\n    ), l = S(() => n.disabled.value || e.disabled || n.isSingle.value && s.value && !n.collapsible), i = S(() => l.value ? \"\" : void 0), r = S(\n      () => s.value ? \"open\" : \"closed\"\n      /* Closed */\n    ), { primitiveElement: u, currentElement: d } = V();\n    Ps({\n      open: s,\n      dataState: r,\n      disabled: l,\n      dataDisabled: i,\n      triggerId: te(),\n      primitiveElement: u,\n      currentElement: d,\n      value: S(() => e.value)\n    });\n    function c(p) {\n      qe(\n        p,\n        d.value,\n        n.parentElement.value,\n        {\n          arrowKeyOptions: n.orientation,\n          dir: n.direction.value,\n          focus: !0\n        }\n      );\n    }\n    return t({ open: s }), (p, f) => (h(), b(a(Cs), {\n      \"data-orientation\": a(n).orientation,\n      \"data-disabled\": i.value,\n      \"data-state\": r.value,\n      disabled: l.value,\n      open: s.value,\n      \"as-child\": e.asChild,\n      onKeydown: le(c, [\"up\", \"down\", \"left\", \"right\", \"home\", \"end\"])\n    }, {\n      default: v(() => [\n        y(p.$slots, \"default\", { open: s.value })\n      ]),\n      _: 3\n    }, 8, [\"data-orientation\", \"data-disabled\", \"data-state\", \"disabled\", \"open\", \"as-child\", \"onKeydown\"]));\n  }\n}), Jr = /* @__PURE__ */ g({\n  __name: \"AccordionContent\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = At(), n = xo();\n    return (s, l) => (h(), b(a(Es), {\n      id: a(n).triggerId,\n      role: \"region\",\n      open: a(n).open.value,\n      hidden: !a(n).open.value,\n      \"as-child\": t.asChild,\n      \"aria-labelledby\": a(n).triggerId,\n      \"data-state\": a(n).dataState.value,\n      \"data-disabled\": a(n).dataDisabled.value,\n      \"data-orientation\": a(e).orientation,\n      style: { \"--radix-accordion-content-width\": \"var(--radix-collapsible-content-width)\", \"--radix-accordion-content-height\": \"var(--radix-collapsible-content-height)\" }\n    }, {\n      default: v(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"id\", \"open\", \"hidden\", \"as-child\", \"aria-labelledby\", \"data-state\", \"data-disabled\", \"data-orientation\"]));\n  }\n}), Zr = /* @__PURE__ */ g({\n  __name: \"AccordionHeader\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"h3\" }\n  },\n  setup(o) {\n    const t = o, e = At(), n = xo();\n    return (s, l) => (h(), b(a(D), {\n      as: t.as,\n      \"as-child\": t.asChild,\n      \"data-orientation\": a(e).orientation,\n      \"data-state\": a(n).dataState.value,\n      \"data-disabled\": a(n).dataDisabled.value\n    }, {\n      default: v(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-orientation\", \"data-state\", \"data-disabled\"]));\n  }\n}), Qr = /* @__PURE__ */ g({\n  __name: \"AccordionTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = At(), n = xo();\n    function s() {\n      n.disabled.value || e.changeModelValue(n.value.value);\n    }\n    return (l, i) => (h(), b(a(_s), {\n      id: a(n).triggerId,\n      ref: a(n).primitiveElement,\n      \"data-radix-vue-collection-item\": \"\",\n      as: t.as,\n      \"as-child\": t.asChild,\n      \"aria-controls\": a(n).triggerId,\n      \"aria-disabled\": a(n).disabled.value || void 0,\n      \"aria-expanded\": a(n).open.value || !1,\n      \"data-disabled\": a(n).dataDisabled.value,\n      \"data-orientation\": a(e).orientation,\n      \"data-state\": a(n).dataState.value,\n      disabled: a(n).disabled.value,\n      onClick: s\n    }, {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"id\", \"as\", \"as-child\", \"aria-controls\", \"aria-disabled\", \"aria-expanded\", \"data-disabled\", \"data-orientation\", \"data-state\", \"disabled\"]));\n  }\n}), [ye, Ss] = H(\"DialogRoot\"), Ts = /* @__PURE__ */ g({\n  __name: \"DialogRoot\",\n  props: {\n    open: { type: Boolean, default: void 0 },\n    defaultOpen: { type: Boolean, default: !1 },\n    modal: { type: Boolean, default: !0 }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, s = X(e, \"open\", t, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), l = B(), i = B(), { modal: r } = z(e);\n    return Ss({\n      open: s,\n      modal: r,\n      openModal: () => {\n        s.value = !0;\n      },\n      onOpenChange: (u) => {\n        s.value = u;\n      },\n      onOpenToggle: () => {\n        s.value = !s.value;\n      },\n      contentId: te(),\n      titleId: te(),\n      descriptionId: te(),\n      triggerElement: l,\n      contentElement: i\n    }), (u, d) => y(u.$slots, \"default\");\n  }\n}), Ds = /* @__PURE__ */ g({\n  __name: \"DialogTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = ye(), { primitiveElement: n, currentElement: s } = V();\n    return U(() => {\n      e.triggerElement = s;\n    }), (l, i) => (h(), b(a(D), T({\n      ref_key: \"primitiveElement\",\n      ref: n\n    }, t, {\n      type: l.as === \"button\" ? \"button\" : void 0,\n      \"aria-haspopup\": \"dialog\",\n      \"aria-expanded\": a(e).open.value || !1,\n      \"aria-controls\": a(e).contentId,\n      \"data-state\": a(e).open.value ? \"open\" : \"closed\",\n      onClick: a(e).onOpenToggle\n    }), {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"aria-expanded\", \"aria-controls\", \"data-state\", \"onClick\"]));\n  }\n}), Pe = /* @__PURE__ */ g({\n  __name: \"Teleport\",\n  props: {\n    to: { default: \"body\" },\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = Dt();\n    return (e, n) => a(t) || e.forceMount ? (h(), b(Ue, {\n      key: 0,\n      to: e.to,\n      disabled: e.disabled\n    }, [\n      y(e.$slots, \"default\")\n    ], 8, [\"to\", \"disabled\"])) : J(\"\", !0);\n  }\n}), eu = /* @__PURE__ */ g({\n  __name: \"DialogPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Pe), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Os = \"dismissableLayer.pointerDownOutside\", Is = \"dismissableLayer.focusOutside\";\nfunction Sn(o, t) {\n  const e = t.closest(\n    \"[data-dismissable-layer]\"\n  ), n = o.querySelector(\n    \"[data-dismissable-layer]\"\n  ), s = Array.from(\n    o.ownerDocument.querySelectorAll(\"[data-dismissable-layer]\")\n  );\n  return !!(e && n === e || s.indexOf(n) < s.indexOf(e));\n}\nfunction As(o, t) {\n  var l;\n  const e = ((l = t == null ? void 0 : t.value) == null ? void 0 : l.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), n = B(!1), s = B(() => {\n  });\n  return ee((i) => {\n    if (!Be)\n      return;\n    const r = async (d) => {\n      if (t != null && t.value) {\n        if (Sn(t.value, d.target)) {\n          n.value = !1;\n          return;\n        }\n        if (d.target && !n.value) {\n          let c = function() {\n            vo(\n              Os,\n              o,\n              p\n            );\n          };\n          const p = { originalEvent: d };\n          d.pointerType === \"touch\" ? (e.removeEventListener(\"click\", s.value), s.value = c, e.addEventListener(\"click\", s.value, {\n            once: !0\n          })) : c();\n        } else\n          e.removeEventListener(\"click\", s.value);\n        n.value = !1;\n      }\n    }, u = window.setTimeout(() => {\n      e.addEventListener(\"pointerdown\", r);\n    }, 0);\n    i(() => {\n      window.clearTimeout(u), e.removeEventListener(\"pointerdown\", r), e.removeEventListener(\"click\", s.value);\n    });\n  }), {\n    onPointerDownCapture: () => n.value = !0\n  };\n}\nfunction Ms(o, t) {\n  var s;\n  const e = ((s = t == null ? void 0 : t.value) == null ? void 0 : s.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), n = B(!1);\n  return ee((l) => {\n    if (!Be)\n      return;\n    const i = async (r) => {\n      t != null && t.value && (await G(), !Sn(t.value, r.target) && r.target && !n.value && vo(\n        Is,\n        o,\n        { originalEvent: r }\n      ));\n    };\n    e.addEventListener(\"focusin\", i), l(() => e.removeEventListener(\"focusin\", i));\n  }), {\n    onFocusCapture: () => n.value = !0,\n    onBlurCapture: () => n.value = !1\n  };\n}\nconst he = hn({\n  layersRoot: /* @__PURE__ */ new Set(),\n  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),\n  branches: /* @__PURE__ */ new Set()\n}), Se = /* @__PURE__ */ g({\n  __name: \"DismissableLayer\",\n  props: {\n    disableOutsidePointerEvents: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { primitiveElement: s, currentElement: l } = V(), i = S(\n      () => {\n        var C;\n        return ((C = l.value) == null ? void 0 : C.ownerDocument) ?? globalThis.document;\n      }\n    ), r = S(() => he.layersRoot), u = S(() => l.value ? Array.from(r.value).indexOf(l.value) : -1), d = S(() => he.layersWithOutsidePointerEventsDisabled.size > 0), c = S(() => {\n      const C = Array.from(r.value), [w] = [...he.layersWithOutsidePointerEventsDisabled].slice(-1), $ = C.indexOf(w);\n      return u.value >= $;\n    }), p = As(async (C) => {\n      const w = [...he.branches].some(\n        ($) => $.contains(C.target)\n      );\n      !c.value || w || (n(\"pointerDownOutside\", C), n(\"interactOutside\", C), await G(), C.defaultPrevented || n(\"dismiss\"));\n    }, l), f = Ms((C) => {\n      [...he.branches].some(\n        ($) => $.contains(C.target)\n      ) || (n(\"focusOutside\", C), n(\"interactOutside\", C), C.defaultPrevented || n(\"dismiss\"));\n    }, l);\n    bo(\"Escape\", (C) => {\n      u.value === r.value.size - 1 && (n(\"escapeKeyDown\", C), C.defaultPrevented || n(\"dismiss\"));\n    });\n    let m;\n    return ee((C) => {\n      l.value && (e.disableOutsidePointerEvents && (he.layersWithOutsidePointerEventsDisabled.size === 0 && (m = i.value.body.style.pointerEvents, i.value.body.style.pointerEvents = \"none\"), he.layersWithOutsidePointerEventsDisabled.add(l.value)), r.value.add(l.value), C(() => {\n        e.disableOutsidePointerEvents && he.layersWithOutsidePointerEventsDisabled.size === 1 && (i.value.body.style.pointerEvents = m);\n      }));\n    }), ee((C) => {\n      C(() => {\n        l.value && (r.value.delete(l.value), he.layersWithOutsidePointerEventsDisabled.delete(l.value));\n      });\n    }), (C, w) => (h(), b(a(D), {\n      ref_key: \"primitiveElement\",\n      ref: s,\n      \"as-child\": C.asChild,\n      as: C.as,\n      \"data-dismissable-layer\": \"\",\n      style: ae({\n        pointerEvents: d.value ? c.value ? \"auto\" : \"none\" : void 0\n      }),\n      onFocusCapture: a(f).onFocusCapture,\n      onBlurCapture: a(f).onBlurCapture,\n      onPointerdownCapture: a(p).onPointerDownCapture\n    }, {\n      default: v(() => [\n        y(C.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"style\", \"onFocusCapture\", \"onBlurCapture\", \"onPointerdownCapture\"]));\n  }\n}), ks = /* @__PURE__ */ g({\n  __name: \"DismissableLayerBranch\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { primitiveElement: e, currentElement: n } = V();\n    return U(() => {\n      he.branches.add(n.value);\n    }), fe(() => {\n      he.branches.delete(n.value);\n    }), (s, l) => (h(), b(a(D), T({\n      ref_key: \"primitiveElement\",\n      ref: e\n    }, t), {\n      default: v(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), eo = \"focusScope.autoFocusOnMount\", to = \"focusScope.autoFocusOnUnmount\", nn = { bubbles: !1, cancelable: !0 };\nfunction $t(o, { select: t = !1 } = {}) {\n  const e = document.activeElement;\n  for (const n of o)\n    if (xe(n, { select: t }), document.activeElement !== e)\n      return !0;\n}\nfunction Rs(o) {\n  const t = $o(o), e = an(t, o), n = an(t.reverse(), o);\n  return [e, n];\n}\nfunction $o(o) {\n  const t = [], e = document.createTreeWalker(o, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (n) => {\n      const s = n.tagName === \"INPUT\" && n.type === \"hidden\";\n      return n.disabled || n.hidden || s ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  for (; e.nextNode(); )\n    t.push(e.currentNode);\n  return t;\n}\nfunction an(o, t) {\n  for (const e of o)\n    if (!Vs(e, { upTo: t }))\n      return e;\n}\nfunction Vs(o, { upTo: t }) {\n  if (getComputedStyle(o).visibility === \"hidden\")\n    return !0;\n  for (; o; ) {\n    if (t !== void 0 && o === t)\n      return !1;\n    if (getComputedStyle(o).display === \"none\")\n      return !0;\n    o = o.parentElement;\n  }\n  return !1;\n}\nfunction Fs(o) {\n  return o instanceof HTMLInputElement && \"select\" in o;\n}\nfunction xe(o, { select: t = !1 } = {}) {\n  if (o && o.focus) {\n    const e = document.activeElement;\n    o.focus({ preventScroll: !0 }), o !== e && Fs(o) && t && o.select();\n  }\n}\nconst Ls = Tt(() => B([]));\nfunction Ks() {\n  const o = Ls();\n  return {\n    add(t) {\n      const e = o.value[0];\n      t !== e && (e == null || e.pause()), o.value = sn(o.value, t), o.value.unshift(t);\n    },\n    remove(t) {\n      var e;\n      o.value = sn(o.value, t), (e = o.value[0]) == null || e.resume();\n    }\n  };\n}\nfunction sn(o, t) {\n  const e = [...o], n = e.indexOf(t);\n  return n !== -1 && e.splice(n, 1), e;\n}\nfunction Ns(o) {\n  return o.filter((t) => t.tagName !== \"A\");\n}\nconst Mt = /* @__PURE__ */ g({\n  __name: \"FocusScope\",\n  props: {\n    loop: { type: Boolean, default: !1 },\n    trapped: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"mountAutoFocus\", \"unmountAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { primitiveElement: s, currentElement: l } = V(), i = B(null), r = Ks(), u = hn({\n      paused: !1,\n      pause() {\n        this.paused = !0;\n      },\n      resume() {\n        this.paused = !1;\n      }\n    });\n    ee((c) => {\n      if (!Be)\n        return;\n      const p = l.value;\n      if (!e.trapped)\n        return;\n      function f($) {\n        if (u.paused || !p)\n          return;\n        const _ = $.target;\n        p.contains(_) ? i.value = _ : xe(i.value, { select: !0 });\n      }\n      function m($) {\n        if (u.paused || !p)\n          return;\n        const _ = $.relatedTarget;\n        _ !== null && (p.contains(_) || xe(i.value, { select: !0 }));\n      }\n      function C($) {\n        p.contains(i.value) || xe(p);\n      }\n      document.addEventListener(\"focusin\", f), document.addEventListener(\"focusout\", m);\n      const w = new MutationObserver(C);\n      p && w.observe(p, { childList: !0, subtree: !0 }), c(() => {\n        document.removeEventListener(\"focusin\", f), document.removeEventListener(\"focusout\", m), w.disconnect();\n      });\n    }), ee(async (c) => {\n      const p = l.value;\n      if (await G(), !p)\n        return;\n      r.add(u);\n      const f = document.activeElement;\n      if (!p.contains(f)) {\n        const C = new CustomEvent(eo, nn);\n        p.addEventListener(\n          eo,\n          (w) => n(\"mountAutoFocus\", w)\n        ), p.dispatchEvent(C), C.defaultPrevented || ($t(Ns($o(p)), {\n          select: !0\n        }), document.activeElement === f && xe(p));\n      }\n      c(() => {\n        p.removeEventListener(\n          eo,\n          ($) => n(\"mountAutoFocus\", $)\n        );\n        const C = new CustomEvent(to, nn), w = ($) => {\n          n(\"unmountAutoFocus\", $);\n        };\n        p.addEventListener(to, w), p.dispatchEvent(C), setTimeout(() => {\n          C.defaultPrevented || xe(f ?? document.body, { select: !0 }), p.removeEventListener(to, w), r.remove(u);\n        }, 0);\n      });\n    });\n    function d(c) {\n      if (!e.loop && !e.trapped || u.paused)\n        return;\n      const p = c.key === \"Tab\" && !c.altKey && !c.ctrlKey && !c.metaKey, f = document.activeElement;\n      if (p && f) {\n        const m = c.currentTarget, [C, w] = Rs(m);\n        C && w ? !c.shiftKey && f === w ? (c.preventDefault(), e.loop && xe(C, { select: !0 })) : c.shiftKey && f === C && (c.preventDefault(), e.loop && xe(w, { select: !0 })) : f === m && c.preventDefault();\n      }\n    }\n    return (c, p) => (h(), b(a(D), {\n      ref_key: \"primitiveElement\",\n      ref: s,\n      tabindex: \"-1\",\n      \"as-child\": e.asChild,\n      as: e.as,\n      onKeydown: d\n    }, {\n      default: v(() => [\n        y(c.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"]));\n  }\n}), Hs = \"menu.itemSelect\", no = [\"Enter\", \" \"], Ws = [\"ArrowDown\", \"PageUp\", \"Home\"], Tn = [\"ArrowUp\", \"PageDown\", \"End\"], js = [...Ws, ...Tn], zs = {\n  ltr: [...no, \"ArrowRight\"],\n  rtl: [...no, \"ArrowLeft\"]\n}, Us = {\n  ltr: [\"ArrowLeft\"],\n  rtl: [\"ArrowRight\"]\n};\nfunction Bo(o) {\n  return o ? \"open\" : \"closed\";\n}\nfunction Pt(o) {\n  return o === \"indeterminate\";\n}\nfunction Po(o) {\n  return Pt(o) ? \"indeterminate\" : o ? \"checked\" : \"unchecked\";\n}\nfunction ao(o) {\n  const t = document.activeElement;\n  for (const e of o)\n    if (e === t || (e.focus(), document.activeElement !== t))\n      return;\n}\nfunction qs(o, t) {\n  const { x: e, y: n } = o;\n  let s = !1;\n  for (let l = 0, i = t.length - 1; l < t.length; i = l++) {\n    const r = t[l].x, u = t[l].y, d = t[i].x, c = t[i].y;\n    u > n != c > n && e < (d - r) * (n - u) / (c - u) + r && (s = !s);\n  }\n  return s;\n}\nfunction Gs(o, t) {\n  if (!t)\n    return !1;\n  const e = { x: o.clientX, y: o.clientY };\n  return qs(e, t);\n}\nfunction st(o) {\n  return o.pointerType === \"mouse\";\n}\nfunction Ys() {\n  const o = \"DialogContent\", t = \"DialogTitle\", e = ye(), n = `Warning: \\`${o}\\` requires a \\`${t}\\` for the component to be accessible for screen reader users.\n\nIf you want to hide the \\`${t}\\`, you can wrap it with our VisuallyHidden component.\n\nFor more information, see https://www.radix-vue.com/components/dialog.html#title;`, s = `Warning: Missing \\`Description\\` or \\`aria-describedby=\"undefined\"\\` for ${o}.`;\n  U(() => {\n    var r;\n    document.getElementById(e.titleId) || console.warn(n);\n    const i = (r = e.contentElement.value) == null ? void 0 : r.getAttribute(\"aria-describedby\");\n    e.descriptionId && i && (document.getElementById(e.descriptionId) || console.warn(s));\n  });\n}\nconst Dn = /* @__PURE__ */ g({\n  __name: \"DialogContentImpl\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = ye(), { primitiveElement: l, currentElement: i } = V();\n    return U(() => {\n      s.contentElement = i;\n    }), process.env.NODE_ENV !== \"production\" && Ys(), (r, u) => (h(), b(a(Mt), {\n      \"as-child\": \"\",\n      loop: \"\",\n      trapped: e.trapFocus,\n      onMountAutoFocus: u[5] || (u[5] = (d) => n(\"openAutoFocus\", d)),\n      onUnmountAutoFocus: u[6] || (u[6] = (d) => n(\"closeAutoFocus\", d))\n    }, {\n      default: v(() => [\n        k(a(Se), T({\n          id: a(s).contentId,\n          ref_key: \"primitiveElement\",\n          ref: l,\n          as: r.as,\n          \"as-child\": r.asChild,\n          \"disable-outside-pointer-events\": r.disableOutsidePointerEvents,\n          role: \"dialog\",\n          \"aria-describedby\": a(s).descriptionId,\n          \"aria-labelledby\": a(s).titleId,\n          \"data-state\": a(Bo)(a(s).open.value)\n        }, r.$attrs, {\n          onDismiss: u[0] || (u[0] = (d) => a(s).onOpenChange(!1)),\n          onEscapeKeyDown: u[1] || (u[1] = (d) => n(\"escapeKeyDown\", d)),\n          onFocusOutside: u[2] || (u[2] = (d) => n(\"focusOutside\", d)),\n          onInteractOutside: u[3] || (u[3] = (d) => n(\"interactOutside\", d)),\n          onPointerDownOutside: u[4] || (u[4] = (d) => n(\"pointerDownOutside\", d))\n        }), {\n          default: v(() => [\n            y(r.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"id\", \"as\", \"as-child\", \"disable-outside-pointer-events\", \"aria-describedby\", \"aria-labelledby\", \"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"trapped\"]));\n  }\n}), Xs = /* @__PURE__ */ g({\n  __name: \"DialogContentModal\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = ye(), l = ce(n), { primitiveElement: i, currentElement: r } = V();\n    return ft(r), (u, d) => (h(), b(Dn, T({\n      ref_key: \"primitiveElement\",\n      ref: i\n    }, { ...e, ...a(l) }, {\n      \"trap-focus\": a(s).open.value,\n      \"disable-outside-pointer-events\": !0,\n      onCloseAutoFocus: d[0] || (d[0] = (c) => {\n        var p;\n        n(\"closeAutoFocus\", c), c.defaultPrevented || (c.preventDefault(), (p = a(s).triggerElement.value) == null || p.focus());\n      }),\n      onPointerDownOutside: d[1] || (d[1] = (c) => {\n        const p = c.detail.originalEvent, f = p.button === 0 && p.ctrlKey === !0;\n        (p.button === 2 || f) && c.preventDefault();\n      }),\n      onFocusOutside: d[2] || (d[2] = (c) => {\n        c.preventDefault();\n      }),\n      onOpenAutoFocus: d[3] || (d[3] = (c) => n(\"openAutoFocus\", c))\n    }), {\n      default: v(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"trap-focus\"]));\n  }\n}), Js = /* @__PURE__ */ g({\n  __name: \"DialogContentNonModal\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = ce(n), l = ye(), i = B(!1), r = B(!1);\n    return (u, d) => (h(), b(Dn, T({ ...e, ...a(s) }, {\n      \"trap-focus\": !1,\n      \"disable-outside-pointer-events\": !1,\n      onCloseAutoFocus: d[0] || (d[0] = (c) => {\n        var p;\n        n(\"closeAutoFocus\", c), c.defaultPrevented || (i.value || (p = a(l).triggerElement.value) == null || p.focus(), c.preventDefault()), i.value = !1, r.value = !1;\n      }),\n      onInteractOutside: d[1] || (d[1] = (c) => {\n        var m;\n        c.defaultPrevented || (i.value = !0, c.detail.originalEvent.type === \"pointerdown\" && (r.value = !0));\n        const p = c.target;\n        ((m = a(l).triggerElement.value) == null ? void 0 : m.contains(p)) && c.preventDefault(), c.detail.originalEvent.type === \"focusin\" && r.value && c.preventDefault();\n      })\n    }), {\n      default: v(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Zs = /* @__PURE__ */ g({\n  __name: \"DialogContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = ye(), l = ce(n);\n    return (i, r) => (h(), b(a(se), {\n      present: i.forceMount || a(s).open.value\n    }, {\n      default: v(() => [\n        a(s).modal.value ? (h(), b(Xs, T({ key: 0 }, { ...e, ...a(l), ...i.$attrs }, {\n          onOpenAutoFocus: r[0] || (r[0] = (u) => n(\"openAutoFocus\", u))\n        }), {\n          default: v(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)) : (h(), b(Js, R(T({ key: 1 }, { ...e, ...a(l), ...i.$attrs })), {\n          default: v(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16))\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Qs = /* @__PURE__ */ g({\n  __name: \"DialogOverlayImpl\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = ye();\n    return pt(!0), (e, n) => (h(), b(a(D), {\n      as: e.as,\n      \"as-child\": e.asChild,\n      \"data-state\": a(t).open.value ? \"open\" : \"closed\",\n      style: { \"pointer-events\": \"auto\" }\n    }, {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-state\"]));\n  }\n}), el = /* @__PURE__ */ g({\n  __name: \"DialogOverlay\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = ye();\n    return (e, n) => {\n      var s;\n      return (s = a(t)) != null && s.modal.value ? (h(), b(a(se), {\n        key: 0,\n        present: e.forceMount || a(t).open.value\n      }, {\n        default: v(() => [\n          k(Qs, T({\n            as: e.as,\n            \"as-child\": e.asChild\n          }, e.$attrs), {\n            default: v(() => [\n              y(e.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16, [\"as\", \"as-child\"])\n        ]),\n        _: 3\n      }, 8, [\"present\"])) : J(\"\", !0);\n    };\n  }\n}), On = /* @__PURE__ */ g({\n  __name: \"DialogClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = ye();\n    return (n, s) => (h(), b(a(D), T(t, {\n      type: n.as === \"button\" ? \"button\" : void 0,\n      onClick: s[0] || (s[0] = (l) => a(e).onOpenChange(!1))\n    }), {\n      default: v(() => [\n        y(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\"]));\n  }\n}), tl = /* @__PURE__ */ g({\n  __name: \"DialogTitle\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"h2\" }\n  },\n  setup(o) {\n    const t = o, e = ye();\n    return (n, s) => (h(), b(a(D), T(t, {\n      id: a(e).titleId\n    }), {\n      default: v(() => [\n        y(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), ol = /* @__PURE__ */ g({\n  __name: \"DialogDescription\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"p\" }\n  },\n  setup(o) {\n    const t = o, e = ye();\n    return (n, s) => (h(), b(a(D), T(t, {\n      id: a(e).descriptionId\n    }), {\n      default: v(() => [\n        y(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), tu = /* @__PURE__ */ g({\n  __name: \"AlertDialogRoot\",\n  props: {\n    open: { type: Boolean },\n    defaultOpen: { type: Boolean }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const s = pe(o, t);\n    return (l, i) => (h(), b(a(Ts), T(a(s), { modal: !0 }), {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ou = /* @__PURE__ */ g({\n  __name: \"AlertDialogTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Ds), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), nu = /* @__PURE__ */ g({\n  __name: \"AlertDialogPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Pe), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [nl, al] = H(\"AlertDialogContent\"), au = /* @__PURE__ */ g({\n  __name: \"AlertDialogContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, s = ce(t), l = B();\n    return al({\n      onCancelElementChange: (i) => {\n        l.value = i;\n      }\n    }), (i, r) => (h(), b(a(Zs), T({ ...e, ...a(s) }, {\n      role: \"alertdialog\",\n      onPointerDownOutside: r[0] || (r[0] = ne(() => {\n      }, [\"prevent\"])),\n      onInteractOutside: r[1] || (r[1] = ne(() => {\n      }, [\"prevent\"])),\n      onOpenAutoFocus: r[2] || (r[2] = () => {\n        G(() => {\n          var u;\n          (u = l.value) == null || u.focus({\n            preventScroll: !0\n          });\n        });\n      })\n    }), {\n      default: v(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), su = /* @__PURE__ */ g({\n  __name: \"AlertDialogOverlay\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(el), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), lu = /* @__PURE__ */ g({\n  __name: \"AlertDialogCancel\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = nl(), { primitiveElement: n, currentElement: s } = V();\n    return U(() => {\n      e.onCancelElementChange(s.value);\n    }), (l, i) => (h(), b(a(On), T(t, {\n      ref_key: \"primitiveElement\",\n      ref: n\n    }), {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), iu = /* @__PURE__ */ g({\n  __name: \"AlertDialogTitle\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(tl), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ru = /* @__PURE__ */ g({\n  __name: \"AlertDialogDescription\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(ol), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), uu = /* @__PURE__ */ g({\n  __name: \"AlertDialogAction\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(On), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), du = /* @__PURE__ */ g({\n  inheritAttrs: !1,\n  __name: \"AspectRatio\",\n  props: {\n    ratio: { default: 1 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = S(() => 1 / t.ratio * 100);\n    return (n, s) => (h(), Q(\"div\", {\n      style: ae(`position: relative; width: 100%; padding-bottom: ${e.value}%`),\n      \"data-radix-aspect-ratio-wrapper\": \"\"\n    }, [\n      k(a(D), T({\n        \"as-child\": n.asChild,\n        as: n.as,\n        style: { position: \"absolute\", inset: \"0px\" }\n      }, n.$attrs), {\n        default: v(() => [\n          y(n.$slots, \"default\", { aspect: e.value })\n        ]),\n        _: 3\n      }, 16, [\"as-child\", \"as\"])\n    ], 4));\n  }\n}), [In, sl] = H(\"AvatarRoot\"), cu = /* @__PURE__ */ g({\n  __name: \"AvatarRoot\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = o;\n    return sl({\n      imageLoadingStatus: B(\"loading\")\n    }), (e, n) => (h(), b(a(D), {\n      as: e.as,\n      \"as-child\": t.asChild\n    }, {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n});\nfunction ll(o) {\n  const t = B(\"idle\"), e = B(!1), n = (s) => () => {\n    e.value && (t.value = s);\n  };\n  return U(() => {\n    e.value = !0, Y(o, (s) => {\n      if (!s)\n        t.value = \"error\";\n      else {\n        const l = new window.Image();\n        t.value = \"loading\", l.onload = n(\"loaded\"), l.onerror = n(\"error\"), l.src = s;\n      }\n    }, { immediate: !0 });\n  }), fe(() => {\n    e.value = !1;\n  }), t;\n}\nconst pu = /* @__PURE__ */ g({\n  __name: \"AvatarImage\",\n  props: {\n    src: {},\n    asChild: { type: Boolean },\n    as: { default: \"img\" }\n  },\n  emits: [\"loadingStatusChange\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { src: s } = z(e), l = In(), i = ll(s);\n    return Y(\n      i,\n      (r) => {\n        n(\"loadingStatusChange\", r), r !== \"idle\" && (l.imageLoadingStatus.value = r);\n      },\n      { immediate: !0 }\n    ), (r, u) => a(i) === \"loaded\" ? (h(), b(a(D), {\n      key: 0,\n      role: \"img\",\n      \"as-child\": r.asChild,\n      as: r.as,\n      src: a(s)\n    }, {\n      default: v(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"src\"])) : J(\"\", !0);\n  }\n}), fu = /* @__PURE__ */ g({\n  __name: \"AvatarFallback\",\n  props: {\n    delayMs: { default: 0 },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = o, e = In(), n = B(!1);\n    let s;\n    return Y(e.imageLoadingStatus, (l) => {\n      l === \"loading\" && (n.value = !1, t.delayMs ? s = setTimeout(() => {\n        n.value = !0, clearTimeout(s);\n      }, t.delayMs) : n.value = !0);\n    }, { immediate: !0 }), (l, i) => n.value && a(e).imageLoadingStatus.value !== \"loaded\" ? (h(), b(a(D), {\n      key: 0,\n      \"as-child\": t.asChild,\n      as: l.as\n    }, {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"])) : J(\"\", !0);\n  }\n});\nfunction So(o) {\n  return o === \"indeterminate\";\n}\nfunction An(o) {\n  return So(o) ? \"indeterminate\" : o ? \"checked\" : \"unchecked\";\n}\nconst il = [\"value\", \"checked\", \"name\", \"disabled\", \"required\"], [rl, ul] = H(\"CheckboxRoot\"), vu = /* @__PURE__ */ g({\n  inheritAttrs: !1,\n  __name: \"CheckboxRoot\",\n  props: {\n    defaultChecked: { type: Boolean },\n    checked: { type: [Boolean, String], default: void 0 },\n    disabled: { type: Boolean },\n    required: { type: Boolean },\n    name: {},\n    value: { default: \"on\" },\n    id: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:checked\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { disabled: s } = z(e), l = X(e, \"checked\", n, {\n      defaultValue: e.defaultChecked,\n      passive: e.checked === void 0\n    }), { primitiveElement: i, currentElement: r } = V(), u = Ke(r), d = S(() => {\n      var c;\n      return e.id && r.value ? (c = document.querySelector(`[for=\"${e.id}\"]`)) == null ? void 0 : c.innerText : void 0;\n    });\n    return ul({\n      disabled: s,\n      state: l\n    }), (c, p) => (h(), Q(ie, null, [\n      k(a(D), T(c.$attrs, {\n        id: c.id,\n        ref_key: \"primitiveElement\",\n        ref: i,\n        role: \"checkbox\",\n        \"as-child\": e.asChild,\n        as: c.as,\n        type: c.as === \"button\" ? \"button\" : void 0,\n        \"aria-checked\": a(So)(a(l)) ? \"mixed\" : a(l),\n        \"aria-required\": !1,\n        \"aria-label\": c.$attrs[\"aria-label\"] || d.value,\n        \"data-state\": a(An)(a(l)),\n        \"data-disabled\": a(s) ? \"\" : void 0,\n        disabled: a(s),\n        onKeydown: le(ne(() => {\n        }, [\"prevent\"]), [\"enter\"]),\n        onClick: p[0] || (p[0] = (f) => l.value = !a(l))\n      }), {\n        default: v(() => [\n          y(c.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\", \"as-child\", \"as\", \"type\", \"aria-checked\", \"aria-label\", \"data-state\", \"data-disabled\", \"disabled\", \"onKeydown\"]),\n      a(u) ? (h(), Q(\"input\", {\n        key: 0,\n        type: \"checkbox\",\n        tabindex: \"-1\",\n        \"aria-hidden\": \"\",\n        value: c.value,\n        checked: !!a(l),\n        name: e.name,\n        disabled: e.disabled,\n        required: e.required,\n        style: ae({\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        })\n      }, null, 12, il)) : J(\"\", !0)\n    ], 64));\n  }\n}), mu = /* @__PURE__ */ g({\n  __name: \"CheckboxIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = rl();\n    return (e, n) => (h(), b(a(se), {\n      present: e.forceMount || a(So)(a(t).state.value) || a(t).state.value === !0\n    }, {\n      default: v(() => [\n        k(a(D), T({\n          \"data-state\": a(An)(a(t).state.value),\n          \"data-disabled\": a(t).disabled.value ? \"\" : void 0,\n          style: { pointerEvents: \"none\" },\n          \"as-child\": e.asChild,\n          as: e.as\n        }, e.$attrs), {\n          default: v(() => [\n            y(e.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\", \"data-disabled\", \"as-child\", \"as\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), [Mn, dl] = H(\"PopperRoot\"), Ne = /* @__PURE__ */ g({\n  __name: \"PopperRoot\",\n  setup(o) {\n    const t = B();\n    return dl({\n      anchor: t,\n      onAnchorChange: (e) => t.value = e\n    }), (e, n) => y(e.$slots, \"default\");\n  }\n}), He = /* @__PURE__ */ g({\n  __name: \"PopperAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { primitiveElement: e, currentElement: n } = V(), s = Mn();\n    return Y(n, () => {\n      s.onAnchorChange(t.element ?? n.value);\n    }), (l, i) => (h(), b(a(D), {\n      ref_key: \"primitiveElement\",\n      ref: e,\n      as: l.as,\n      \"as-child\": l.asChild\n    }, {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n});\nfunction cl(o) {\n  return o !== null;\n}\nfunction pl(o) {\n  return {\n    name: \"transformOrigin\",\n    options: o,\n    fn(t) {\n      var $, _, E;\n      const { placement: e, rects: n, middlewareData: s } = t, i = (($ = s.arrow) == null ? void 0 : $.centerOffset) !== 0, r = i ? 0 : o.arrowWidth, u = i ? 0 : o.arrowHeight, [d, c] = so(e), p = { start: \"0%\", center: \"50%\", end: \"100%\" }[c], f = (((_ = s.arrow) == null ? void 0 : _.x) ?? 0) + r / 2, m = (((E = s.arrow) == null ? void 0 : E.y) ?? 0) + u / 2;\n      let C = \"\", w = \"\";\n      return d === \"bottom\" ? (C = i ? p : `${f}px`, w = `${-u}px`) : d === \"top\" ? (C = i ? p : `${f}px`, w = `${n.floating.height + u}px`) : d === \"right\" ? (C = `${-u}px`, w = i ? p : `${m}px`) : d === \"left\" && (C = `${n.floating.width + u}px`, w = i ? p : `${m}px`), { data: { x: C, y: w } };\n    }\n  };\n}\nfunction so(o) {\n  const [t, e = \"center\"] = o.split(\"-\");\n  return [t, e];\n}\nconst kn = {\n  side: \"bottom\",\n  sideOffset: 0,\n  align: \"center\",\n  alignOffset: 0,\n  arrowPadding: 0,\n  avoidCollisions: !0,\n  collisionBoundary: () => [],\n  collisionPadding: 0,\n  sticky: \"partial\",\n  hideWhenDetached: !1,\n  updatePositionStrategy: \"optimized\",\n  prioritizePosition: !1\n}, [fl, vl] = H(\"PopperContent\"), Ge = /* @__PURE__ */ g({\n  inheritAttrs: !1,\n  __name: \"PopperContent\",\n  props: yn({\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    onPlaced: { type: Function },\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  }, {\n    ...kn\n  }),\n  setup(o, { expose: t }) {\n    const e = o, n = Mn(), s = be(), { primitiveElement: l, currentElement: i } = V(), r = B(), u = B(), { width: d, height: c } = xn(u), p = S(\n      () => e.side + (e.align !== \"center\" ? `-${e.align}` : \"\")\n    ), f = S(() => typeof e.collisionPadding == \"number\" ? e.collisionPadding : { top: 0, right: 0, bottom: 0, left: 0, ...e.collisionPadding }), m = S(() => Array.isArray(e.collisionBoundary) ? e.collisionBoundary : [e.collisionBoundary]), C = S(() => ({\n      padding: f.value,\n      boundary: m.value.filter(cl),\n      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n      altBoundary: m.value.length > 0\n    })), w = za(() => [\n      Fa({\n        mainAxis: e.sideOffset + c.value,\n        alignmentAxis: e.alignOffset\n      }),\n      e.avoidCollisions && La({\n        mainAxis: !0,\n        crossAxis: !!e.prioritizePosition,\n        limiter: e.sticky === \"partial\" ? Ka() : void 0,\n        ...C.value\n      }),\n      !e.prioritizePosition && e.avoidCollisions && Na({\n        ...C.value\n      }),\n      Ha({\n        ...C.value,\n        apply: ({ elements: O, rects: K, availableWidth: j, availableHeight: Z }) => {\n          const { width: F, height: q } = K.reference, oe = O.floating.style;\n          Object.assign(O.floating.style, {\n            maxWidth: `${j}px`,\n            maxHeight: `${Z}px`\n          }), oe.setProperty(\n            \"--radix-popper-available-width\",\n            `${j}px`\n          ), oe.setProperty(\n            \"--radix-popper-available-height\",\n            `${Z}px`\n          ), oe.setProperty(\n            \"--radix-popper-anchor-width\",\n            `${F}px`\n          ), oe.setProperty(\n            \"--radix-popper-anchor-height\",\n            `${q}px`\n          );\n        }\n      }),\n      u.value && Wa({ element: u.value, padding: e.arrowPadding }),\n      pl({\n        arrowWidth: d.value,\n        arrowHeight: c.value\n      }),\n      e.hideWhenDetached && ja({ strategy: \"referenceHidden\", ...C.value })\n    ]), { floatingStyles: $, placement: _, isPositioned: E, middlewareData: x } = Ra(\n      n.anchor,\n      r,\n      {\n        strategy: \"fixed\",\n        placement: p,\n        whileElementsMounted: (...O) => Va(...O, {\n          animationFrame: e.updatePositionStrategy === \"always\"\n        }),\n        middleware: w\n      }\n    ), P = S(\n      () => so(_.value)[0]\n    ), I = S(\n      () => so(_.value)[1]\n    );\n    ee(() => {\n      var O;\n      E.value && ((O = e.onPlaced) == null || O.call(e));\n    });\n    const A = S(\n      () => {\n        var O;\n        return ((O = x.value.arrow) == null ? void 0 : O.centerOffset) !== 0;\n      }\n    ), L = B(\"\");\n    ee(() => {\n      i.value && (L.value = window.getComputedStyle(i.value).zIndex);\n    });\n    const M = S(() => {\n      var O;\n      return ((O = x.value.arrow) == null ? void 0 : O.x) ?? 0;\n    }), W = S(() => {\n      var O;\n      return ((O = x.value.arrow) == null ? void 0 : O.y) ?? 0;\n    });\n    return vl({\n      placedSide: P,\n      onArrowChange: (O) => u.value = O,\n      arrowX: M,\n      arrowY: W,\n      shouldHideArrow: A\n    }), t({\n      $el: i\n    }), (O, K) => {\n      var j, Z, F;\n      return h(), Q(\"div\", {\n        ref_key: \"floatingRef\",\n        ref: r,\n        \"data-radix-popper-content-wrapper\": \"\",\n        style: ae({\n          ...a($),\n          transform: a(E) ? a($).transform : \"translate(0, -200%)\",\n          // keep off the page when measuring\n          minWidth: \"max-content\",\n          zIndex: L.value,\n          \"--radix-popper-transform-origin\": [\n            (j = a(x).transformOrigin) == null ? void 0 : j.x,\n            (Z = a(x).transformOrigin) == null ? void 0 : Z.y\n          ].join(\" \")\n        })\n      }, [\n        k(a(D), T({\n          ref: (q) => {\n            a(s)(q), l.value = q;\n          }\n        }, O.$attrs, {\n          \"as-child\": e.asChild,\n          as: O.as,\n          \"data-side\": P.value,\n          \"data-align\": I.value,\n          style: {\n            // if the PopperContent hasn't been placed yet (not all measurements done)\n            // we prevent animations so that users's animation don't kick in too early referring wrong sides\n            animation: a(E) ? void 0 : \"none\",\n            // hide the content if using the hide middleware and should be hidden\n            opacity: (F = a(x).hide) != null && F.referenceHidden ? 0 : void 0\n          }\n        }), {\n          default: v(() => [\n            y(O.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as-child\", \"as\", \"data-side\", \"data-align\", \"style\"])\n      ], 4);\n    };\n  }\n}), ml = /* @__PURE__ */ rt(\"polygon\", { points: \"0,0 30,0 15,10\" }, null, -1), hl = /* @__PURE__ */ g({\n  __name: \"Arrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(o) {\n    const t = o, { primitiveElement: e } = V();\n    return (n, s) => (h(), b(a(D), T({\n      ref_key: \"primitiveElement\",\n      ref: e\n    }, t, {\n      width: n.width,\n      height: n.height,\n      viewBox: n.asChild ? void 0 : \"0 0 30 10\",\n      preserveAspectRatio: n.asChild ? void 0 : \"none\"\n    }), {\n      default: v(() => [\n        y(n.$slots, \"default\", {}, () => [\n          ml\n        ])\n      ]),\n      _: 3\n    }, 16, [\"width\", \"height\", \"viewBox\", \"preserveAspectRatio\"]));\n  }\n}), yl = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\"\n}, Ye = /* @__PURE__ */ g({\n  inheritAttrs: !1,\n  __name: \"PopperArrow\",\n  props: {\n    width: {},\n    height: {},\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(o) {\n    const t = fl(), e = S(() => yl[t.placedSide.value]);\n    return (n, s) => {\n      var l, i, r, u;\n      return h(), Q(\"span\", {\n        ref: (d) => {\n          a(t).onArrowChange(d);\n        },\n        style: ae({\n          position: \"absolute\",\n          left: (l = a(t).arrowX) != null && l.value ? `${(i = a(t).arrowX) == null ? void 0 : i.value}px` : void 0,\n          top: (r = a(t).arrowY) != null && r.value ? `${(u = a(t).arrowY) == null ? void 0 : u.value}px` : void 0,\n          [e.value]: 0,\n          transformOrigin: {\n            top: \"\",\n            right: \"0 0\",\n            bottom: \"center 0\",\n            left: \"100% 0\"\n          }[a(t).placedSide.value],\n          transform: {\n            top: \"translateY(100%)\",\n            right: \"translateY(50%) rotate(90deg) translateX(-50%)\",\n            bottom: \"rotate(180deg)\",\n            left: \"translateY(50%) rotate(-90deg) translateX(50%)\"\n          }[a(t).placedSide.value],\n          visibility: a(t).shouldHideArrow.value ? \"hidden\" : void 0\n        })\n      }, [\n        k(hl, T(n.$attrs, {\n          style: {\n            display: \"block\"\n          },\n          as: n.as,\n          \"as-child\": n.asChild,\n          width: n.width,\n          height: n.height\n        }), {\n          default: v(() => [\n            y(n.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\", \"width\", \"height\"])\n      ], 4);\n    };\n  }\n}), Xe = /* @__PURE__ */ g({\n  __name: \"VisuallyHidden\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    return (t, e) => (h(), b(a(D), {\n      as: t.as,\n      \"as-child\": t.asChild,\n      style: ae({\n        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss\n        position: \"absolute\",\n        border: 0,\n        width: \"1px\",\n        display: \"inline-block\",\n        height: \"1px\",\n        padding: 0,\n        margin: \"-1px\",\n        overflow: \"hidden\",\n        clip: \"rect(0, 0, 0, 0)\",\n        whiteSpace: \"nowrap\",\n        wordWrap: \"normal\"\n      })\n    }, {\n      default: v(() => [\n        y(t.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"style\"]));\n  }\n}), Rn = /* @__PURE__ */ g({\n  __name: \"VisuallyHiddenInput\",\n  props: {\n    name: {},\n    value: {},\n    required: { type: Boolean },\n    disabled: { type: Boolean }\n  },\n  setup(o) {\n    const t = o, e = S(() => typeof t.value == \"string\" || typeof t.value == \"number\" || typeof t.value == \"boolean\" ? [{ name: t.name, value: t.value }] : typeof t.value == \"object\" && Array.isArray(t.value) ? t.value.flatMap((n, s) => typeof n == \"object\" ? Object.entries(n).map(([l, i]) => ({ name: `[${s}][${t.name}][${l}]`, value: i })) : { name: `[${t.name}][${s}]`, value: n }) : typeof t.value == \"object\" && !Array.isArray(t.value) ? Object.entries(t.value).map(([n, s]) => ({ name: `[${t.name}][${n}]`, value: s })) : []);\n    return (n, s) => (h(!0), Q(ie, null, po(e.value, (l) => (h(), b(Xe, {\n      key: l.name,\n      as: \"input\",\n      type: \"hidden\",\n      hidden: \"\",\n      readonly: \"\",\n      name: l.name,\n      value: l.value,\n      required: n.required,\n      disabled: n.disabled\n    }, null, 8, [\"name\", \"value\", \"required\", \"disabled\"]))), 128));\n  }\n});\nfunction gl(o) {\n  return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, \"default\") ? o.default : o;\n}\nvar bl = function o(t, e) {\n  if (t === e)\n    return !0;\n  if (t && e && typeof t == \"object\" && typeof e == \"object\") {\n    if (t.constructor !== e.constructor)\n      return !1;\n    var n, s, l;\n    if (Array.isArray(t)) {\n      if (n = t.length, n != e.length)\n        return !1;\n      for (s = n; s-- !== 0; )\n        if (!o(t[s], e[s]))\n          return !1;\n      return !0;\n    }\n    if (t.constructor === RegExp)\n      return t.source === e.source && t.flags === e.flags;\n    if (t.valueOf !== Object.prototype.valueOf)\n      return t.valueOf() === e.valueOf();\n    if (t.toString !== Object.prototype.toString)\n      return t.toString() === e.toString();\n    if (l = Object.keys(t), n = l.length, n !== Object.keys(e).length)\n      return !1;\n    for (s = n; s-- !== 0; )\n      if (!Object.prototype.hasOwnProperty.call(e, l[s]))\n        return !1;\n    for (s = n; s-- !== 0; ) {\n      var i = l[s];\n      if (!o(t[i], e[i]))\n        return !1;\n    }\n    return !0;\n  }\n  return t !== t && e !== e;\n};\nconst nt = /* @__PURE__ */ gl(bl), Cl = \"data-radix-vue-collection-item\", [To, _l] = H(\"CollectionProvider\");\nfunction Vn(o = Cl) {\n  const t = B(/* @__PURE__ */ new Map()), e = B(), n = _l({\n    collectionRef: e,\n    itemMap: t,\n    attrName: o\n  }), { getItems: s } = wl(n), l = S(() => Array.from(n.itemMap.value.values())), i = S(() => n.itemMap.value.size);\n  return { getItems: s, reactiveItems: l, itemMapSize: i };\n}\nconst Fn = g({\n  name: \"CollectionSlot\",\n  setup(o, { slots: t }) {\n    const e = To(), { primitiveElement: n, currentElement: s } = V();\n    return Y(s, () => {\n      e.collectionRef.value = s.value;\n    }), () => Re(Eo, { ref: n }, t);\n  }\n}), Ln = g({\n  name: \"CollectionItem\",\n  setup(o, { slots: t, attrs: e }) {\n    const n = To(), { primitiveElement: s, currentElement: l } = V(), i = Fe();\n    return ee((r) => {\n      var u;\n      if (l.value) {\n        const d = en(l.value);\n        n.itemMap.value.set(d, { ref: l.value, ...en(((u = i == null ? void 0 : i.parent) == null ? void 0 : u.props) ?? {}) }), r(() => n.itemMap.value.delete(d));\n      }\n    }), () => Re(Eo, { ...e, [n.attrName]: \"\", ref: s }, t);\n  }\n});\nfunction wl(o) {\n  const t = o ?? To();\n  return { getItems: () => {\n    const n = t.collectionRef.value;\n    if (!n)\n      return [];\n    const s = Array.from(n.querySelectorAll(`[${t.attrName}]`));\n    return Array.from(t.itemMap.value.values()).sort(\n      (r, u) => s.indexOf(r.ref) - s.indexOf(u.ref)\n    );\n  } };\n}\nconst [we, El] = H(\"ComboboxRoot\"), hu = /* @__PURE__ */ g({\n  __name: \"ComboboxRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    open: { type: Boolean, default: void 0 },\n    defaultOpen: { type: Boolean },\n    searchTerm: {},\n    multiple: { type: Boolean },\n    disabled: { type: Boolean },\n    name: {},\n    dir: {},\n    filterFunction: {},\n    displayValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"update:open\", \"update:searchTerm\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { multiple: s, disabled: l, name: i, dir: r } = z(e), u = de(r), d = X(e, \"searchTerm\", n, {\n      // @ts-expect-error ignore the type error here\n      defaultValue: \"\",\n      passive: e.searchTerm === void 0\n    }), c = X(e, \"modelValue\", n, {\n      // @ts-expect-error ignore the type error here\n      defaultValue: e.defaultValue ?? s.value ? [] : void 0,\n      passive: e.modelValue === void 0,\n      deep: !0\n    }), p = X(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), f = B();\n    async function m(F) {\n      var q, oe;\n      p.value = F, await G(), F ? (c.value && (Array.isArray(c.value) && s.value ? f.value = (q = P().find((tt) => {\n        var ot, ht;\n        return ((ht = (ot = tt.ref) == null ? void 0 : ot.dataset) == null ? void 0 : ht.state) === \"checked\";\n      })) == null ? void 0 : q.value : f.value = c.value), (oe = $.value) == null || oe.focus(), Z()) : (w.value = !1, W());\n    }\n    function C(F) {\n      if (Array.isArray(c.value) && s.value) {\n        const q = c.value.findIndex((oe) => nt(oe, F));\n        q === -1 ? c.value.push(F) : c.value.splice(q, 1);\n      } else\n        c.value = F, m(!1);\n    }\n    const w = B(!1), $ = B(), _ = B(), { primitiveElement: E, currentElement: x } = V(), { getItems: P, reactiveItems: I, itemMapSize: A } = Vn(\"data-radix-vue-combobox-item\"), L = mo(() => A.value, () => P().map((F) => F.value)), M = S(() => {\n      if (w.value) {\n        if (e.filterFunction)\n          return e.filterFunction(L.value, d.value);\n        if (typeof L.value[0] == \"string\")\n          return L.value.filter((F) => {\n            var q;\n            return F.toLowerCase().includes((q = d.value) == null ? void 0 : q.toLowerCase());\n          });\n      }\n      return L.value;\n    });\n    function W() {\n      !s.value && c.value ? e.displayValue ? d.value = e.displayValue(c.value) : typeof c.value != \"object\" ? d.value = c.value.toString() : d.value = \"\" : d.value = \"\";\n    }\n    const O = S(() => M.value.findIndex((F) => nt(F, f.value))), K = S(() => {\n      var F;\n      return (F = I.value.find((q) => q.value === f.value)) == null ? void 0 : F.ref;\n    });\n    Y(c, async () => {\n      await G(), W();\n    }, { immediate: !0 }), Y(() => M.value.length, async (F) => {\n      await G(), await G(), F && O.value === -1 && (f.value = M.value[0]);\n    });\n    const j = Ke(x);\n    function Z() {\n      K.value instanceof Element && K.value.scrollIntoView({ block: \"nearest\" });\n    }\n    return El({\n      searchTerm: d,\n      modelValue: c,\n      // @ts-expect-error igoring\n      onValueChange: C,\n      isUserInputted: w,\n      multiple: s,\n      disabled: l,\n      open: p,\n      onOpenChange: m,\n      filteredOptions: M,\n      contentId: te(),\n      inputElement: $,\n      onInputElementChange: (F) => $.value = F,\n      onInputNavigation: async (F) => {\n        const q = O.value;\n        q === 0 && F === \"up\" || q === M.value.length - 1 && F === \"down\" || (q === -1 && M.value.length || F === \"home\" ? f.value = M.value[0] : F === \"end\" ? f.value = M.value[M.value.length - 1] : f.value = M.value[F === \"up\" ? q - 1 : q + 1], Z());\n      },\n      onInputEnter: async () => {\n        var F;\n        M.value.length && f.value && K.value instanceof Element && ((F = K.value) == null || F.click());\n      },\n      selectedValue: f,\n      onSelectedValueChange: (F) => f.value = F,\n      parentElement: x,\n      contentElement: _,\n      onContentElementChange: (F) => _.value = F\n    }), (F, q) => (h(), b(a(Ne), null, {\n      default: v(() => [\n        k(a(D), T({\n          ref_key: \"primitiveElement\",\n          ref: E,\n          style: {\n            pointerEvents: a(p) ? \"auto\" : void 0\n          },\n          as: F.as,\n          \"as-child\": F.asChild,\n          dir: a(u)\n        }, F.$attrs), {\n          default: v(() => [\n            y(F.$slots, \"default\", {\n              activeIndex: O.value,\n              open: a(p),\n              value: a(c)\n            }),\n            a(j) && a(i) ? (h(), b(a(Rn), {\n              key: 0,\n              name: a(i),\n              value: a(c)\n            }, null, 8, [\"name\", \"value\"])) : J(\"\", !0)\n          ]),\n          _: 3\n        }, 16, [\"style\", \"as\", \"as-child\", \"dir\"])\n      ]),\n      _: 3\n    }));\n  }\n}), yu = /* @__PURE__ */ g({\n  __name: \"ComboboxInput\",\n  props: {\n    type: { default: \"text\" },\n    disabled: { type: Boolean },\n    autoFocus: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(o) {\n    const t = o, e = we(), { primitiveElement: n, currentElement: s } = V();\n    U(() => {\n      const d = s.value.nodeName === \"INPUT\" ? s.value : s.value.querySelector(\"input\");\n      d && (e.onInputElementChange(d), setTimeout(() => {\n        t.autoFocus && (d == null || d.focus());\n      }, 1));\n    });\n    const l = S(() => t.disabled || e.disabled.value || !1);\n    function i(d) {\n      e.open.value ? e.onInputNavigation(d.key === \"ArrowUp\" ? \"up\" : \"down\") : e.onOpenChange(!0);\n    }\n    function r(d) {\n      e.open.value && e.onInputNavigation(d.key === \"Home\" ? \"home\" : \"end\");\n    }\n    function u(d) {\n      var c;\n      e.searchTerm.value = (c = d.target) == null ? void 0 : c.value, e.open.value || e.onOpenChange(!0), e.isUserInputted.value = !0;\n    }\n    return (d, c) => (h(), b(a(D), T({\n      ref_key: \"primitiveElement\",\n      ref: n\n    }, t, {\n      value: a(e).searchTerm.value,\n      \"aria-expanded\": a(e).open.value,\n      \"aria-controls\": a(e).contentId,\n      disabled: l.value,\n      \"aria-disabled\": l.value ?? void 0,\n      \"aria-autocomplete\": \"list\",\n      role: \"combobox\",\n      autocomplete: \"false\",\n      onInput: u,\n      onKeydown: [\n        le(ne(i, [\"prevent\"]), [\"down\", \"up\"]),\n        le(a(e).onInputEnter, [\"enter\"]),\n        le(ne(r, [\"prevent\"]), [\"home\", \"end\"])\n      ]\n    }), {\n      default: v(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"value\", \"aria-expanded\", \"aria-controls\", \"disabled\", \"aria-disabled\", \"onKeydown\"]));\n  }\n}), gu = /* @__PURE__ */ g({\n  __name: \"ComboboxAnchor\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    return (t, e) => (h(), b(a(He), { \"as-child\": \"\" }, {\n      default: v(() => [\n        k(a(D), T({\n          \"as-child\": t.asChild,\n          as: t.as\n        }, t.$attrs), {\n          default: v(() => [\n            y(t.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as-child\", \"as\"])\n      ]),\n      _: 3\n    }));\n  }\n}), bu = /* @__PURE__ */ g({\n  __name: \"ComboboxTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = we(), n = S(() => t.disabled || e.disabled.value || !1);\n    return (s, l) => (h(), b(a(D), T({\n      type: s.as === \"button\" ? \"button\" : void 0\n    }, t, {\n      tabindex: \"-1\",\n      \"aria-label\": \"Show popup\",\n      \"aria-haspopup\": \"listbox\",\n      \"aria-expanded\": a(e).open.value,\n      \"aria-controls\": a(e).contentId,\n      \"data-state\": a(e).open.value ? \"open\" : \"closed\",\n      disabled: n.value,\n      \"data-disabled\": n.value,\n      \"aria-disabled\": n.value ?? void 0,\n      onClick: l[0] || (l[0] = (i) => a(e).onOpenChange(!a(e).open.value))\n    }), {\n      default: v(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"aria-expanded\", \"aria-controls\", \"data-state\", \"disabled\", \"data-disabled\", \"aria-disabled\"]));\n  }\n}), Cu = /* @__PURE__ */ g({\n  __name: \"ComboboxCancel\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = we();\n    function n() {\n      var s;\n      e.searchTerm.value = \"\", (s = e.inputElement.value) == null || s.focus();\n    }\n    return (s, l) => (h(), b(a(D), T({\n      type: s.as === \"button\" ? \"button\" : void 0\n    }, t, {\n      tabindex: \"-1\",\n      onClick: n\n    }), {\n      default: v(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\"]));\n  }\n}), [Kn, xl] = H(\"ComboboxGroup\"), _u = /* @__PURE__ */ g({\n  __name: \"ComboboxGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = te(), n = B([]), s = we(), l = S(() => !s.isUserInputted.value || n.value.length === 0 || s.filteredOptions.value.map((i) => JSON.stringify(i)).some((i) => n.value.map((r) => JSON.stringify(r)).includes(i)));\n    return xl({\n      id: e,\n      options: n\n    }), (i, r) => fo((h(), b(a(D), T({ role: \"group\" }, t, { \"aria-labelledby\": a(e) }), {\n      default: v(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-labelledby\"])), [\n      [gn, l.value]\n    ]);\n  }\n}), wu = /* @__PURE__ */ g({\n  __name: \"ComboboxLabel\",\n  props: {\n    for: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(o) {\n    const t = o, e = Kn({ id: \"\" });\n    return (n, s) => (h(), b(a(D), T(t, {\n      id: a(e).id\n    }), {\n      default: v(() => [\n        y(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), [$l, Bl] = H(\"ComboboxContent\"), Pl = /* @__PURE__ */ g({\n  __name: \"ComboboxContentImpl\",\n  props: {\n    position: { default: \"inline\" },\n    bodyLock: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    onPlaced: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { position: s } = z(e), l = we();\n    pt(e.bodyLock);\n    const { primitiveElement: i, currentElement: r } = V();\n    ft(r);\n    const u = S(() => e.position === \"popper\" ? e : {});\n    function d(p) {\n      l.onSelectedValueChange(\"\");\n    }\n    U(() => {\n      l.onContentElementChange(r.value);\n    });\n    const c = {\n      // Ensure border-box for floating-ui calculations\n      boxSizing: \"border-box\",\n      \"--radix-combobox-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-combobox-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-combobox-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-combobox-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-combobox-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    };\n    return Bl({ position: s }), (p, f) => (h(), b(a(Fn), null, {\n      default: v(() => [\n        k(a(Se), {\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": p.disableOutsidePointerEvents,\n          onDismiss: f[0] || (f[0] = (m) => a(l).onOpenChange(!1)),\n          onFocusOutside: f[1] || (f[1] = (m) => {\n            var C;\n            (C = a(l).parentElement.value) != null && C.contains(m.target) && m.preventDefault(), n(\"focusOutside\", m);\n          }),\n          onInteractOutside: f[2] || (f[2] = (m) => n(\"interactOutside\", m)),\n          onEscapeKeyDown: f[3] || (f[3] = (m) => n(\"escapeKeyDown\", m)),\n          onPointerDownOutside: f[4] || (f[4] = (m) => {\n            var C;\n            (C = a(l).parentElement.value) != null && C.contains(m.target) && m.preventDefault(), n(\"pointerDownOutside\", m);\n          })\n        }, {\n          default: v(() => [\n            (h(), b($e(a(s) === \"popper\" ? a(Ge) : a(D)), T({ ...p.$attrs, ...u.value }, {\n              id: a(l).contentId,\n              ref_key: \"primitiveElement\",\n              ref: i,\n              role: \"listbox\",\n              \"data-state\": a(l).open.value ? \"open\" : \"closed\",\n              style: {\n                // flex layout so we can place the scroll buttons properly\n                display: \"flex\",\n                flexDirection: \"column\",\n                // reset the outline by default as the content MAY get focused\n                outline: \"none\",\n                ...a(s) === \"popper\" ? c : {}\n              },\n              onPointerleave: d\n            }), {\n              default: v(() => [\n                y(p.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"id\", \"data-state\", \"style\"]))\n          ]),\n          _: 3\n        }, 8, [\"disable-outside-pointer-events\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Eu = /* @__PURE__ */ g({\n  __name: \"ComboboxContent\",\n  props: {\n    forceMount: { type: Boolean },\n    position: {},\n    bodyLock: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    onPlaced: { type: Function },\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\"],\n  setup(o, { emit: t }) {\n    const s = pe(o, t), l = we();\n    return (i, r) => (h(), b(a(se), {\n      present: i.forceMount || a(l).open.value\n    }, {\n      default: v(() => [\n        k(Pl, R(N({ ...a(s), ...i.$attrs })), {\n          default: v(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), xu = /* @__PURE__ */ g({\n  __name: \"ComboboxEmpty\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = we(), n = S(() => e.searchTerm.value && e.filteredOptions.value.length === 0);\n    return (s, l) => n.value ? (h(), b(a(D), R(T({ key: 0 }, t)), {\n      default: v(() => [\n        y(s.$slots, \"default\", {}, () => [\n          ue(\"No options\")\n        ])\n      ]),\n      _: 3\n    }, 16)) : J(\"\", !0);\n  }\n}), $u = /* @__PURE__ */ g({\n  __name: \"ComboboxViewport\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), Q(ie, null, [\n      k(a(D), { as: \"style\" }, {\n        default: v(() => [\n          ue(\" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-combobox-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-combobox-viewport]::-webkit-scrollbar { display: none; } \")\n        ]),\n        _: 1\n      }),\n      k(a(D), T({\n        \"data-radix-combobox-viewport\": \"\",\n        role: \"presentation\"\n      }, { ...e.$attrs, ...t }, { style: {\n        // we use position: 'relative' here on the `viewport` so that when we call\n        // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport\n        // (independent of the scrollUpButton).\n        position: \"relative\",\n        flex: 1,\n        overflow: \"auto\"\n      } }), {\n        default: v(() => [\n          y(e.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"style\"])\n    ], 64));\n  }\n}), [Sl, Tl] = H(\"ComboboxItem\"), Dl = \"combobox.select\", Bu = /* @__PURE__ */ g({\n  __name: \"ComboboxItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { disabled: s } = z(e), l = we(), i = Kn({ id: \"\", options: B([]) }), { primitiveElement: r, currentElement: u } = V(), d = S(\n      () => {\n        var _, E;\n        return l.multiple.value && Array.isArray(l.modelValue.value) ? (_ = l.modelValue.value) == null ? void 0 : _.includes(e.value) : nt((E = l.modelValue) == null ? void 0 : E.value, e.value);\n      }\n    ), c = S(() => nt(l.selectedValue.value, e.value)), p = B(e.textValue ?? \"\"), f = te(), m = S(() => l.isUserInputted.value ? l.searchTerm.value === \"\" || !!l.filteredOptions.value.find((_) => nt(_, e.value)) : !0);\n    async function C(_) {\n      n(\"select\", _), !(_ != null && _.defaultPrevented) && !s.value && _ && l.onValueChange(e.value);\n    }\n    function w(_) {\n      if (!_)\n        return;\n      const E = { originalEvent: _, value: e.value };\n      vo(Dl, C, E);\n    }\n    async function $(_) {\n      await G(), !_.defaultPrevented && l.onSelectedValueChange(e.value);\n    }\n    if (e.value === \"\")\n      throw new Error(\n        \"A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.\"\n      );\n    return U(() => {\n      var _, E, x, P;\n      (E = (_ = i.options) == null ? void 0 : _.value) != null && E.includes(e.value) || (x = i.options) == null || x.value.push(e.value), !p.value && ((P = u.value) != null && P.textContent) && (p.value = u.value.textContent);\n    }), Tl({\n      isSelected: d\n    }), (_, E) => (h(), b(a(Ln), null, {\n      default: v(() => [\n        fo(k(a(D), {\n          ref_key: \"primitiveElement\",\n          ref: r,\n          role: \"option\",\n          tabindex: \"-1\",\n          \"aria-labelledby\": a(f),\n          \"data-highlighted\": c.value ? \"\" : void 0,\n          \"aria-selected\": d.value,\n          \"data-state\": d.value ? \"checked\" : \"unchecked\",\n          \"aria-disabled\": a(s) || void 0,\n          \"data-disabled\": a(s) ? \"\" : void 0,\n          as: _.as,\n          \"as-child\": _.asChild,\n          onClick: w,\n          onPointermove: $\n        }, {\n          default: v(() => [\n            y(_.$slots, \"default\", {}, () => [\n              ue(Le(_.value), 1)\n            ])\n          ]),\n          _: 3\n        }, 8, [\"aria-labelledby\", \"data-highlighted\", \"aria-selected\", \"data-state\", \"aria-disabled\", \"data-disabled\", \"as\", \"as-child\"]), [\n          [gn, m.value]\n        ])\n      ]),\n      _: 3\n    }));\n  }\n}), Pu = /* @__PURE__ */ g({\n  __name: \"ComboboxItemIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = o, e = Sl();\n    return (n, s) => a(e).isSelected.value ? (h(), b(a(D), T({\n      key: 0,\n      \"aria-hidden\": \"\"\n    }, t), {\n      default: v(() => [\n        y(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : J(\"\", !0);\n  }\n}), Su = /* @__PURE__ */ g({\n  __name: \"ComboboxSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(D), T({ \"aria-hidden\": \"\" }, t), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Tu = /* @__PURE__ */ g({\n  __name: \"ComboboxArrow\",\n  props: {\n    width: {},\n    height: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = we(), n = $l();\n    return (s, l) => a(e).open.value && a(n).position.value === \"popper\" ? (h(), b(a(Ye), R(T({ key: 0 }, t)), {\n      default: v(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : J(\"\", !0);\n  }\n}), Du = /* @__PURE__ */ g({\n  __name: \"ComboboxPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Pe), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), kt = /* @__PURE__ */ g({\n  __name: \"MenuAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(He), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Do = /* @__PURE__ */ g({\n  __name: \"MenuArrow\",\n  props: {\n    width: {},\n    height: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Ye), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [We, Nn] = H([\"MenuRoot\", \"MenuSub\"], \"MenuContext\"), [vt, Ol] = H(\"MenuRoot\"), Oo = /* @__PURE__ */ g({\n  __name: \"MenuRoot\",\n  props: {\n    open: { type: Boolean, default: !1 },\n    onOpenChange: {},\n    dir: {},\n    modal: { type: Boolean, default: !0 }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { modal: s, dir: l } = z(e), i = de(l), r = X(e, \"open\", n), u = B(), d = B(!1);\n    return ee((c) => {\n      if (!Be)\n        return;\n      const p = () => {\n        d.value = !0, document.addEventListener(\"pointerdown\", f, {\n          capture: !0,\n          once: !0\n        }), document.addEventListener(\"pointermove\", f, {\n          capture: !0,\n          once: !0\n        });\n      }, f = () => d.value = !1;\n      document.addEventListener(\"keydown\", p, { capture: !0 }), c(() => {\n        document.removeEventListener(\"keydown\", p, { capture: !0 }), document.removeEventListener(\"pointerdown\", f, {\n          capture: !0\n        }), document.removeEventListener(\"pointermove\", f, {\n          capture: !0\n        });\n      });\n    }), Nn({\n      open: r,\n      onOpenChange: (c) => {\n        r.value = c;\n      },\n      content: u,\n      onContentChange: (c) => {\n        u.value = c;\n      }\n    }), Ol({\n      onClose: () => {\n        r.value = !1;\n      },\n      isUsingKeyboardRef: d,\n      dir: i,\n      modal: s\n    }), (c, p) => (h(), b(a(Ne), null, {\n      default: v(() => [\n        y(c.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), Il = \"rovingFocusGroup.onEntryFocus\", Al = { bubbles: !1, cancelable: !0 }, Ml = {\n  ArrowLeft: \"prev\",\n  ArrowUp: \"prev\",\n  ArrowRight: \"next\",\n  ArrowDown: \"next\",\n  PageUp: \"first\",\n  Home: \"first\",\n  PageDown: \"last\",\n  End: \"last\"\n};\nfunction kl(o, t) {\n  return t !== \"rtl\" ? o : o === \"ArrowLeft\" ? \"ArrowRight\" : o === \"ArrowRight\" ? \"ArrowLeft\" : o;\n}\nfunction Rl(o, t, e) {\n  const n = kl(o.key, e);\n  if (!(t === \"vertical\" && [\"ArrowLeft\", \"ArrowRight\"].includes(n)) && !(t === \"horizontal\" && [\"ArrowUp\", \"ArrowDown\"].includes(n)))\n    return Ml[n];\n}\nfunction Hn(o) {\n  const t = document.activeElement;\n  for (const e of o)\n    if (e === t || (e.focus(), document.activeElement !== t))\n      return;\n}\nfunction Vl(o, t) {\n  return o.map((e, n) => o[(t + n) % o.length]);\n}\nconst [Fl, Ll] = H(\"RovingFocusGroup\"), Je = /* @__PURE__ */ g({\n  __name: \"RovingFocusGroup\",\n  props: {\n    orientation: { default: void 0 },\n    dir: {},\n    loop: { type: Boolean, default: !1 },\n    currentTabStopId: {},\n    defaultCurrentTabStopId: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"entryFocus\", \"update:currentTabStopId\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { loop: s, orientation: l, dir: i } = z(e), r = de(i), u = X(e, \"currentTabStopId\", n, {\n      defaultValue: e.defaultCurrentTabStopId,\n      passive: e.currentTabStopId === void 0\n    }), d = B(!1), c = B(!1), p = B(0), { primitiveElement: f, currentElement: m } = V(), { createCollection: C } = re(\"rovingFocus\"), w = C(m);\n    function $(_) {\n      const E = !c.value;\n      if (_.currentTarget && _.target === _.currentTarget && E && !d.value) {\n        const x = new CustomEvent(Il, Al);\n        if (_.currentTarget.dispatchEvent(x), n(\"entryFocus\", x), !x.defaultPrevented) {\n          const P = w.value, I = P.find((M) => M.getAttribute(\"data-active\") === \"true\"), A = P.find(\n            (M) => M.id === u.value\n          ), L = [I, A, ...P].filter(\n            Boolean\n          );\n          Hn(L);\n        }\n      }\n      c.value = !1;\n    }\n    return Ll({\n      loop: s,\n      dir: r,\n      orientation: l,\n      currentTabStopId: u,\n      onItemFocus: (_) => {\n        u.value = _;\n      },\n      onItemShiftTab: () => {\n        d.value = !0;\n      },\n      onFocusableItemAdd: () => {\n        p.value++;\n      },\n      onFocusableItemRemove: () => {\n        p.value--;\n      }\n    }), (_, E) => (h(), b(a(D), {\n      ref_key: \"primitiveElement\",\n      ref: f,\n      tabindex: d.value || p.value === 0 ? -1 : 0,\n      \"data-orientation\": a(l),\n      as: _.as,\n      \"as-child\": _.asChild,\n      dir: a(r),\n      style: { outline: \"none\" },\n      onMousedown: E[0] || (E[0] = (x) => c.value = !0),\n      onFocus: $,\n      onBlur: E[1] || (E[1] = (x) => d.value = !1)\n    }, {\n      default: v(() => [\n        y(_.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"tabindex\", \"data-orientation\", \"as\", \"as-child\", \"dir\"]));\n  }\n}), Ze = /* @__PURE__ */ g({\n  __name: \"RovingFocusItem\",\n  props: {\n    tabStopId: {},\n    focusable: { type: Boolean, default: !0 },\n    active: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = o, e = Fl(), n = te(), s = S(() => t.tabStopId || n), l = S(\n      () => e.currentTabStopId.value === s.value\n    ), { injectCollection: i } = re(\"rovingFocus\"), r = i();\n    U(() => {\n      t.focusable && e.onFocusableItemAdd();\n    }), fe(() => {\n      t.focusable && e.onFocusableItemRemove();\n    });\n    function u(d) {\n      if (d.key === \"Tab\" && d.shiftKey) {\n        e.onItemShiftTab();\n        return;\n      }\n      if (d.target !== d.currentTarget)\n        return;\n      const c = Rl(\n        d,\n        e.orientation.value,\n        e.dir.value\n      );\n      if (c !== void 0) {\n        d.preventDefault();\n        let p = [...r.value];\n        if (c === \"last\")\n          p.reverse();\n        else if (c === \"prev\" || c === \"next\") {\n          c === \"prev\" && p.reverse();\n          const f = p.indexOf(\n            d.currentTarget\n          );\n          p = e.loop.value ? Vl(p, f + 1) : p.slice(f + 1);\n        }\n        G(() => Hn(p));\n      }\n    }\n    return (d, c) => (h(), b(a(D), {\n      \"data-radix-vue-collection-item\": \"\",\n      tabindex: l.value ? 0 : -1,\n      \"data-orientation\": a(e).orientation.value,\n      \"data-active\": d.active,\n      \"data-disabled\": !d.focusable || void 0,\n      as: d.as,\n      \"as-child\": d.asChild,\n      onMousedown: c[0] || (c[0] = (p) => {\n        d.focusable ? a(e).onItemFocus(s.value) : p.preventDefault();\n      }),\n      onFocus: c[1] || (c[1] = (p) => a(e).onItemFocus(s.value)),\n      onKeydown: u\n    }, {\n      default: v(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"tabindex\", \"data-orientation\", \"data-active\", \"data-disabled\", \"as\", \"as-child\"]));\n  }\n}), [Io, Kl] = H(\"MenuContent\"), Ao = /* @__PURE__ */ g({\n  __name: \"MenuContentImpl\",\n  props: yn({\n    loop: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    disableOutsideScroll: { type: Boolean },\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  }, {\n    ...kn\n  }),\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = We(), l = vt(), { trapFocus: i, disableOutsidePointerEvents: r, loop: u } = z(e);\n    Co(), pt(r.value);\n    const d = B(\"\"), c = B(0), p = B(0), f = B(null), m = B(\"right\"), C = B(0), w = B(null), { createCollection: $ } = re(), { primitiveElement: _, currentElement: E } = V(), x = $(E);\n    Y(E, (O) => {\n      s.onContentChange(O);\n    });\n    const { handleTypeaheadSearch: P } = _o(x);\n    fe(() => {\n      window.clearTimeout(c.value);\n    });\n    function I(O) {\n      var j, Z;\n      return m.value === ((j = f.value) == null ? void 0 : j.side) && Gs(O, (Z = f.value) == null ? void 0 : Z.area);\n    }\n    async function A(O) {\n      var K;\n      n(\"openAutoFocus\", O), !O.defaultPrevented && (O.preventDefault(), (K = E.value) == null || K.focus());\n    }\n    function L(O) {\n      if (O.defaultPrevented)\n        return;\n      const j = O.target.closest(\"[data-radix-menu-content]\") === O.currentTarget, Z = O.ctrlKey || O.altKey || O.metaKey, F = O.key.length === 1, q = qe(\n        O,\n        document.activeElement,\n        E.value,\n        {\n          loop: u.value,\n          arrowKeyOptions: \"vertical\",\n          dir: l == null ? void 0 : l.dir.value,\n          focus: !0\n        }\n      );\n      if (q)\n        return q == null ? void 0 : q.focus();\n      if (O.code === \"Space\" || (j && (O.key === \"Tab\" && O.preventDefault(), !Z && F && P(O.key)), O.target !== E.value) || !js.includes(O.key))\n        return;\n      O.preventDefault();\n      const oe = x.value;\n      Tn.includes(O.key) && oe.reverse(), ao(oe);\n    }\n    function M(O) {\n      var K, j;\n      (j = (K = O == null ? void 0 : O.currentTarget) == null ? void 0 : K.contains) != null && j.call(K, O.target) || (window.clearTimeout(c.value), d.value = \"\");\n    }\n    function W(O) {\n      var Z;\n      if (!st(O))\n        return;\n      const K = O.target, j = C.value !== O.clientX;\n      if ((Z = O == null ? void 0 : O.currentTarget) != null && Z.contains(K) && j) {\n        const F = O.clientX > C.value ? \"right\" : \"left\";\n        m.value = F, C.value = O.clientX;\n      }\n    }\n    return Kl({\n      onItemEnter: (O) => !!I(O),\n      onItemLeave: (O) => {\n        var K;\n        I(O) || ((K = E.value) == null || K.focus(), w.value = null);\n      },\n      onTriggerLeave: (O) => !!I(O),\n      searchRef: d,\n      pointerGraceTimerRef: p,\n      onPointerGraceIntentChange: (O) => {\n        f.value = O;\n      }\n    }), (O, K) => (h(), b(a(Mt), {\n      \"as-child\": \"\",\n      trapped: a(i),\n      onMountAutoFocus: A,\n      onUnmountAutoFocus: K[7] || (K[7] = (j) => n(\"closeAutoFocus\", j))\n    }, {\n      default: v(() => [\n        k(a(Se), {\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": a(r),\n          onEscapeKeyDown: K[2] || (K[2] = (j) => n(\"escapeKeyDown\", j)),\n          onPointerDownOutside: K[3] || (K[3] = (j) => n(\"pointerDownOutside\", j)),\n          onFocusOutside: K[4] || (K[4] = (j) => n(\"focusOutside\", j)),\n          onInteractOutside: K[5] || (K[5] = (j) => n(\"interactOutside\", j)),\n          onDismiss: K[6] || (K[6] = (j) => n(\"dismiss\"))\n        }, {\n          default: v(() => [\n            k(a(Je), {\n              \"current-tab-stop-id\": w.value,\n              \"onUpdate:currentTabStopId\": K[0] || (K[0] = (j) => w.value = j),\n              \"as-child\": \"\",\n              orientation: \"vertical\",\n              dir: a(l).dir.value,\n              loop: a(u),\n              onEntryFocus: K[1] || (K[1] = (j) => {\n                n(\"entryFocus\", j), a(l).isUsingKeyboardRef.value || j.preventDefault();\n              })\n            }, {\n              default: v(() => [\n                k(a(Ge), {\n                  ref_key: \"primitiveElement\",\n                  ref: _,\n                  role: \"menu\",\n                  as: O.as,\n                  \"as-child\": O.asChild,\n                  \"aria-orientation\": \"vertical\",\n                  \"data-radix-menu-content\": \"\",\n                  \"data-state\": a(Bo)(a(s).open.value),\n                  dir: a(l).dir.value,\n                  side: O.side,\n                  \"side-offset\": O.sideOffset,\n                  align: O.align,\n                  \"align-offset\": O.alignOffset,\n                  \"avoid-collisions\": O.avoidCollisions,\n                  \"collision-boundary\": O.collisionBoundary,\n                  \"collision-padding\": O.collisionPadding,\n                  \"arrow-padding\": O.arrowPadding,\n                  sticky: O.sticky,\n                  \"hide-when-detached\": O.hideWhenDetached,\n                  onKeydown: L,\n                  onBlur: M,\n                  onPointermove: W\n                }, {\n                  default: v(() => [\n                    y(O.$slots, \"default\")\n                  ]),\n                  _: 3\n                }, 8, [\"as\", \"as-child\", \"data-state\", \"dir\", \"side\", \"side-offset\", \"align\", \"align-offset\", \"avoid-collisions\", \"collision-boundary\", \"collision-padding\", \"arrow-padding\", \"sticky\", \"hide-when-detached\"])\n              ]),\n              _: 3\n            }, 8, [\"current-tab-stop-id\", \"dir\", \"loop\"])\n          ]),\n          _: 3\n        }, 8, [\"disable-outside-pointer-events\"])\n      ]),\n      _: 3\n    }, 8, [\"trapped\"]));\n  }\n}), Wn = /* @__PURE__ */ g({\n  __name: \"MenuItemImpl\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o, { expose: t }) {\n    const e = o, { primitiveElement: n, currentElement: s } = V(), l = Io(), i = B(!1);\n    async function r(d) {\n      if (!d.defaultPrevented && st(d)) {\n        if (e.disabled)\n          l.onItemLeave(d);\n        else if (!l.onItemEnter(d)) {\n          const p = d.currentTarget;\n          p == null || p.focus();\n        }\n      }\n    }\n    async function u(d) {\n      await G(), !d.defaultPrevented && st(d) && l.onItemLeave(d);\n    }\n    return t({\n      el: s\n    }), (d, c) => (h(), b(a(D), {\n      ref_key: \"primitiveElement\",\n      ref: n,\n      role: \"menuitem\",\n      tabindex: \"-1\",\n      as: d.as,\n      \"as-child\": d.asChild,\n      \"data-radix-vue-collection-item\": \"\",\n      \"aria-disabled\": d.disabled || void 0,\n      \"data-disabled\": d.disabled ? \"\" : void 0,\n      disabled: d.disabled,\n      \"data-highlighted\": i.value ? \"\" : void 0,\n      onPointermove: r,\n      onPointerleave: u,\n      onFocus: c[0] || (c[0] = async (p) => {\n        await G(), !(p.defaultPrevented || d.disabled) && (i.value = !0);\n      }),\n      onBlur: c[1] || (c[1] = async (p) => {\n        await G(), !p.defaultPrevented && (i.value = !1);\n      })\n    }, {\n      default: v(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"aria-disabled\", \"data-disabled\", \"disabled\", \"data-highlighted\"]));\n  }\n}), mt = /* @__PURE__ */ g({\n  __name: \"MenuItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { primitiveElement: s, currentElement: l } = V(), i = vt(), r = Io(), u = B(!1);\n    async function d() {\n      const c = l.value;\n      if (!e.disabled && c) {\n        const p = new CustomEvent(Hs, {\n          bubbles: !0,\n          cancelable: !0\n        });\n        n(\"select\", p), await G(), p.defaultPrevented ? u.value = !1 : i.onClose();\n      }\n    }\n    return (c, p) => (h(), b(Wn, T(e, {\n      ref_key: \"primitiveElement\",\n      ref: s,\n      onClick: d,\n      onPointerdown: p[0] || (p[0] = () => {\n        u.value = !0;\n      }),\n      onPointerup: p[1] || (p[1] = async (f) => {\n        var m;\n        await G(), !f.defaultPrevented && (u.value || (m = f.currentTarget) == null || m.click());\n      }),\n      onKeydown: p[2] || (p[2] = async (f) => {\n        const m = a(r).searchRef.value !== \"\";\n        c.disabled || m && f.key === \" \" || a(no).includes(f.key) && (f.currentTarget.click(), f.preventDefault());\n      })\n    }), {\n      default: v(() => [\n        y(c.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Nl, jn] = H(\n  [\"MenuCheckboxItem\", \"MenuRadioItem\"],\n  \"MenuItemIndicatorContext\"\n), Mo = /* @__PURE__ */ g({\n  __name: \"MenuItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = Nl({\n      checked: B(!1)\n    });\n    return (e, n) => (h(), b(a(se), {\n      present: e.forceMount || a(Pt)(a(t).checked.value) || a(t).checked.value === !0\n    }, {\n      default: v(() => [\n        k(a(D), {\n          as: e.as,\n          \"as-child\": e.asChild,\n          \"data-state\": a(Po)(a(t).checked.value)\n        }, {\n          default: v(() => [\n            y(e.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\", \"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), ko = /* @__PURE__ */ g({\n  __name: \"MenuCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String], default: !1 },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = X(e, \"checked\", n);\n    return jn({ checked: s }), (l, i) => (h(), b(mt, T({ role: \"menuitemcheckbox\" }, e, {\n      \"aria-checked\": a(Pt)(a(s)) ? \"mixed\" : a(s),\n      \"data-state\": a(Po)(a(s)),\n      onSelect: i[0] || (i[0] = async (r) => {\n        n(\"select\", r), a(Pt)(a(s)) ? s.value = !0 : s.value = !a(s);\n      })\n    }), {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-checked\", \"data-state\"]));\n  }\n}), Hl = /* @__PURE__ */ g({\n  __name: \"MenuRootContentModal\",\n  props: {\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = pe(e, n), l = We(), { primitiveElement: i, currentElement: r } = V();\n    return ft(r), (u, d) => (h(), b(Ao, T({\n      ref_key: \"primitiveElement\",\n      ref: i\n    }, a(s), {\n      \"trap-focus\": a(l).open.value,\n      \"disable-outside-pointer-events\": a(l).open.value,\n      \"disable-outside-scroll\": !0,\n      onDismiss: d[0] || (d[0] = (c) => a(l).onOpenChange(!1)),\n      onFocusOutside: d[1] || (d[1] = ne((c) => n(\"focusOutside\", c), [\"prevent\"]))\n    }), {\n      default: v(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"trap-focus\", \"disable-outside-pointer-events\"]));\n  }\n}), Wl = /* @__PURE__ */ g({\n  __name: \"MenuRootContentNonModal\",\n  props: {\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const s = pe(o, t), l = We();\n    return (i, r) => (h(), b(Ao, T(a(s), {\n      \"trap-focus\": !1,\n      \"disable-outside-pointer-events\": !1,\n      \"disable-outside-scroll\": !1,\n      onDismiss: r[0] || (r[0] = (u) => a(l).onOpenChange(!1))\n    }), {\n      default: v(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ro = /* @__PURE__ */ g({\n  __name: \"MenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const s = pe(o, t), l = We(), i = vt();\n    return (r, u) => (h(), b(a(se), {\n      present: r.forceMount || a(l).open.value\n    }, {\n      default: v(() => [\n        a(i).modal.value ? (h(), b(Hl, R(T({ key: 0 }, { ...r.$attrs, ...a(s) })), {\n          default: v(() => [\n            y(r.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)) : (h(), b(Wl, R(T({ key: 1 }, { ...r.$attrs, ...a(s) })), {\n          default: v(() => [\n            y(r.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16))\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Rt = /* @__PURE__ */ g({\n  __name: \"MenuGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(D), T({ role: \"group\" }, t), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Vo = /* @__PURE__ */ g({\n  __name: \"MenuLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(D), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Fo = /* @__PURE__ */ g({\n  __name: \"MenuPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Pe), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [jl, zl] = H(\"MenuRadioGroup\"), Lo = /* @__PURE__ */ g({\n  __name: \"MenuRadioGroup\",\n  props: {\n    modelValue: { default: \"\" },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { emit: t }) {\n    const e = o, s = X(e, \"modelValue\", t);\n    return zl({\n      modelValue: s,\n      onValueChange: (l) => {\n        s.value = l;\n      }\n    }), (l, i) => (h(), b(Rt, R(N(e)), {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ko = /* @__PURE__ */ g({\n  __name: \"MenuRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { value: s } = z(e), l = jl(), i = S(\n      () => l.modelValue.value === (s == null ? void 0 : s.value)\n    );\n    return jn({ checked: i }), (r, u) => (h(), b(mt, T({ role: \"menuitemradio\" }, e, {\n      \"aria-checked\": i.value,\n      \"data-state\": a(Po)(i.value),\n      onSelect: u[0] || (u[0] = async (d) => {\n        n(\"select\", d), a(l).onValueChange(a(s));\n      })\n    }), {\n      default: v(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-checked\", \"data-state\"]));\n  }\n}), No = /* @__PURE__ */ g({\n  __name: \"MenuSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(D), T(t, {\n      role: \"separator\",\n      \"aria-orientation\": \"horizontal\"\n    }), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [zn, Ul] = H(\"MenuSub\"), Ho = /* @__PURE__ */ g({\n  __name: \"MenuSub\",\n  props: {\n    open: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, s = X(e, \"open\", t, {\n      defaultValue: !1,\n      passive: e.open === void 0\n    }), l = We(), i = B(), r = B();\n    return ee((u) => {\n      (l == null ? void 0 : l.open.value) === !1 && (s.value = !1), u(() => s.value = !1);\n    }), Nn({\n      open: s,\n      onOpenChange: (u) => {\n        s.value = u;\n      },\n      content: r,\n      onContentChange: (u) => {\n        r.value = u;\n      }\n    }), Ul({\n      triggerId: te(),\n      contentId: te(),\n      trigger: i,\n      onTriggerChange: (u) => {\n        i.value = u;\n      }\n    }), (u, d) => (h(), b(a(Ne), null, {\n      default: v(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), Wo = /* @__PURE__ */ g({\n  __name: \"MenuSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    disableOutsideScroll: { type: Boolean },\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const s = pe(o, t), l = We(), i = vt(), r = zn(), { primitiveElement: u, currentElement: d } = V();\n    return (c, p) => (h(), b(a(se), {\n      present: c.forceMount || a(l).open.value\n    }, {\n      default: v(() => [\n        k(Ao, T(a(s), {\n          id: a(r).contentId,\n          ref_key: \"primitiveElement\",\n          ref: u,\n          \"aria-labelledby\": a(r).triggerId,\n          align: \"start\",\n          side: a(i).dir.value === \"rtl\" ? \"left\" : \"right\",\n          \"disable-outside-pointer-events\": !1,\n          \"disable-outside-scroll\": !1,\n          \"trap-focus\": !1,\n          onOpenAutoFocus: p[0] || (p[0] = ne((f) => {\n            var m;\n            a(i).isUsingKeyboardRef.value && ((m = a(d)) == null || m.focus());\n          }, [\"prevent\"])),\n          onCloseAutoFocus: p[1] || (p[1] = ne(() => {\n          }, [\"prevent\"])),\n          onFocusOutside: p[2] || (p[2] = (f) => {\n            f.defaultPrevented || f.target !== a(r).trigger.value && a(l).onOpenChange(!1);\n          }),\n          onEscapeKeyDown: p[3] || (p[3] = (f) => {\n            a(i).onClose(), f.preventDefault();\n          }),\n          onKeydown: p[4] || (p[4] = (f) => {\n            var w, $;\n            const m = (w = f.currentTarget) == null ? void 0 : w.contains(f.target), C = a(Us)[a(i).dir.value].includes(f.key);\n            m && C && (a(l).onOpenChange(!1), ($ = a(r).trigger.value) == null || $.focus(), f.preventDefault());\n          })\n        }), {\n          default: v(() => [\n            y(c.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"id\", \"aria-labelledby\", \"side\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), jo = /* @__PURE__ */ g({\n  __name: \"MenuSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = We(), n = vt(), s = zn(), l = Io(), i = B(null);\n    function r() {\n      i.value && window.clearTimeout(i.value), i.value = null;\n    }\n    fe(() => {\n      r();\n    });\n    function u(p) {\n      !st(p) || l.onItemEnter(p) || !t.disabled && !e.open.value && !i.value && (l.onPointerGraceIntentChange(null), i.value = window.setTimeout(() => {\n        e.onOpenChange(!0), r();\n      }, 100));\n    }\n    async function d(p) {\n      var m, C;\n      if (!st(p))\n        return;\n      r();\n      const f = (m = e.content.value) == null ? void 0 : m.getBoundingClientRect();\n      if (f != null && f.width) {\n        const w = (C = e.content.value) == null ? void 0 : C.dataset.side, $ = w === \"right\", _ = $ ? -5 : 5, E = f[$ ? \"left\" : \"right\"], x = f[$ ? \"right\" : \"left\"];\n        l.onPointerGraceIntentChange({\n          area: [\n            // Apply a bleed on clientX to ensure that our exit point is\n            // consistently within polygon bounds\n            { x: p.clientX + _, y: p.clientY },\n            { x: E, y: f.top },\n            { x, y: f.top },\n            { x, y: f.bottom },\n            { x: E, y: f.bottom }\n          ],\n          side: w\n        }), window.clearTimeout(l.pointerGraceTimerRef.value), l.pointerGraceTimerRef.value = window.setTimeout(\n          () => l.onPointerGraceIntentChange(null),\n          300\n        );\n      } else {\n        if (l.onTriggerLeave(p))\n          return;\n        l.onPointerGraceIntentChange(null);\n      }\n    }\n    async function c(p) {\n      var m;\n      const f = l.searchRef.value !== \"\";\n      t.disabled || f && p.key === \" \" || zs[n.dir.value].includes(p.key) && (e.onOpenChange(!0), await G(), (m = e.content.value) == null || m.focus(), p.preventDefault());\n    }\n    return (p, f) => (h(), b(kt, { \"as-child\": \"\" }, {\n      default: v(() => [\n        k(Wn, T(t, {\n          id: a(s).triggerId,\n          ref: (m) => {\n            var C;\n            (C = a(s)) == null || C.onTriggerChange(m == null ? void 0 : m.el);\n          },\n          \"aria-haspopup\": \"menu\",\n          \"aria-expanded\": a(e).open.value,\n          \"aria-controls\": a(s).contentId,\n          \"data-state\": a(Bo)(a(e).open.value),\n          onClick: f[0] || (f[0] = async (m) => {\n            t.disabled || m.defaultPrevented || (m.currentTarget.focus(), a(e).open.value || a(e).onOpenChange(!0));\n          }),\n          onPointermove: u,\n          onPointerleave: d,\n          onKeydown: c\n        }), {\n          default: v(() => [\n            y(p.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"id\", \"aria-expanded\", \"aria-controls\", \"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), [Un, ql] = H(\"ContextMenuRoot\"), Ou = /* @__PURE__ */ g({\n  __name: \"ContextMenuRoot\",\n  props: {\n    dir: {},\n    modal: { type: Boolean, default: !0 }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { dir: s, modal: l } = z(e), i = de(s), r = B(!1);\n    return ql({\n      open: r,\n      onOpenChange: (u) => {\n        r.value = u, n(\"update:open\", u);\n      },\n      dir: i,\n      modal: l\n    }), (u, d) => (h(), b(a(Oo), {\n      open: r.value,\n      \"onUpdate:open\": d[0] || (d[0] = (c) => r.value = c),\n      dir: a(i),\n      modal: a(l)\n    }, {\n      default: v(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\", \"dir\", \"modal\"]));\n  }\n});\nfunction ln(o) {\n  return o.pointerType !== \"mouse\";\n}\nconst Iu = /* @__PURE__ */ g({\n  inheritAttrs: !1,\n  __name: \"ContextMenuTrigger\",\n  props: {\n    disabled: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = o, { disabled: e } = z(t), n = Un(), s = B({ x: 0, y: 0 }), l = S(() => ({\n      getBoundingClientRect: () => ({\n        width: 0,\n        height: 0,\n        left: s.value.x,\n        right: s.value.x,\n        top: s.value.y,\n        bottom: s.value.y,\n        ...s.value\n      })\n    })), i = B(0);\n    function r() {\n      window.clearTimeout(i.value);\n    }\n    function u(f) {\n      s.value = { x: f.clientX, y: f.clientY }, n.onOpenChange(!0);\n    }\n    async function d(f) {\n      e.value || (await G(), f.defaultPrevented || (r(), u(f), f.preventDefault()));\n    }\n    async function c(f) {\n      e.value || (await G(), ln(f) && !f.defaultPrevented && (r(), i.value = window.setTimeout(() => u(f), 700)));\n    }\n    async function p(f) {\n      e.value || (await G(), ln(f) && !f.defaultPrevented && r());\n    }\n    return (f, m) => (h(), Q(ie, null, [\n      k(a(kt), {\n        as: \"div\",\n        element: l.value\n      }, null, 8, [\"element\"]),\n      k(a(D), T({\n        as: f.as,\n        \"as-child\": f.asChild,\n        \"data-state\": a(n).open.value ? \"open\" : \"closed\",\n        \"data-disabled\": a(e) ? \"\" : void 0,\n        style: {\n          WebkitTouchCallout: \"none\"\n        }\n      }, f.$attrs, {\n        onContextmenu: d,\n        onPointerdown: c,\n        onPointermove: p,\n        onPointercancel: p,\n        onPointerup: p\n      }), {\n        default: v(() => [\n          y(f.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"as\", \"as-child\", \"data-state\", \"data-disabled\"])\n    ], 64));\n  }\n}), Au = /* @__PURE__ */ g({\n  __name: \"ContextMenuPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Fo), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Mu = /* @__PURE__ */ g({\n  __name: \"ContextMenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    alignOffset: { default: 0 },\n    avoidCollisions: { type: Boolean, default: !0 },\n    collisionBoundary: { default: () => [] },\n    collisionPadding: { default: 0 },\n    sticky: { default: \"partial\" },\n    hideWhenDetached: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = Un(), l = B(!1);\n    return (i, r) => (h(), b(a(Ro), T(e, {\n      side: \"right\",\n      \"side-offset\": 2,\n      align: \"start\",\n      style: {\n        \"--radix-context-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n        \"--radix-context-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n        \"--radix-context-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n        \"--radix-context-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n        \"--radix-context-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n      },\n      onCloseAutoFocus: r[0] || (r[0] = (u) => {\n        n(\"closeAutoFocus\", u), !u.defaultPrevented && l.value && u.preventDefault(), l.value = !1;\n      }),\n      onInteractOutside: r[1] || (r[1] = (u) => {\n        n(\"interactOutside\", u), !u.defaultPrevented && !a(s).modal.value && (l.value = !0);\n      })\n    }), {\n      default: v(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"style\"]));\n  }\n}), ku = /* @__PURE__ */ g({\n  __name: \"ContextMenuArrow\",\n  props: {\n    width: {},\n    height: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Do), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ru = /* @__PURE__ */ g({\n  __name: \"ContextMenuItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o, { emit: t }) {\n    const e = o, s = ce(t);\n    return (l, i) => (h(), b(a(mt), R(N({ ...e, ...a(s) })), {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Vu = /* @__PURE__ */ g({\n  __name: \"ContextMenuGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Rt), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Fu = /* @__PURE__ */ g({\n  __name: \"ContextMenuSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(No), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Lu = /* @__PURE__ */ g({\n  __name: \"ContextMenuCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String] },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(o, { emit: t }) {\n    const e = o, s = ce(t);\n    return (l, i) => (h(), b(a(ko), R(N({ ...e, ...a(s) })), {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ku = /* @__PURE__ */ g({\n  __name: \"ContextMenuItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Mo), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Nu = /* @__PURE__ */ g({\n  __name: \"ContextMenuLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Vo), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Hu = /* @__PURE__ */ g({\n  __name: \"ContextMenuRadioGroup\",\n  props: {\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { emit: t }) {\n    const e = o, s = ce(t);\n    return (l, i) => (h(), b(a(Lo), R(N({ ...e, ...a(s) })), {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Wu = /* @__PURE__ */ g({\n  __name: \"ContextMenuRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o, { emit: t }) {\n    const e = o, s = ce(t);\n    return (l, i) => (h(), b(a(Ko), R(N({ ...e, ...a(s) })), {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ju = /* @__PURE__ */ g({\n  __name: \"ContextMenuSub\",\n  props: {\n    open: { type: Boolean, default: void 0 },\n    defaultOpen: { type: Boolean }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, s = X(e, \"open\", t, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    });\n    return (l, i) => (h(), b(a(Ho), {\n      open: a(s),\n      \"onUpdate:open\": i[0] || (i[0] = (r) => ut(s) ? s.value = r : null)\n    }, {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\"]));\n  }\n}), zu = /* @__PURE__ */ g({\n  __name: \"ContextMenuSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    disableOutsideScroll: { type: Boolean },\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const s = pe(o, t);\n    return (l, i) => (h(), b(a(Wo), T(a(s), { style: {\n      \"--radix-context-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-context-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-context-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-context-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-context-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    } }), {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"style\"]));\n  }\n}), Uu = /* @__PURE__ */ g({\n  __name: \"ContextMenuSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(jo), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [qn, Gl] = H(\"DropdownMenuRoot\"), qu = /* @__PURE__ */ g({\n  __name: \"DropdownMenuRoot\",\n  props: {\n    open: { type: Boolean, default: void 0 },\n    defaultOpen: { type: Boolean },\n    dir: {},\n    modal: { type: Boolean, default: !0 }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, s = X(e, \"open\", t, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), l = B(), { modal: i, dir: r } = z(e), u = de(r);\n    return Gl({\n      open: s,\n      onOpenChange: (d) => {\n        s.value = d;\n      },\n      onOpenToggle: () => {\n        s.value = !s.value;\n      },\n      triggerId: te(),\n      triggerElement: l,\n      contentId: te(),\n      modal: i,\n      dir: u\n    }), (d, c) => (h(), b(a(Oo), {\n      open: a(s),\n      \"onUpdate:open\": c[0] || (c[0] = (p) => ut(s) ? s.value = p : null),\n      dir: a(u),\n      modal: a(i)\n    }, {\n      default: v(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\", \"dir\", \"modal\"]));\n  }\n}), Gu = /* @__PURE__ */ g({\n  __name: \"DropdownMenuTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = qn(), { primitiveElement: n, currentElement: s } = V();\n    return U(() => {\n      e.triggerElement = s;\n    }), (l, i) => (h(), b(a(kt), { \"as-child\": \"\" }, {\n      default: v(() => [\n        k(a(D), {\n          id: a(e).triggerId,\n          ref_key: \"primitiveElement\",\n          ref: n,\n          type: l.as === \"button\" ? \"button\" : void 0,\n          \"as-child\": t.asChild,\n          as: l.as,\n          \"aria-haspopup\": \"menu\",\n          \"aria-expanded\": a(e).open.value,\n          \"aria-controls\": a(e).open.value ? a(e).contentId : void 0,\n          \"data-disabled\": l.disabled ? \"\" : void 0,\n          disabled: l.disabled,\n          \"data-state\": a(e).open.value ? \"open\" : \"closed\",\n          onClick: i[0] || (i[0] = async (r) => {\n            var u;\n            !l.disabled && r.button === 0 && r.ctrlKey === !1 && ((u = a(e)) == null || u.onOpenToggle(), await G(), a(e).open.value && r.preventDefault());\n          }),\n          onKeydown: i[1] || (i[1] = le(\n            (r) => {\n              l.disabled || ([\"Enter\", \" \"].includes(r.key) && a(e).onOpenToggle(), r.key === \"ArrowDown\" && a(e).onOpenChange(!0), [\"Enter\", \" \", \"ArrowDown\"].includes(r.key) && r.preventDefault());\n            },\n            [\"enter\", \"space\", \"arrow-down\"]\n          ))\n        }, {\n          default: v(() => [\n            y(l.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"id\", \"type\", \"as-child\", \"as\", \"aria-expanded\", \"aria-controls\", \"data-disabled\", \"disabled\", \"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Yu = /* @__PURE__ */ g({\n  __name: \"DropdownMenuPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Fo), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Xu = /* @__PURE__ */ g({\n  __name: \"DropdownMenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = pe(e, n), l = qn(), i = B(!1);\n    function r(u) {\n      n(\"closeAutoFocus\", u), !u.defaultPrevented && (i.value || setTimeout(() => {\n        var d;\n        (d = l.triggerElement.value) == null || d.focus();\n      }, 0), i.value = !1, u.preventDefault());\n    }\n    return (u, d) => {\n      var c;\n      return h(), b(a(Ro), T(a(s), {\n        id: a(l).contentId,\n        \"aria-labelledby\": (c = a(l)) == null ? void 0 : c.triggerId,\n        style: {\n          \"--radix-dropdown-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n          \"--radix-dropdown-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n          \"--radix-dropdown-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n          \"--radix-dropdown-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n          \"--radix-dropdown-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n        },\n        onCloseAutoFocus: r,\n        onInteractOutside: d[0] || (d[0] = (p) => {\n          if (n(\"interactOutside\", p), p.defaultPrevented)\n            return;\n          const f = p.detail.originalEvent, m = f.button === 0 && f.ctrlKey === !0, C = f.button === 2 || m;\n          (!a(l).modal.value || C) && (i.value = !0);\n        })\n      }), {\n        default: v(() => [\n          y(u.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\", \"aria-labelledby\", \"style\"]);\n    };\n  }\n}), Ju = /* @__PURE__ */ g({\n  __name: \"DropdownMenuArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Do), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Zu = /* @__PURE__ */ g({\n  __name: \"DropdownMenuItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o, { emit: t }) {\n    const e = o, s = ce(t);\n    return (l, i) => (h(), b(a(mt), R(N({ ...e, ...a(s) })), {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Qu = /* @__PURE__ */ g({\n  __name: \"DropdownMenuGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Rt), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ed = /* @__PURE__ */ g({\n  __name: \"DropdownMenuSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(No), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), td = /* @__PURE__ */ g({\n  __name: \"DropdownMenuCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String] },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(o, { emit: t }) {\n    const e = o, s = ce(t);\n    return (l, i) => (h(), b(a(ko), R(N({ ...e, ...a(s) })), {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), od = /* @__PURE__ */ g({\n  __name: \"DropdownMenuItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Mo), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), nd = /* @__PURE__ */ g({\n  __name: \"DropdownMenuLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Vo), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ad = /* @__PURE__ */ g({\n  __name: \"DropdownMenuRadioGroup\",\n  props: {\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { emit: t }) {\n    const e = o, s = ce(t);\n    return (l, i) => (h(), b(a(Lo), R(N({ ...e, ...a(s) })), {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), sd = /* @__PURE__ */ g({\n  __name: \"DropdownMenuRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t;\n    return (s, l) => (h(), b(a(Ko), R(N({ ...e, ...n })), {\n      default: v(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ld = /* @__PURE__ */ g({\n  __name: \"DropdownMenuSub\",\n  props: {\n    open: { type: Boolean, default: void 0 },\n    defaultOpen: { type: Boolean }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, s = X(e, \"open\", t, {\n      passive: e.open === void 0,\n      defaultValue: e.defaultOpen ?? !1\n    });\n    return (l, i) => (h(), b(a(Ho), {\n      open: a(s),\n      \"onUpdate:open\": i[0] || (i[0] = (r) => ut(s) ? s.value = r : null)\n    }, {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\"]));\n  }\n}), id = /* @__PURE__ */ g({\n  __name: \"DropdownMenuSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    disableOutsideScroll: { type: Boolean },\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const s = pe(o, t);\n    return (l, i) => (h(), b(a(Wo), T(a(s), { style: {\n      \"--radix-dropdown-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-dropdown-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-dropdown-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-dropdown-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-dropdown-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    } }), {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"style\"]));\n  }\n}), rd = /* @__PURE__ */ g({\n  __name: \"DropdownMenuSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(jo), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [zo, Yl] = H(\"HoverCardRoot\"), ud = /* @__PURE__ */ g({\n  __name: \"HoverCardRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    openDelay: { default: 700 },\n    closeDelay: { default: 300 }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { openDelay: s, closeDelay: l } = z(e), i = X(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), r = B(0), u = B(0), d = B(!1), c = B(!1);\n    function p() {\n      clearTimeout(u.value), r.value = window.setTimeout(() => i.value = !0, s.value);\n    }\n    function f() {\n      clearTimeout(r.value), !d.value && !c.value && (u.value = window.setTimeout(() => i.value = !1, l.value));\n    }\n    function m() {\n      i.value = !1;\n    }\n    return Yl({\n      open: i,\n      onOpenChange(C) {\n        i.value = C;\n      },\n      onOpen: p,\n      onClose: f,\n      onDismiss: m,\n      hasSelectionRef: d,\n      isPointerDownOnContentRef: c\n    }), (C, w) => (h(), b(a(Ne), null, {\n      default: v(() => [\n        y(C.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n});\nfunction St(o) {\n  return (t) => t.pointerType === \"touch\" ? void 0 : o();\n}\nfunction Xl(o) {\n  const t = [], e = document.createTreeWalker(o, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (n) => n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP\n  });\n  for (; e.nextNode(); )\n    t.push(e.currentNode);\n  return t;\n}\nconst dd = /* @__PURE__ */ g({\n  __name: \"HoverCardTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"a\" }\n  },\n  setup(o) {\n    const t = zo();\n    return (e, n) => (h(), b(a(He), { \"as-child\": \"\" }, {\n      default: v(() => [\n        k(a(D), {\n          \"as-child\": e.asChild,\n          as: e.as,\n          \"data-state\": a(t).open.value ? \"open\" : \"closed\",\n          onPointerenter: n[0] || (n[0] = (s) => a(St)(a(t).onOpen)(s)),\n          onPointerleave: n[1] || (n[1] = (s) => a(St)(a(t).onClose)(s)),\n          onFocus: n[2] || (n[2] = (s) => a(t).onOpen()),\n          onBlur: a(t).onClose,\n          onTouchstart: ne(() => {\n          }, [\"prevent\"])\n        }, {\n          default: v(() => [\n            y(e.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as-child\", \"as\", \"data-state\", \"onBlur\", \"onTouchstart\"])\n      ]),\n      _: 3\n    }));\n  }\n}), cd = /* @__PURE__ */ g({\n  __name: \"HoverCardPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Pe), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Jl = /* @__PURE__ */ g({\n  __name: \"HoverCardContentImpl\",\n  props: {\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    onPlaced: { type: Function },\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = It(e), { primitiveElement: l, currentElement: i } = V(), r = zo(), u = B(!1);\n    let d;\n    ee((p) => {\n      if (u.value) {\n        const f = document.body;\n        d = f.style.userSelect || f.style.webkitUserSelect, f.style.userSelect = \"none\", f.style.webkitUserSelect = \"none\", p(() => {\n          f.style.userSelect = d, f.style.webkitUserSelect = d;\n        });\n      }\n    });\n    function c() {\n      u.value = !1, r.isPointerDownOnContentRef.value = !1, G(() => {\n        var f;\n        ((f = document.getSelection()) == null ? void 0 : f.toString()) !== \"\" && (r.hasSelectionRef.value = !0);\n      });\n    }\n    return U(() => {\n      i.value && (document.addEventListener(\"pointerup\", c), Xl(i.value).forEach((f) => f.setAttribute(\"tabindex\", \"-1\")));\n    }), fe(() => {\n      document.removeEventListener(\"pointerup\", c), r.hasSelectionRef.value = !1, r.isPointerDownOnContentRef.value = !1;\n    }), (p, f) => (h(), b(a(Se), {\n      \"as-child\": \"\",\n      \"disable-outside-pointer-events\": !1,\n      onEscapeKeyDown: f[1] || (f[1] = (m) => n(\"escapeKeyDown\", m)),\n      onPointerDownOutside: f[2] || (f[2] = (m) => n(\"pointerDownOutside\", m)),\n      onFocusOutside: f[3] || (f[3] = ne((m) => n(\"focusOutside\", m), [\"prevent\"])),\n      onDismiss: a(r).onDismiss\n    }, {\n      default: v(() => [\n        k(a(Ge), T({\n          ref_key: \"primitiveElement\",\n          ref: l\n        }, { ...a(s), ...p.$attrs }, {\n          \"data-state\": a(r).open.value ? \"open\" : \"closed\",\n          style: {\n            userSelect: u.value ? \"text\" : void 0,\n            // Safari requires prefix\n            WebkitUserSelect: u.value ? \"text\" : void 0,\n            // re-namespace exposed content custom properties\n            \"--radix-hover-card-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n            \"--radix-hover-card-content-available-width\": \"var(--radix-popper-available-width)\",\n            \"--radix-hover-card-content-available-height\": \"var(--radix-popper-available-height)\",\n            \"--radix-hover-card-trigger-width\": \"var(--radix-popper-anchor-width)\",\n            \"--radix-hover-card-trigger-height\": \"var(--radix-popper-anchor-height)\"\n          },\n          onPointerdown: f[0] || (f[0] = (m) => {\n            m.currentTarget.contains(m.target) && (u.value = !0), a(r).hasSelectionRef.value = !1, a(r).isPointerDownOnContentRef.value = !0;\n          })\n        }), {\n          default: v(() => [\n            y(p.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\", \"style\"])\n      ]),\n      _: 3\n    }, 8, [\"onDismiss\"]));\n  }\n}), pd = /* @__PURE__ */ g({\n  __name: \"HoverCardContent\",\n  props: {\n    forceMount: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    onPlaced: { type: Function },\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\"],\n  setup(o, { emit: t }) {\n    const s = pe(o, t), l = zo();\n    return (i, r) => (h(), b(a(se), {\n      present: i.forceMount || a(l).open.value\n    }, {\n      default: v(() => [\n        k(Jl, T(a(s), {\n          onPointerenter: r[0] || (r[0] = (u) => a(St)(a(l).onOpen)(u)),\n          onPointerleave: r[1] || (r[1] = (u) => a(St)(a(l).onClose)(u))\n        }), {\n          default: v(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), fd = /* @__PURE__ */ g({\n  __name: \"HoverCardArrow\",\n  props: {\n    width: {},\n    height: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Ye), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), vd = /* @__PURE__ */ g({\n  __name: \"Label\",\n  props: {\n    for: {},\n    asChild: { type: Boolean },\n    as: { default: \"label\" }\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(D), T(t, {\n      onMousedown: n[0] || (n[0] = (s) => {\n        !s.defaultPrevented && s.detail > 1 && s.preventDefault();\n      })\n    }), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Vt, Zl] = H(\"MenubarRoot\"), md = /* @__PURE__ */ g({\n  __name: \"MenubarRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    dir: {},\n    loop: { type: Boolean, default: !1 }\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { primitiveElement: s, currentElement: l } = V(), { createCollection: i } = re(\"menubar\");\n    i(l);\n    const r = X(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue ?? \"\",\n      passive: e.modelValue === void 0\n    }), u = B(null), { dir: d, loop: c } = z(e), p = de(d);\n    return Zl({\n      modelValue: r,\n      dir: p,\n      loop: c,\n      onMenuOpen: (f) => {\n        r.value = f, u.value = f;\n      },\n      onMenuClose: () => {\n        r.value = \"\";\n      },\n      onMenuToggle: (f) => {\n        r.value = r.value ? \"\" : f, u.value = f;\n      }\n    }), (f, m) => (h(), b(a(Je), {\n      \"current-tab-stop-id\": u.value,\n      \"onUpdate:currentTabStopId\": m[0] || (m[0] = (C) => u.value = C),\n      orientation: \"horizontal\",\n      loop: a(c),\n      dir: a(p),\n      \"as-child\": \"\"\n    }, {\n      default: v(() => [\n        k(a(D), {\n          ref_key: \"primitiveElement\",\n          ref: s,\n          role: \"menubar\"\n        }, {\n          default: v(() => [\n            y(f.$slots, \"default\")\n          ]),\n          _: 3\n        }, 512)\n      ]),\n      _: 3\n    }, 8, [\"current-tab-stop-id\", \"loop\", \"dir\"]));\n  }\n}), [Uo, Ql] = H(\"MenubarMenu\"), hd = /* @__PURE__ */ g({\n  __name: \"MenubarMenu\",\n  props: {\n    value: {}\n  },\n  setup(o) {\n    const e = o.value ?? te(), n = Vt(), s = B(), l = B(!1), i = S(() => n.modelValue.value === e);\n    return Y(i, () => {\n      i.value || (l.value = !1);\n    }), Ql({\n      value: e,\n      triggerElement: s,\n      triggerId: e,\n      contentId: te(),\n      wasKeyboardTriggerOpenRef: l\n    }), (r, u) => (h(), b(a(Oo), {\n      open: i.value,\n      modal: !1,\n      dir: a(n).dir.value,\n      \"onUpdate:open\": u[0] || (u[0] = (d) => {\n        d || a(n).onMenuClose();\n      })\n    }, {\n      default: v(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\", \"dir\"]));\n  }\n}), yd = /* @__PURE__ */ g({\n  __name: \"MenubarTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = Vt(), e = Uo(), { primitiveElement: n, currentElement: s } = V(), l = B(!1), i = S(() => t.modelValue.value === e.value);\n    return U(() => {\n      e.triggerElement = s;\n    }), (r, u) => (h(), b(a(Ze), {\n      \"as-child\": \"\",\n      focusable: !r.disabled,\n      \"tab-stop-id\": a(e).value\n    }, {\n      default: v(() => [\n        k(a(kt), { \"as-child\": \"\" }, {\n          default: v(() => [\n            k(a(D), {\n              id: a(e).triggerId,\n              ref_key: \"primitiveElement\",\n              ref: n,\n              as: r.as,\n              type: r.as === \"button\" ? \"button\" : void 0,\n              role: \"menuitem\",\n              \"aria-haspopup\": \"menu\",\n              \"aria-expanded\": i.value,\n              \"aria-controls\": i.value ? a(e).contentId : void 0,\n              \"data-highlighted\": l.value ? \"\" : void 0,\n              \"data-state\": i.value ? \"open\" : \"closed\",\n              \"data-disabled\": r.disabled ? \"\" : void 0,\n              disabled: r.disabled,\n              \"data-value\": a(e).value,\n              \"data-radix-vue-collection-item\": \"\",\n              onPointerdown: u[0] || (u[0] = (d) => {\n                !r.disabled && d.button === 0 && d.ctrlKey === !1 && (a(t).onMenuOpen(a(e).value), i.value || d.preventDefault());\n              }),\n              onPointerenter: u[1] || (u[1] = () => {\n                var c;\n                !!a(t).modelValue.value && !i.value && (a(t).onMenuOpen(a(e).value), (c = a(s)) == null || c.focus());\n              }),\n              onKeydown: u[2] || (u[2] = le((d) => {\n                r.disabled || ([\"Enter\", \" \"].includes(d.key) && a(t).onMenuToggle(a(e).value), d.key === \"ArrowDown\" && a(t).onMenuOpen(a(e).value), [\"Enter\", \" \", \"ArrowDown\"].includes(d.key) && (a(e).wasKeyboardTriggerOpenRef.value = !0, d.preventDefault()));\n              }, [\"enter\", \"space\", \"arrow-down\"])),\n              onFocus: u[3] || (u[3] = (d) => l.value = !0),\n              onBlur: u[4] || (u[4] = (d) => l.value = !1)\n            }, {\n              default: v(() => [\n                y(r.$slots, \"default\")\n              ]),\n              _: 3\n            }, 8, [\"id\", \"as\", \"type\", \"aria-expanded\", \"aria-controls\", \"data-highlighted\", \"data-state\", \"data-disabled\", \"disabled\", \"data-value\"])\n          ]),\n          _: 3\n        })\n      ]),\n      _: 3\n    }, 8, [\"focusable\", \"tab-stop-id\"]));\n  }\n}), gd = /* @__PURE__ */ g({\n  __name: \"MenubarPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Fo), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), bd = /* @__PURE__ */ g({\n  __name: \"MenubarContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: { default: \"start\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const s = pe(o, t), l = Vt(), i = Uo(), { injectCollection: r } = re(\"menubar\"), u = r(), d = B(!1);\n    function c(p) {\n      const m = p.target.hasAttribute(\n        \"data-radix-menubar-subtrigger\"\n      ), w = (l.dir.value === \"rtl\" ? \"ArrowRight\" : \"ArrowLeft\") === p.key;\n      if (!w && m)\n        return;\n      let _ = u.value.map((P) => P.dataset.value);\n      w && _.reverse();\n      const E = _.indexOf(i.value);\n      _ = l.loop.value ? wo(_, E + 1) : _.slice(E + 1);\n      const [x] = _;\n      x && l.onMenuOpen(x);\n    }\n    return (p, f) => (h(), b(a(Ro), T({\n      id: a(i).contentId,\n      \"aria-labelledby\": a(i).triggerId,\n      \"data-radix-menubar-content\": \"\"\n    }, a(s), {\n      style: {\n        \"--radix-menubar-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n        \"--radix-menubar-content-available-width\": \"var(--radix-popper-available-width)\",\n        \"--radix-menubar-content-available-height\": \"var(--radix-popper-available-height)\",\n        \"--radix-menubar-trigger-width\": \"var(--radix-popper-anchor-width)\",\n        \"--radix-menubar-trigger-height\": \"var(--radix-popper-anchor-height)\"\n      },\n      onCloseAutoFocus: f[0] || (f[0] = (m) => {\n        var w;\n        !!!a(l).modelValue.value && !d.value && ((w = a(i).triggerElement.value) == null || w.focus()), d.value = !1, m.preventDefault();\n      }),\n      onFocusOutside: f[1] || (f[1] = (m) => {\n        const C = m.target;\n        a(u).some(($) => $.contains(C)) && m.preventDefault();\n      }),\n      onInteractOutside: f[2] || (f[2] = (m) => {\n        d.value = !0;\n      }),\n      onEntryFocus: f[3] || (f[3] = (m) => {\n        a(i).wasKeyboardTriggerOpenRef.value || m.preventDefault();\n      }),\n      onKeydown: le(c, [\"arrow-right\", \"arrow-left\"])\n    }), {\n      default: v(() => [\n        y(p.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\", \"aria-labelledby\", \"style\", \"onKeydown\"]));\n  }\n}), Cd = /* @__PURE__ */ g({\n  __name: \"MenubarArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Do), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), _d = /* @__PURE__ */ g({\n  __name: \"MenubarItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o, { emit: t }) {\n    const e = o, s = ce(t);\n    return (l, i) => (h(), b(a(mt), R(N({ ...e, ...a(s) })), {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), wd = /* @__PURE__ */ g({\n  __name: \"MenubarGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Rt), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ed = /* @__PURE__ */ g({\n  __name: \"MenubarSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(No), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), xd = /* @__PURE__ */ g({\n  __name: \"MenubarCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String] },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(o, { emit: t }) {\n    const e = o, s = ce(t);\n    return (l, i) => (h(), b(a(ko), R(N({ ...e, ...a(s) })), {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), $d = /* @__PURE__ */ g({\n  __name: \"MenubarItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Mo), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Bd = /* @__PURE__ */ g({\n  __name: \"MenubarLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Vo), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Pd = /* @__PURE__ */ g({\n  __name: \"MenubarRadioGroup\",\n  props: {\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { emit: t }) {\n    const e = o, s = ce(t);\n    return (l, i) => (h(), b(a(Lo), R(N({ ...e, ...a(s) })), {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Sd = /* @__PURE__ */ g({\n  __name: \"MenubarRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t;\n    return (s, l) => (h(), b(a(Ko), R(N({ ...e, ...n })), {\n      default: v(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Td = /* @__PURE__ */ g({\n  __name: \"MenubarSub\",\n  props: {\n    open: { type: Boolean, default: void 0 },\n    defaultOpen: { type: Boolean }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, s = X(e, \"open\", t, {\n      defaultValue: e.defaultOpen ?? !1,\n      passive: e.open === void 0\n    });\n    return (l, i) => (h(), b(a(Ho), {\n      open: a(s),\n      \"onUpdate:open\": i[0] || (i[0] = (r) => ut(s) ? s.value = r : null)\n    }, {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\"]));\n  }\n}), Dd = /* @__PURE__ */ g({\n  __name: \"MenubarSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    disableOutsideScroll: { type: Boolean },\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const s = pe(o, t), { injectCollection: l } = re(\"menubar\"), i = Vt(), r = Uo(), u = l();\n    function d(c) {\n      if (c.target.hasAttribute(\n        \"data-radix-menubar-subtrigger\"\n      ))\n        return;\n      let m = u.value.map(($) => $.dataset.value);\n      const C = m.indexOf(r.value);\n      m = i.loop.value ? wo(m, C + 1) : m.slice(C + 1);\n      const [w] = m;\n      w && i.onMenuOpen(w);\n    }\n    return (c, p) => (h(), b(a(Wo), T(a(s), {\n      \"data-radix-menubar-content\": \"\",\n      style: {\n        \"--radix-menubar-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n        \"--radix-menubar-content-available-width\": \"var(--radix-popper-available-width)\",\n        \"--radix-menubar-content-available-height\": \"var(--radix-popper-available-height)\",\n        \"--radix-menubar-trigger-width\": \"var(--radix-popper-anchor-width)\",\n        \"--radix-menubar-trigger-height\": \"var(--radix-popper-anchor-height)\"\n      },\n      onKeydown: le(d, [\"arrow-right\"])\n    }), {\n      default: v(() => [\n        y(c.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"style\", \"onKeydown\"]));\n  }\n}), Od = /* @__PURE__ */ g({\n  __name: \"MenubarSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(jo), T({ \"data-radix-menubar-subtrigger\": \"\" }, t), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Te, Gn] = H([\"NavigationMenuRoot\", \"NavigationMenuSub\"], \"NavigationMenuContext\"), Id = /* @__PURE__ */ g({\n  __name: \"NavigationMenuRoot\",\n  props: {\n    modelValue: { default: void 0 },\n    defaultValue: {},\n    dir: {},\n    orientation: { default: \"horizontal\" },\n    delayDuration: { default: 200 },\n    skipDelayDuration: { default: 300 },\n    asChild: { type: Boolean },\n    as: { default: \"nav\" }\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { emit: t }) {\n    const e = o, s = X(e, \"modelValue\", t, {\n      defaultValue: e.defaultValue ?? \"\",\n      passive: e.modelValue === void 0\n    }), l = B(\"\"), { primitiveElement: i, currentElement: r } = V(), u = B(), d = B(), { createCollection: c } = re(\"nav\");\n    c(u);\n    const { delayDuration: p, skipDelayDuration: f, dir: m } = z(e), C = de(m), w = ho(!1, f), $ = S(() => s.value !== \"\" || w.value ? 150 : p.value), _ = yo((E) => {\n      l.value = s.value, s.value = E;\n    }, $);\n    return Gn({\n      isRootMenu: !0,\n      modelValue: s,\n      previousValue: l,\n      baseId: te(),\n      dir: C,\n      orientation: e.orientation,\n      rootNavigationMenu: r,\n      indicatorTrack: u,\n      onIndicatorTrackChange: (E) => {\n        u.value = E;\n      },\n      viewport: d,\n      onViewportChange: (E) => {\n        d.value = E;\n      },\n      onTriggerEnter: (E) => {\n        _(E);\n      },\n      onTriggerLeave: () => {\n        w.value = !0, _(\"\");\n      },\n      onContentEnter: (E) => {\n        _(E);\n      },\n      onContentLeave: () => {\n        _(\"\");\n      },\n      onItemSelect: (E) => {\n        l.value = s.value, s.value = E;\n      },\n      onItemDismiss: () => {\n        l.value = s.value, s.value = \"\";\n      }\n    }), (E, x) => (h(), b(a(D), {\n      ref_key: \"primitiveElement\",\n      ref: i,\n      \"aria-label\": \"Main\",\n      as: E.as,\n      \"as-child\": E.asChild,\n      \"data-orientation\": E.orientation,\n      dir: a(C)\n    }, {\n      default: v(() => [\n        y(E.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-orientation\", \"dir\"]));\n  }\n});\nfunction Ft(o) {\n  return o ? \"open\" : \"closed\";\n}\nfunction Yn(o, t) {\n  return `${o}-trigger-${t}`;\n}\nfunction qo(o, t) {\n  return `${o}-content-${t}`;\n}\nconst Bt = \"navigationMenu.rootContentDismiss\";\nfunction lo(o) {\n  const t = [], e = document.createTreeWalker(o, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (n) => {\n      const s = n.tagName === \"INPUT\" && n.type === \"hidden\";\n      return n.disabled || n.hidden || s ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  for (; e.nextNode(); )\n    t.push(e.currentNode);\n  return t;\n}\nfunction Xn(o) {\n  const t = document.activeElement;\n  return o.some((e) => e === t ? !0 : (e.focus(), document.activeElement !== t));\n}\nfunction ei(o) {\n  return o.forEach((t) => {\n    t.dataset.tabindex = t.getAttribute(\"tabindex\") || \"\", t.setAttribute(\"tabindex\", \"-1\");\n  }), () => {\n    o.forEach((t) => {\n      const e = t.dataset.tabindex;\n      t.setAttribute(\"tabindex\", e);\n    });\n  };\n}\nconst [Go, ti] = H(\"NavigationMenuItem\"), Ad = /* @__PURE__ */ g({\n  __name: \"NavigationMenuItem\",\n  props: {\n    value: {},\n    asChild: { type: Boolean },\n    as: { default: \"li\" }\n  },\n  setup(o) {\n    const t = o, { injectCollection: e } = re(\"nav\"), n = e(), s = Te(), l = t.value || te(), i = B(), r = B(), u = qo(s.baseId, l);\n    let d = () => ({});\n    const c = B(!1);\n    async function p(w = \"start\") {\n      const $ = document.getElementById(u);\n      if ($) {\n        d();\n        const _ = lo($);\n        _.length && Xn(w === \"start\" ? _ : _.reverse());\n      }\n    }\n    function f() {\n      const w = document.getElementById(u);\n      if (w) {\n        const $ = lo(w);\n        $.length && (d = ei($));\n      }\n    }\n    ti({\n      value: l,\n      contentId: u,\n      triggerRef: i,\n      focusProxyRef: r,\n      wasEscapeCloseRef: c,\n      onEntryKeyDown: p,\n      onFocusProxyEnter: p,\n      onContentFocusOutside: f,\n      onRootContentClose: f\n    });\n    function m() {\n      var w;\n      s.onItemDismiss(), (w = i.value) == null || w.focus();\n    }\n    function C(w) {\n      const $ = document.activeElement;\n      if (w.keyCode === 32 || w.key === \"Enter\")\n        if (s.modelValue.value === l) {\n          m(), w.preventDefault();\n          return;\n        } else {\n          w.target.click(), w.preventDefault();\n          return;\n        }\n      const _ = n.value.filter(\n        (x) => {\n          var P;\n          return (P = x.parentElement) == null ? void 0 : P.hasAttribute(\"data-menu-item\");\n        }\n      ), E = qe(w, $, void 0, {\n        itemsArray: _,\n        loop: !1\n      });\n      E && (E == null || E.focus()), w.preventDefault(), w.stopPropagation();\n    }\n    return (w, $) => (h(), b(a(D), {\n      \"as-child\": t.asChild,\n      as: w.as,\n      \"data-menu-item\": \"\",\n      onKeydown: le(C, [\"up\", \"down\", \"left\", \"right\", \"home\", \"end\", \"space\"])\n    }, {\n      default: v(() => [\n        y(w.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"onKeydown\"]));\n  }\n}), oi = /* @__PURE__ */ g({\n  __name: \"NavigationMenuContentImpl\",\n  props: {\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { injectCollection: s } = re(\"nav\"), l = s(), { primitiveElement: i, currentElement: r } = V(), u = Te(), d = Go(), c = Yn(u.baseId, d.value), p = qo(u.baseId, d.value), f = B(null), m = S(() => {\n      const P = l.value.map((O) => O.id.split(\"trigger-\")[1]);\n      u.dir.value === \"rtl\" && P.reverse();\n      const I = P.indexOf(u.modelValue.value), A = P.indexOf(u.previousValue.value), L = d.value === u.modelValue.value, M = A === P.indexOf(d.value);\n      if (!L && !M)\n        return f.value;\n      const W = (() => {\n        if (I !== A) {\n          if (L && A !== -1)\n            return I > A ? \"from-end\" : \"from-start\";\n          if (M && I !== -1)\n            return I > A ? \"to-start\" : \"to-end\";\n        }\n        return null;\n      })();\n      return f.value = W, W;\n    });\n    function C(x) {\n      var P, I;\n      if (n(\"focusOutside\", x), n(\"interactOutside\", x), !x.defaultPrevented) {\n        d.onContentFocusOutside();\n        const A = x.target;\n        (I = (P = u.rootNavigationMenu) == null ? void 0 : P.value) != null && I.contains(A) && x.preventDefault();\n      }\n    }\n    function w(x) {\n      var P;\n      if (n(\"pointerDownOutside\", x), !x.defaultPrevented) {\n        const I = x.target, A = l.value.some(\n          (M) => M.contains(I)\n        ), L = u.isRootMenu && ((P = u.viewport.value) == null ? void 0 : P.contains(I));\n        (A || L || !u.isRootMenu) && x.preventDefault();\n      }\n    }\n    ee((x) => {\n      const P = r.value;\n      if (u.isRootMenu && P) {\n        const I = () => {\n          var A;\n          d.onRootContentClose(), P.contains(document.activeElement) && ((A = d.triggerRef.value) == null || A.focus());\n        };\n        P.addEventListener(Bt, I), x(\n          () => P.removeEventListener(Bt, I)\n        );\n      }\n    });\n    function $(x) {\n      var P, I;\n      n(\"escapeKeyDown\", x), x.defaultPrevented || (u.onItemDismiss(), (I = (P = d.triggerRef) == null ? void 0 : P.value) == null || I.focus(), d.wasEscapeCloseRef.value = !0);\n    }\n    function _(x) {\n      var M;\n      const P = x.altKey || x.ctrlKey || x.metaKey, I = x.key === \"Tab\" && !P, A = lo(x.currentTarget);\n      if (I) {\n        const W = document.activeElement, O = A.findIndex(\n          (Z) => Z === W\n        ), j = x.shiftKey ? A.slice(0, O).reverse() : A.slice(O + 1, A.length);\n        if (Xn(j))\n          x.preventDefault();\n        else {\n          (M = d.focusProxyRef.value) == null || M.focus();\n          return;\n        }\n      }\n      const L = qe(\n        x,\n        document.activeElement,\n        void 0,\n        { itemsArray: A, loop: !1 }\n      );\n      L == null || L.focus(), !(x.key === \"Enter\" || x.key === \"Escape\") && (x.preventDefault(), x.stopPropagation());\n    }\n    function E() {\n      var P;\n      const x = new Event(Bt, {\n        bubbles: !0,\n        cancelable: !0\n      });\n      (P = r.value) == null || P.dispatchEvent(x);\n    }\n    return (x, P) => (h(), b(a(Se), T({\n      id: a(p),\n      ref_key: \"primitiveElement\",\n      ref: i,\n      \"aria-labelledby\": a(c),\n      \"data-motion\": m.value,\n      \"data-state\": a(Ft)(a(u).modelValue.value === a(d).value),\n      \"data-orientation\": a(u).orientation\n    }, e, {\n      onKeydown: _,\n      onEscapeKeyDown: $,\n      onPointerDownOutside: w,\n      onFocusOutside: C,\n      onDismiss: E\n    }), {\n      default: v(() => [\n        y(x.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\", \"aria-labelledby\", \"data-motion\", \"data-state\", \"data-orientation\"]));\n  }\n}), Md = /* @__PURE__ */ g({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = ce(n), l = Dt(), i = Te(), r = Go(), u = S(() => r.value === i.modelValue.value), d = S(() => !i.modelValue.value && i.previousValue.value ? i.previousValue.value === r.value : !1);\n    function c(p) {\n      n(\"pointerDownOutside\", p), p.preventDefault || i.onContentLeave();\n    }\n    return (p, f) => a(l) ? (h(), b(Ue, {\n      key: 0,\n      to: a(i).viewport.value,\n      disabled: !a(i).viewport.value\n    }, [\n      k(a(se), {\n        present: p.forceMount || u.value || d.value\n      }, {\n        default: v(() => [\n          k(oi, T({\n            \"data-state\": a(Ft)(u.value),\n            style: {\n              pointerEvents: !u.value && a(i).isRootMenu ? \"none\" : void 0\n            }\n          }, { ...p.$attrs, ...e, ...a(s) }, {\n            onPointerenter: f[0] || (f[0] = (m) => a(i).onContentEnter(a(r).value)),\n            onPointerleave: f[1] || (f[1] = (m) => a(i).onContentLeave()),\n            onPointerdown: c,\n            onFocusOutside: f[2] || (f[2] = (m) => n(\"focusOutside\", m)),\n            onInteractOutside: f[3] || (f[3] = (m) => n(\"interactOutside\", m))\n          }), {\n            default: v(() => [\n              y(p.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16, [\"data-state\", \"style\"])\n        ]),\n        _: 3\n      }, 8, [\"present\"])\n    ], 8, [\"to\", \"disabled\"])) : J(\"\", !0);\n  }\n}), kd = /* @__PURE__ */ g({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { injectCollection: e } = re(\"nav\"), n = e(), s = Te(), l = B(), i = S(() => s.orientation === \"horizontal\"), r = S(() => !!s.modelValue.value), u = B();\n    function d() {\n      u.value && (l.value = {\n        size: i.value ? u.value.offsetWidth : u.value.offsetHeight,\n        offset: i.value ? u.value.offsetLeft : u.value.offsetTop\n      });\n    }\n    return ee(() => {\n      if (!s.modelValue.value) {\n        l.value = void 0;\n        return;\n      }\n      const c = n.value;\n      u.value = c.find(\n        (p) => p.id.includes(s.modelValue.value)\n      ), d();\n    }), _e(u, d), _e(s.indicatorTrack, d), (c, p) => a(s).indicatorTrack.value ? (h(), b(Ue, {\n      key: 0,\n      to: a(s).indicatorTrack.value\n    }, [\n      k(a(se), {\n        present: c.forceMount || r.value\n      }, {\n        default: v(() => {\n          var f, m, C, w;\n          return [\n            k(a(D), T({\n              \"aria-hidden\": \"\",\n              \"data-state\": r.value ? \"visible\" : \"hidden\",\n              \"data-orientation\": a(s).orientation,\n              \"as-child\": t.asChild,\n              as: c.as,\n              style: {\n                position: \"absolute\",\n                ...i.value ? {\n                  left: 0,\n                  width: `${(f = l.value) == null ? void 0 : f.size}px`,\n                  transform: `translateX(${(m = l.value) == null ? void 0 : m.offset}px)`\n                } : {\n                  top: 0,\n                  height: `${(C = l.value) == null ? void 0 : C.size}px`,\n                  transform: `translateY(${(w = l.value) == null ? void 0 : w.offset}px)`\n                }\n              }\n            }, c.$attrs), {\n              default: v(() => [\n                y(c.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"data-state\", \"data-orientation\", \"as-child\", \"as\", \"style\"])\n          ];\n        }),\n        _: 3\n      }, 8, [\"present\"])\n    ], 8, [\"to\"])) : J(\"\", !0);\n  }\n}), Rd = /* @__PURE__ */ g({\n  __name: \"NavigationMenuLink\",\n  props: {\n    active: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"a\" }\n  },\n  emits: [\"select\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t;\n    async function s(l) {\n      var i;\n      if (n(\"select\", l), await G(), !l.defaultPrevented && !l.metaKey) {\n        const r = new CustomEvent(\n          Bt,\n          {\n            bubbles: !0,\n            cancelable: !0\n          }\n        );\n        (i = l.target) == null || i.dispatchEvent(r);\n      }\n    }\n    return (l, i) => (h(), b(a(D), {\n      as: l.as,\n      \"data-active\": l.active ? \"\" : void 0,\n      \"aria-current\": l.active ? \"page\" : void 0,\n      \"as-child\": e.asChild,\n      \"data-radix-vue-collection-item\": \"\",\n      onClick: s\n    }, {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"data-active\", \"aria-current\", \"as-child\"]));\n  }\n}), Vd = /* @__PURE__ */ g({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuList\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"ul\" }\n  },\n  setup(o) {\n    const t = o, e = Te(), { primitiveElement: n, currentElement: s } = V();\n    return U(() => {\n      e.onIndicatorTrackChange(s.value);\n    }), (l, i) => (h(), b(a(D), {\n      ref_key: \"primitiveElement\",\n      ref: n,\n      style: { position: \"relative\" }\n    }, {\n      default: v(() => [\n        k(a(D), T(l.$attrs, {\n          \"as-child\": t.asChild,\n          as: l.as,\n          \"data-orientation\": a(e).orientation\n        }), {\n          default: v(() => [\n            y(l.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as-child\", \"as\", \"data-orientation\"])\n      ]),\n      _: 3\n    }, 512));\n  }\n}), Fd = /* @__PURE__ */ g({\n  __name: \"NavigationMenuSub\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    orientation: { default: \"horizontal\" },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { emit: t }) {\n    const e = o, s = X(e, \"modelValue\", t, {\n      defaultValue: e.defaultValue ?? \"\",\n      passive: e.modelValue === void 0\n    }), l = B(\"\"), i = Te(), { primitiveElement: r, currentElement: u } = V(), d = B(), c = B(), { createCollection: p } = re(\"nav\");\n    return p(d), Gn({\n      ...i,\n      isRootMenu: !1,\n      modelValue: s,\n      previousValue: l,\n      orientation: e.orientation,\n      rootNavigationMenu: u,\n      indicatorTrack: d,\n      onIndicatorTrackChange: (f) => {\n        d.value = f;\n      },\n      viewport: c,\n      onViewportChange: (f) => {\n        c.value = f;\n      },\n      onTriggerEnter: (f) => {\n        s.value = f;\n      },\n      onTriggerLeave: () => {\n      },\n      onContentEnter: () => {\n      },\n      onContentLeave: () => {\n      },\n      onItemSelect: (f) => {\n        s.value = f;\n      },\n      onItemDismiss: () => {\n        s.value = \"\";\n      }\n    }), (f, m) => (h(), b(a(D), {\n      ref_key: \"primitiveElement\",\n      ref: r,\n      \"data-orientation\": f.orientation,\n      \"as-child\": e.asChild,\n      as: f.as\n    }, {\n      default: v(() => [\n        y(f.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"data-orientation\", \"as-child\", \"as\"]));\n  }\n}), ni = [\"aria-owns\"], Ld = /* @__PURE__ */ g({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = Te(), n = Go(), { primitiveElement: s, currentElement: l } = V(), i = B(\"\"), r = B(\"\"), u = ho(!1, 300), d = B(!1), c = S(() => n.value === e.modelValue.value);\n    U(() => {\n      n.triggerRef = l, i.value = Yn(e.baseId, n.value), r.value = qo(e.baseId, n.value);\n    });\n    function p() {\n      d.value = !1, n.wasEscapeCloseRef.value = !1;\n    }\n    function f(E) {\n      if (E.pointerType === \"mouse\") {\n        if (t.disabled || d.value || n.wasEscapeCloseRef.value || u.value)\n          return;\n        e.onTriggerEnter(n.value), u.value = !0;\n      }\n    }\n    function m(E) {\n      if (E.pointerType === \"mouse\") {\n        if (t.disabled)\n          return;\n        e.onTriggerLeave(), u.value = !1;\n      }\n    }\n    function C() {\n      u.value || (c.value ? e.onItemSelect(\"\") : e.onItemSelect(n.value), d.value = c.value);\n    }\n    function w(E) {\n      const P = { horizontal: \"ArrowDown\", vertical: e.dir.value === \"rtl\" ? \"ArrowLeft\" : \"ArrowRight\" }[e.orientation];\n      c.value && E.key === P && (n.onEntryKeyDown(), E.preventDefault(), E.stopPropagation());\n    }\n    function $(E) {\n      n.focusProxyRef.value = ve(E);\n    }\n    function _(E) {\n      const x = document.getElementById(n.contentId), P = E.relatedTarget, I = P === l.value, A = x == null ? void 0 : x.contains(P);\n      (I || !A) && n.onFocusProxyEnter(I ? \"start\" : \"end\");\n    }\n    return (E, x) => (h(), Q(ie, null, [\n      k(a(D), T({\n        id: i.value,\n        ref_key: \"primitiveElement\",\n        ref: s,\n        disabled: E.disabled,\n        \"data-disabled\": E.disabled ? \"\" : void 0,\n        \"data-state\": a(Ft)(c.value),\n        \"aria-expanded\": c.value,\n        \"aria-controls\": r.value,\n        \"as-child\": t.asChild,\n        as: E.as\n      }, E.$attrs, {\n        \"data-radix-vue-collection-item\": \"\",\n        onPointerenter: p,\n        onPointermove: f,\n        onPointerleave: m,\n        onClick: C,\n        onKeydown: w\n      }), {\n        default: v(() => [\n          y(E.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\", \"disabled\", \"data-disabled\", \"data-state\", \"aria-expanded\", \"aria-controls\", \"as-child\", \"as\"]),\n      c.value ? (h(), Q(ie, { key: 0 }, [\n        k(a(Xe), {\n          ref: $,\n          \"aria-hidden\": \"\",\n          tabindex: 0,\n          onFocus: _\n        }),\n        a(e).viewport ? (h(), Q(\"span\", {\n          key: 0,\n          \"aria-owns\": r.value\n        }, null, 8, ni)) : J(\"\", !0)\n      ], 64)) : J(\"\", !0)\n    ], 64));\n  }\n}), Kd = /* @__PURE__ */ g({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuViewport\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const { primitiveElement: t, currentElement: e } = V(), n = Te(), s = B(), l = S(() => !!n.modelValue.value), i = S(() => n.modelValue.value);\n    Y(e, () => {\n      e.value && n.onViewportChange(e.value);\n    });\n    const r = B();\n    return Y([i, l], async () => {\n      var d, c;\n      if (await G(), !e.value)\n        return;\n      const u = (c = (d = e.value.querySelector(\"[data-state=open]\")) == null ? void 0 : d.children) == null ? void 0 : c[0];\n      r.value = u;\n    }, { immediate: !0 }), _e(r, () => {\n      r.value && (s.value = {\n        width: r.value.offsetWidth,\n        height: r.value.offsetHeight\n      });\n    }), (u, d) => (h(), b(a(se), {\n      present: u.forceMount || l.value\n    }, {\n      default: v(() => {\n        var c, p;\n        return [\n          k(a(D), T(u.$attrs, {\n            ref_key: \"primitiveElement\",\n            ref: t,\n            as: u.as,\n            \"as-child\": u.asChild,\n            \"data-state\": a(Ft)(l.value),\n            \"data-orientation\": a(n).orientation,\n            style: {\n              // Prevent interaction when animating out\n              pointerEvents: !l.value && a(n).isRootMenu ? \"none\" : void 0,\n              \"--radix-navigation-menu-viewport-width\": s.value ? `${(c = s.value) == null ? void 0 : c.width}px` : void 0,\n              \"--radix-navigation-menu-viewport-height\": s.value ? `${(p = s.value) == null ? void 0 : p.height}px` : void 0\n            },\n            onPointerenter: d[0] || (d[0] = (f) => a(n).onContentEnter(a(n).modelValue.value)),\n            onPointerleave: d[1] || (d[1] = (f) => a(n).onContentLeave())\n          }), {\n            default: v(() => [\n              y(u.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16, [\"as\", \"as-child\", \"data-state\", \"data-orientation\", \"style\"])\n        ];\n      }),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), [Qe, ai] = H(\"PaginationRoot\"), Nd = /* @__PURE__ */ g({\n  __name: \"PaginationRoot\",\n  props: {\n    page: {},\n    defaultPage: { default: 1 },\n    itemsPerPage: { default: 10 },\n    total: { default: 0 },\n    siblingCount: { default: 2 },\n    disabled: { type: Boolean },\n    showEdges: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"nav\" }\n  },\n  emits: [\"update:page\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { siblingCount: s, disabled: l, showEdges: i } = z(e), r = X(e, \"page\", n, {\n      defaultValue: e.defaultPage,\n      passive: e.page === void 0\n    }), u = S(() => Math.ceil(e.total / e.itemsPerPage));\n    return ai({\n      page: r,\n      onPageChange(d) {\n        r.value = d;\n      },\n      pageCount: u,\n      siblingCount: s,\n      disabled: l,\n      showEdges: i\n    }), (d, c) => (h(), b(a(D), {\n      as: d.as,\n      \"as-child\": d.asChild\n    }, {\n      default: v(() => [\n        y(d.$slots, \"default\", { page: a(r) })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), Hd = /* @__PURE__ */ g({\n  __name: \"PaginationEllipsis\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(D), T({ \"data-type\": \"ellipsis\" }, t), {\n      default: v(() => [\n        y(e.$slots, \"default\", {}, () => [\n          ue(\"â€¦\")\n        ])\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Wd = /* @__PURE__ */ g({\n  __name: \"PaginationFirst\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = Qe();\n    return (n, s) => (h(), b(a(D), T(t, {\n      \"aria-label\": \"First Page\",\n      type: n.as === \"button\" ? \"button\" : void 0,\n      disabled: a(e).page.value === 1 || a(e).disabled.value,\n      onClick: s[0] || (s[0] = (l) => a(e).onPageChange(1))\n    }), {\n      default: v(() => [\n        y(n.$slots, \"default\", {}, () => [\n          ue(\"First page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"disabled\"]));\n  }\n}), jd = /* @__PURE__ */ g({\n  __name: \"PaginationLast\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = Qe();\n    return (n, s) => (h(), b(a(D), T(t, {\n      \"aria-label\": \"Last Page\",\n      type: n.as === \"button\" ? \"button\" : void 0,\n      disabled: a(e).page.value === a(e).pageCount.value || a(e).disabled.value,\n      onClick: s[0] || (s[0] = (l) => a(e).onPageChange(a(e).pageCount.value))\n    }), {\n      default: v(() => [\n        y(n.$slots, \"default\", {}, () => [\n          ue(\"Last page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"disabled\"]));\n  }\n});\nfunction ke(o, t) {\n  const e = t - o + 1;\n  return Array.from({ length: e }, (n, s) => s + o);\n}\nfunction si(o) {\n  return o.map((t) => typeof t == \"number\" ? { type: \"page\", value: t } : { type: \"ellipsis\" });\n}\nconst wt = \"ellipsis\";\nfunction li(o, t, e, n) {\n  const l = t, i = Math.max(o - e, 1), r = Math.min(o + e, l), u = i > 1 + 1, d = r < l - 1;\n  if (n) {\n    const p = Math.min(2 * e + 5, t) - 2;\n    if (!u && d)\n      return [...ke(1, p), wt, l];\n    if (u && !d) {\n      const m = ke(l - p + 1, l);\n      return [1, wt, ...m];\n    }\n    if (u && d) {\n      const m = ke(i, r);\n      return [1, wt, ...m, wt, l];\n    }\n    return ke(1, l);\n  } else {\n    const c = e * 2 + 1;\n    return o <= e + 1 ? ke(1, c) : t - o <= e ? ke(t - c + 1, l) : ke(i, r);\n  }\n}\nconst zd = /* @__PURE__ */ g({\n  __name: \"PaginationList\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = Qe(), n = S(() => si(\n      li(\n        e.page.value,\n        e.pageCount.value,\n        e.siblingCount.value,\n        e.showEdges.value\n      )\n    ));\n    return (s, l) => (h(), b(a(D), R(N(t)), {\n      default: v(() => [\n        y(s.$slots, \"default\", { items: n.value })\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ud = /* @__PURE__ */ g({\n  __name: \"PaginationListItem\",\n  props: {\n    value: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = Qe(), n = S(() => e.page.value === t.value);\n    return (s, l) => (h(), b(a(D), T(t, {\n      \"data-type\": \"page\",\n      \"aria-label\": `Page ${s.value}`,\n      \"aria-current\": n.value ? \"page\" : void 0,\n      \"data-selected\": n.value ? \"true\" : void 0,\n      disabled: a(e).disabled.value,\n      type: s.as === \"button\" ? \"button\" : void 0,\n      onClick: l[0] || (l[0] = (i) => a(e).onPageChange(s.value))\n    }), {\n      default: v(() => [\n        y(s.$slots, \"default\", {}, () => [\n          ue(Le(s.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"aria-label\", \"aria-current\", \"data-selected\", \"disabled\", \"type\"]));\n  }\n}), qd = /* @__PURE__ */ g({\n  __name: \"PaginationNext\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = Qe();\n    return (n, s) => (h(), b(a(D), T(t, {\n      \"aria-label\": \"Next Page\",\n      type: n.as === \"button\" ? \"button\" : void 0,\n      disabled: a(e).page.value === a(e).pageCount.value || a(e).disabled.value,\n      onClick: s[0] || (s[0] = (l) => a(e).onPageChange(a(e).page.value + 1))\n    }), {\n      default: v(() => [\n        y(n.$slots, \"default\", {}, () => [\n          ue(\"Next page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"disabled\"]));\n  }\n}), Gd = /* @__PURE__ */ g({\n  __name: \"PaginationPrev\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = Qe();\n    return (n, s) => {\n      var l;\n      return h(), b(a(D), T(t, {\n        \"aria-label\": \"Previous Page\",\n        type: n.as === \"button\" ? \"button\" : void 0,\n        disabled: a(e).page.value === 1 || ((l = a(e).disabled) == null ? void 0 : l.value),\n        onClick: s[0] || (s[0] = (i) => a(e).onPageChange(a(e).page.value - 1))\n      }), {\n        default: v(() => [\n          y(n.$slots, \"default\", {}, () => [\n            ue(\"Prev page\")\n          ])\n        ]),\n        _: 3\n      }, 16, [\"type\", \"disabled\"]);\n    };\n  }\n}), ii = [\"id\", \"value\", \"name\", \"disabled\", \"required\"], [ri, ui] = H(\"PinInputRoot\"), Yd = /* @__PURE__ */ g({\n  inheritAttrs: !1,\n  __name: \"PinInputRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    placeholder: { default: \"\" },\n    mask: { type: Boolean },\n    otp: { type: Boolean },\n    type: { default: \"text\" },\n    dir: {},\n    name: {},\n    disabled: { type: Boolean },\n    required: { type: Boolean },\n    id: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"complete\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { mask: s, otp: l, placeholder: i, type: r, disabled: u, dir: d } = z(e), c = de(d), p = X(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue ?? [],\n      passive: e.modelValue === void 0\n    }), f = B(/* @__PURE__ */ new Set());\n    function m(w) {\n      f.value.add(w);\n    }\n    const C = S(() => p.value.filter(($) => !!$).length === f.value.size);\n    return Y(p, () => {\n      C.value && n(\"complete\", p.value);\n    }, { deep: !0 }), ui({\n      modelValue: p,\n      mask: s,\n      otp: l,\n      placeholder: i,\n      type: r,\n      dir: c,\n      disabled: u,\n      isCompleted: C,\n      inputElements: f,\n      onInputElementChange: m\n    }), (w, $) => (h(), Q(ie, null, [\n      k(a(D), T(w.$attrs, {\n        dir: a(c),\n        \"data-complete\": C.value ? \"\" : void 0,\n        \"data-disabled\": a(u) ? \"\" : void 0\n      }), {\n        default: v(() => [\n          y(w.$slots, \"default\", { modelValue: a(p) })\n        ]),\n        _: 3\n      }, 16, [\"dir\", \"data-complete\", \"data-disabled\"]),\n      rt(\"input\", {\n        id: w.id,\n        type: \"text\",\n        tabindex: \"-1\",\n        \"aria-hidden\": \"\",\n        value: a(p).join(\"\"),\n        name: w.name,\n        disabled: a(u),\n        required: w.required,\n        style: ae({\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        }),\n        onFocus: $[0] || ($[0] = (_) => {\n          var E, x;\n          return (x = (E = Array.from(f.value)) == null ? void 0 : E[0]) == null ? void 0 : x.focus();\n        })\n      }, null, 44, ii)\n    ], 64));\n  }\n}), di = [\"autocomplete\", \"type\", \"inputmode\", \"pattern\", \"placeholder\", \"value\", \"disabled\", \"data-disabled\", \"data-complete\", \"aria-label\", \"onKeydown\"], Xd = /* @__PURE__ */ g({\n  __name: \"PinInputInput\",\n  props: {\n    index: {},\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(o) {\n    const t = o, e = ri(), n = S(() => Array.from(e.inputElements.value)), s = S(() => t.disabled || e.disabled.value), l = S(() => e.otp.value), i = S(() => e.type.value === \"number\"), r = S(() => e.mask.value), u = B();\n    function d($) {\n      const _ = $.target;\n      if (i.value && !/^[0-9]*$/.test(_.value)) {\n        _.value = _.value.replace(/\\D/g, \"\");\n        return;\n      }\n      _.value = _.value.slice(-1), e.modelValue.value[t.index] = _.value;\n      const E = n.value[t.index + 1];\n      E && E.focus();\n    }\n    function c($) {\n      qe($, document.activeElement, void 0, {\n        itemsArray: n.value,\n        focus: !0,\n        loop: !1,\n        arrowKeyOptions: \"horizontal\",\n        dir: e.dir.value\n      });\n    }\n    function p($) {\n      if ($.preventDefault(), $.target.value)\n        e.modelValue.value[t.index] = \"\";\n      else {\n        const x = n.value[t.index - 1];\n        x && (x.focus(), e.modelValue.value[t.index - 1] = \"\");\n      }\n    }\n    function f($) {\n      $.preventDefault(), e.modelValue.value[t.index] = \"\";\n    }\n    function m($) {\n      const _ = $.target;\n      _.setSelectionRange(1, 1), _.value || (_.placeholder = \"\");\n    }\n    function C($) {\n      const _ = $.target;\n      G(() => {\n        _.value || (_.placeholder = e.placeholder.value);\n      });\n    }\n    function w($) {\n      var I;\n      $.preventDefault();\n      const _ = $.clipboardData;\n      if (!_)\n        return;\n      const E = _.getData(\"text\"), x = E.length >= n.value.length ? 0 : t.index, P = Math.min(x + E.length, n.value.length);\n      for (let A = x; A < P; A++) {\n        const L = n.value[A], M = E[A - x];\n        i.value && !/^[0-9]*$/.test(M) || (L.value = M, e.modelValue.value[A] = M, L.focus());\n      }\n      (I = n.value[P]) == null || I.focus();\n    }\n    return U(() => {\n      e.onInputElementChange(u.value);\n    }), fe(() => {\n      var $;\n      ($ = e.inputElements) == null || $.value.delete(u.value);\n    }), ($, _) => (h(), Q(\"input\", {\n      ref_key: \"inputRef\",\n      ref: u,\n      autocapitalize: \"none\",\n      autocomplete: l.value ? \"one-time-code\" : \"false\",\n      type: r.value ? \"password\" : \"text\",\n      inputmode: i.value ? \"numeric\" : \"text\",\n      pattern: i.value ? \"[0-9]*\" : void 0,\n      placeholder: a(e).placeholder.value,\n      value: a(e).modelValue.value.at($.index),\n      disabled: s.value,\n      \"data-disabled\": s.value ? \"\" : void 0,\n      \"data-complete\": a(e).isCompleted.value ? \"\" : void 0,\n      \"aria-label\": `pin input ${$.index + 1} of ${n.value.length}`,\n      onInput: d,\n      onKeydown: [\n        le(c, [\"left\", \"right\", \"up\", \"down\", \"home\", \"end\"]),\n        le(p, [\"backspace\"]),\n        le(f, [\"delete\"])\n      ],\n      onFocus: m,\n      onBlur: C,\n      onPaste: w\n    }, null, 40, di));\n  }\n}), [je, ci] = H(\"PopoverRoot\"), Jd = /* @__PURE__ */ g({\n  __name: \"PopoverRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    modal: { type: Boolean, default: !1 }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { modal: s } = z(e), l = X(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), i = B(), r = B(!1);\n    return ci({\n      contentId: te(),\n      modal: s,\n      open: l,\n      onOpenChange: (u) => {\n        l.value = u;\n      },\n      onOpenToggle: () => {\n        l.value = !l.value;\n      },\n      triggerElement: i,\n      hasCustomAnchor: r\n    }), (u, d) => (h(), b(a(Ne), null, {\n      default: v(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), Zd = /* @__PURE__ */ g({\n  __name: \"PopoverTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o, { expose: t }) {\n    const e = o, n = je(), { primitiveElement: s, currentElement: l } = V();\n    return U(() => {\n      n.triggerElement.value = l.value;\n    }), t({ $el: l }), (i, r) => (h(), b($e(a(n).hasCustomAnchor.value ? a(D) : a(He)), { \"as-child\": \"\" }, {\n      default: v(() => [\n        k(a(D), {\n          ref_key: \"primitiveElement\",\n          ref: s,\n          type: i.as === \"button\" ? \"button\" : void 0,\n          \"aria-haspopup\": \"dialog\",\n          \"aria-expanded\": a(n).open.value,\n          \"aria-controls\": a(n).contentId,\n          \"data-state\": a(n).open.value ? \"open\" : \"closed\",\n          as: i.as,\n          \"as-child\": e.asChild,\n          onClick: a(n).onOpenToggle\n        }, {\n          default: v(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"type\", \"aria-expanded\", \"aria-controls\", \"data-state\", \"as\", \"as-child\", \"onClick\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Qd = /* @__PURE__ */ g({\n  __name: \"PopoverPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Pe), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Jn = /* @__PURE__ */ g({\n  __name: \"PopoverContentImpl\",\n  props: {\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    onPlaced: { type: Function },\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = It(e), l = je();\n    return Co(), (i, r) => (h(), b(a(Mt), {\n      \"as-child\": \"\",\n      loop: \"\",\n      trapped: i.trapFocus,\n      onMountAutoFocus: r[5] || (r[5] = (u) => n(\"openAutoFocus\", u)),\n      onUnmountAutoFocus: r[6] || (r[6] = (u) => n(\"closeAutoFocus\", u))\n    }, {\n      default: v(() => [\n        k(a(Se), {\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": i.disableOutsidePointerEvents,\n          onPointerDownOutside: r[0] || (r[0] = (u) => n(\"pointerDownOutside\", u)),\n          onInteractOutside: r[1] || (r[1] = (u) => n(\"interactOutside\", u)),\n          onEscapeKeyDown: r[2] || (r[2] = (u) => n(\"escapeKeyDown\", u)),\n          onFocusOutside: r[3] || (r[3] = (u) => n(\"focusOutside\", u)),\n          onDismiss: r[4] || (r[4] = (u) => a(l).onOpenChange(!1))\n        }, {\n          default: v(() => [\n            k(a(Ge), T(a(s), {\n              id: a(l).contentId,\n              \"data-state\": a(l).open.value ? \"open\" : \"closed\",\n              role: \"dialog\",\n              style: {\n                \"--radix-popover-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n                \"--radix-popover-content-available-width\": \"var(--radix-popper-available-width)\",\n                \"--radix-popover-content-available-height\": \"var(--radix-popper-available-height)\",\n                \"--radix-popover-trigger-width\": \"var(--radix-popper-anchor-width)\",\n                \"--radix-popover-trigger-height\": \"var(--radix-popper-anchor-height)\"\n              }\n            }), {\n              default: v(() => [\n                y(i.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"id\", \"data-state\", \"style\"])\n          ]),\n          _: 3\n        }, 8, [\"disable-outside-pointer-events\"])\n      ]),\n      _: 3\n    }, 8, [\"trapped\"]));\n  }\n}), pi = /* @__PURE__ */ g({\n  __name: \"PopoverContentModal\",\n  props: {\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    onPlaced: { type: Function },\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = je(), l = B(!1);\n    pt(!0);\n    const i = pe(e, n), { primitiveElement: r, currentElement: u } = V();\n    return ft(u), (d, c) => (h(), b(Jn, T({\n      ref_key: \"primitiveElement\",\n      ref: r\n    }, a(i), {\n      \"trap-focus\": a(s).open.value,\n      \"disable-outside-pointer-events\": \"\",\n      onCloseAutoFocus: c[0] || (c[0] = ne(\n        (p) => {\n          var f;\n          n(\"closeAutoFocus\", p), l.value || (f = a(s).triggerElement.value) == null || f.focus();\n        },\n        [\"prevent\"]\n      )),\n      onPointerDownOutside: c[1] || (c[1] = (p) => {\n        n(\"pointerDownOutside\", p);\n        const f = p.detail.originalEvent, m = f.button === 0 && f.ctrlKey === !0, C = f.button === 2 || m;\n        l.value = C;\n      }),\n      onFocusOutside: c[2] || (c[2] = ne(() => {\n      }, [\"prevent\"]))\n    }), {\n      default: v(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"trap-focus\"]));\n  }\n}), fi = /* @__PURE__ */ g({\n  __name: \"PopoverContentNonModal\",\n  props: {\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    onPlaced: { type: Function },\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = je(), l = B(!1), i = B(!1), r = pe(e, n);\n    return (u, d) => (h(), b(Jn, T(a(r), {\n      \"trap-focus\": !1,\n      \"disable-outside-pointer-events\": !1,\n      onCloseAutoFocus: d[0] || (d[0] = (c) => {\n        var p;\n        n(\"closeAutoFocus\", c), c.defaultPrevented || (l.value || (p = a(s).triggerElement.value) == null || p.focus(), c.preventDefault()), l.value = !1, i.value = !1;\n      }),\n      onInteractOutside: d[1] || (d[1] = async (c) => {\n        var m;\n        n(\"interactOutside\", c), c.defaultPrevented || (l.value = !0, c.detail.originalEvent.type === \"pointerdown\" && (i.value = !0));\n        const p = c.target;\n        ((m = a(s).triggerElement.value) == null ? void 0 : m.contains(p)) && c.preventDefault(), c.detail.originalEvent.type === \"focusin\" && i.value && c.preventDefault();\n      })\n    }), {\n      default: v(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ec = /* @__PURE__ */ g({\n  __name: \"PopoverContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    onPlaced: { type: Function },\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = je(), l = pe(e, n);\n    return (i, r) => (h(), b(a(se), {\n      present: i.forceMount || a(s).open.value\n    }, {\n      default: v(() => [\n        a(s).modal.value ? (h(), b(pi, R(T({ key: 0 }, a(l))), {\n          default: v(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)) : (h(), b(fi, R(T({ key: 1 }, a(l))), {\n          default: v(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16))\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), tc = /* @__PURE__ */ g({\n  __name: \"PopoverArrow\",\n  props: {\n    width: {},\n    height: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Ye), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), oc = /* @__PURE__ */ g({\n  __name: \"PopoverClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = je();\n    return (n, s) => (h(), b(a(D), {\n      type: n.as === \"button\" ? \"button\" : void 0,\n      as: n.as,\n      \"as-child\": t.asChild,\n      onClick: s[0] || (s[0] = (l) => a(e).onOpenChange(!1))\n    }, {\n      default: v(() => [\n        y(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"type\", \"as\", \"as-child\"]));\n  }\n}), nc = /* @__PURE__ */ g({\n  __name: \"PopoverAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = je();\n    return bn(() => {\n      e.hasCustomAnchor.value = !0;\n    }), fe(() => {\n      e.hasCustomAnchor.value = !1;\n    }), (n, s) => (h(), b(a(He), R(N(t)), {\n      default: v(() => [\n        y(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), lt = 100, [vi, mi] = H(\"ProgressRoot\"), Yo = (o) => typeof o == \"number\";\nfunction hi(o, t) {\n  return o === null || Yo(o) && !Number.isNaN(o) && o <= t && o >= 0 ? o : (console.error(`Invalid prop \\`value\\` of value \\`${o}\\` supplied to \\`ProgressRoot\\`. The \\`value\\` prop must be:\n  - a positive number\n  - less than the value passed to \\`max\\` (or ${lt} if no \\`max\\` prop is set)\n  - \\`null\\` if the progress is indeterminate.\n\nDefaulting to \\`null\\`.`), null);\n}\nfunction yi(o) {\n  return Yo(o) && !Number.isNaN(o) && o > 0 ? o : (console.error(\n    `Invalid prop \\`max\\` of value \\`${o}\\` supplied to \\`ProgressRoot\\`. Only numbers greater than 0 are valid max values. Defaulting to \\`${lt}\\`.`\n  ), lt);\n}\nconst ac = /* @__PURE__ */ g({\n  __name: \"ProgressRoot\",\n  props: {\n    modelValue: {},\n    max: { default: lt },\n    getValueLabel: { type: Function, default: (o, t) => `${Math.round(o / t * lt)}%` },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"update:max\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = X(e, \"modelValue\", n, {\n      passive: e.modelValue === void 0\n    }), l = X(e, \"max\", n, {\n      passive: e.max === void 0\n    });\n    Y(\n      () => s.value,\n      async (r) => {\n        const u = hi(r, e.max);\n        u !== r && (await G(), s.value = u);\n      },\n      { immediate: !0 }\n    ), Y(\n      () => e.max,\n      (r) => {\n        const u = yi(e.max);\n        u !== r && (l.value = u);\n      },\n      { immediate: !0 }\n    );\n    const i = S(() => s.value ? s.value === l.value ? \"complete\" : \"loading\" : \"indeterminate\");\n    return mi({\n      modelValue: s,\n      max: l,\n      progressState: i\n    }), (r, u) => (h(), b(a(D), {\n      \"as-child\": e.asChild,\n      as: r.as,\n      \"aria-valuemax\": a(l),\n      \"aria-valuemin\": 0,\n      \"aria-valuenow\": Yo(a(s)) ? a(s) : void 0,\n      \"aria-valuetext\": r.getValueLabel(a(s), a(l)),\n      \"aria-label\": r.getValueLabel(a(s), a(l)),\n      role: \"progressbar\",\n      \"data-state\": i.value,\n      \"data-value\": a(s) ?? void 0,\n      \"data-max\": a(l)\n    }, {\n      default: v(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"aria-valuemax\", \"aria-valuenow\", \"aria-valuetext\", \"aria-label\", \"data-state\", \"data-value\", \"data-max\"]));\n  }\n}), sc = /* @__PURE__ */ g({\n  __name: \"ProgressIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = vi();\n    return (n, s) => {\n      var l;\n      return h(), b(a(D), T(t, {\n        \"data-state\": a(e).progressState.value,\n        \"data-value\": ((l = a(e).modelValue) == null ? void 0 : l.value) ?? void 0,\n        \"data-max\": a(e).max.value\n      }), {\n        default: v(() => [\n          y(n.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"data-state\", \"data-value\", \"data-max\"]);\n    };\n  }\n}), [gi, bi] = H(\"RadioGroupRoot\"), lc = /* @__PURE__ */ g({\n  __name: \"RadioGroupRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    disabled: { type: Boolean, default: !1 },\n    name: {},\n    required: { type: Boolean, default: !1 },\n    orientation: { default: void 0 },\n    dir: {},\n    loop: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { emit: t }) {\n    const e = o, s = X(e, \"modelValue\", t, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), { disabled: l, loop: i, orientation: r, name: u, required: d, dir: c } = z(e), p = de(c);\n    return bi({\n      modelValue: s,\n      changeModelValue: (f) => {\n        s.value = f;\n      },\n      disabled: l,\n      loop: i,\n      orientation: r,\n      name: u == null ? void 0 : u.value,\n      required: d\n    }), (f, m) => (h(), b(a(Je), {\n      \"as-child\": \"\",\n      orientation: a(r),\n      dir: a(p),\n      loop: a(i)\n    }, {\n      default: v(() => [\n        k(a(D), {\n          role: \"radiogroup\",\n          \"data-disabled\": a(l) ? \"\" : void 0,\n          \"as-child\": f.asChild,\n          as: f.as,\n          required: a(d),\n          \"aria-orientation\": a(r),\n          \"aria-required\": a(d),\n          dir: a(p),\n          name: a(u)\n        }, {\n          default: v(() => [\n            y(f.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"data-disabled\", \"as-child\", \"as\", \"required\", \"aria-orientation\", \"aria-required\", \"dir\", \"name\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n}), Ci = [\"value\", \"checked\", \"name\", \"disabled\", \"required\"], _i = /* @__PURE__ */ g({\n  __name: \"Radio\",\n  props: {\n    id: {},\n    value: {},\n    disabled: { type: Boolean, default: !1 },\n    required: { type: Boolean },\n    checked: { type: Boolean, default: void 0 },\n    name: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:checked\"],\n  setup(o, { emit: t }) {\n    const e = o, s = X(e, \"checked\", t, {\n      passive: e.checked === void 0\n    }), { value: l } = z(e), { primitiveElement: i, currentElement: r } = V(), u = Ke(r), d = S(() => {\n      var p;\n      return e.id && r.value ? ((p = document.querySelector(`[for=\"${e.id}\"]`)) == null ? void 0 : p.innerText) ?? e.value : void 0;\n    });\n    function c(p) {\n      s.value = !0, u.value && p.stopPropagation();\n    }\n    return (p, f) => (h(), b(a(D), T(p.$attrs, {\n      id: p.id,\n      ref_key: \"primitiveElement\",\n      ref: i,\n      role: \"radio\",\n      type: p.as === \"button\" ? \"button\" : void 0,\n      as: p.as,\n      \"aria-checked\": a(s),\n      \"aria-label\": d.value,\n      \"as-child\": p.asChild,\n      disabled: p.disabled ? !0 : void 0,\n      \"data-state\": a(s) ? \"checked\" : \"unchecked\",\n      \"data-disabled\": p.disabled ? \"\" : void 0,\n      value: a(l),\n      required: p.required,\n      name: p.name,\n      onClick: ne(c, [\"stop\"])\n    }), {\n      default: v(() => [\n        y(p.$slots, \"default\"),\n        a(u) ? (h(), Q(\"input\", {\n          key: 0,\n          type: \"radio\",\n          tabindex: \"-1\",\n          \"aria-hidden\": \"\",\n          value: a(l),\n          checked: !!a(s),\n          name: p.name,\n          disabled: p.disabled,\n          required: p.required,\n          style: ae({\n            transform: \"translateX(-100%)\",\n            position: \"absolute\",\n            pointerEvents: \"none\",\n            opacity: 0,\n            margin: 0\n          })\n        }, null, 12, Ci)) : J(\"\", !0)\n      ]),\n      _: 3\n    }, 16, [\"id\", \"type\", \"as\", \"aria-checked\", \"aria-label\", \"as-child\", \"disabled\", \"data-state\", \"data-disabled\", \"value\", \"required\", \"name\", \"onClick\"]));\n  }\n}), [wi, Ei] = H(\"RadioGroupItem\"), ic = /* @__PURE__ */ g({\n  inheritAttrs: !1,\n  __name: \"RadioGroupItem\",\n  props: {\n    id: {},\n    value: {},\n    disabled: { type: Boolean, default: !1 },\n    required: { type: Boolean },\n    name: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, { primitiveElement: e, currentElement: n } = V(), s = gi(), l = S(() => s.disabled.value || t.disabled), i = S(() => s.required.value || t.required), r = S(() => {\n      var p;\n      return ((p = s.modelValue) == null ? void 0 : p.value) === t.value;\n    });\n    Ei({ disabled: l, checked: r });\n    const u = B(!1), d = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"];\n    Ve(\"keydown\", (p) => {\n      d.includes(p.key) && (u.value = !0);\n    }), Ve(\"keyup\", () => {\n      u.value = !1;\n    });\n    function c() {\n      setTimeout(() => {\n        var p;\n        u.value && ((p = n.value) == null || p.click());\n      }, 0);\n    }\n    return (p, f) => (h(), b(a(Ze), {\n      checked: r.value,\n      disabled: l.value,\n      \"as-child\": \"\",\n      focusable: !l.value,\n      active: r.value\n    }, {\n      default: v(() => [\n        k(_i, T({\n          ref_key: \"primitiveElement\",\n          ref: e\n        }, { ...p.$attrs, ...t }, {\n          checked: r.value,\n          required: i.value,\n          \"onUpdate:checked\": f[0] || (f[0] = (m) => a(s).changeModelValue(p.value)),\n          onKeydown: f[1] || (f[1] = le(ne(() => {\n          }, [\"prevent\"]), [\"enter\"])),\n          onFocus: c\n        }), {\n          default: v(() => [\n            y(p.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"checked\", \"required\"])\n      ]),\n      _: 3\n    }, 8, [\"checked\", \"disabled\", \"focusable\", \"active\"]));\n  }\n}), rc = /* @__PURE__ */ g({\n  __name: \"RadioGroupIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = wi();\n    return (e, n) => a(t).checked.value ? (h(), b(a(D), {\n      key: 0,\n      \"data-state\": a(t).checked.value ? \"checked\" : \"unchecked\",\n      \"data-disabled\": a(t).disabled.value ? \"\" : void 0,\n      \"as-child\": e.asChild,\n      as: e.as\n    }, {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"data-state\", \"data-disabled\", \"as-child\", \"as\"])) : J(\"\", !0);\n  }\n}), [me, xi] = H(\"ScrollAreaRoot\"), uc = /* @__PURE__ */ g({\n  __name: \"ScrollAreaRoot\",\n  props: {\n    type: { default: \"hover\" },\n    dir: {},\n    scrollHideDelay: { default: 600 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { primitiveElement: e, currentElement: n } = V(), s = B(0), l = B(0), i = B(), r = B(), u = B(), d = B(), c = B(!1), p = B(!1), { type: f, dir: m, scrollHideDelay: C } = z(t), w = de(m);\n    return xi({\n      type: f,\n      dir: w,\n      scrollHideDelay: C,\n      scrollArea: n,\n      viewport: i,\n      onViewportChange: ($) => {\n        i.value = $ || void 0;\n      },\n      content: r,\n      onContentChange: ($) => {\n        r.value = $;\n      },\n      scrollbarX: u,\n      scrollbarXEnabled: c,\n      scrollbarY: d,\n      scrollbarYEnabled: p,\n      onScrollbarXChange: ($) => {\n        u.value = $ || void 0;\n      },\n      onScrollbarYChange: ($) => {\n        d.value = $ || void 0;\n      },\n      onScrollbarXEnabledChange: ($) => {\n        c.value = $;\n      },\n      onScrollbarYEnabledChange: ($) => {\n        p.value = $;\n      },\n      onCornerWidthChange: ($) => {\n        s.value = $;\n      },\n      onCornerHeightChange: ($) => {\n        l.value = $;\n      }\n    }), ($, _) => (h(), b(a(D), {\n      ref_key: \"primitiveElement\",\n      ref: e,\n      \"as-child\": t.asChild,\n      as: $.as,\n      dir: a(w),\n      style: ae({\n        position: \"relative\",\n        // Pass corner sizes as CSS vars to reduce re-renders of context consumers\n        \"--radix-scroll-area-corner-width\": `${s.value}px`,\n        \"--radix-scroll-area-corner-height\": `${l.value}px`\n      })\n    }, {\n      default: v(() => [\n        y($.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"dir\", \"style\"]));\n  }\n}), dc = /* @__PURE__ */ g({\n  inheritAttrs: !1,\n  __name: \"ScrollAreaViewport\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = me(), { primitiveElement: n, currentElement: s } = V(), l = B();\n    return U(() => {\n      e.onViewportChange(l.value), e.onContentChange(s.value);\n    }), (i, r) => (h(), Q(ie, null, [\n      k(a(D), { as: \"style\" }, {\n        default: v(() => [\n          ue(\" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-scroll-area-viewport] { scrollbar-width:none; -ms-overflow-style:none; -webkit-overflow-scrolling:touch; } [data-radix-scroll-area-viewport]::-webkit-scrollbar { display:none; } \")\n        ]),\n        _: 1\n      }),\n      rt(\"div\", T({\n        ref_key: \"viewportElement\",\n        ref: l,\n        \"data-radix-scroll-area-viewport\": \"\",\n        style: {\n          /**\n           * We don't support `visible` because the intention is to have at least one scrollbar\n           * if this component is used and `visible` will behave like `auto` in that case\n           * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description\n           *\n           * We don't handle `auto` because the intention is for the native implementation\n           * to be hidden if using this component. We just want to ensure the node is scrollable\n           * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent\n           * the browser from having to work out whether to render native scrollbars or not,\n           * we tell it to with the intention of hiding them in CSS.\n           */\n          overflowX: a(e).scrollbarXEnabled.value ? \"scroll\" : \"hidden\",\n          overflowY: a(e).scrollbarYEnabled.value ? \"scroll\" : \"hidden\"\n        }\n      }, i.$attrs, { tabindex: 0 }), [\n        k(a(D), {\n          ref_key: \"primitiveElement\",\n          ref: n,\n          style: { minWidth: \"100%\", display: \"table\" },\n          \"as-child\": t.asChild,\n          as: i.as\n        }, {\n          default: v(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as-child\", \"as\"])\n      ], 16)\n    ], 64));\n  }\n});\nfunction $i(o, [t, e]) {\n  return Math.min(e, Math.max(t, o));\n}\nfunction Zn(o, t) {\n  return (e) => {\n    if (o[0] === o[1] || t[0] === t[1])\n      return t[0];\n    const n = (t[1] - t[0]) / (o[1] - o[0]);\n    return t[0] + n * (e - o[0]);\n  };\n}\nfunction Lt(o) {\n  const t = Qn(o.viewport, o.content), e = o.scrollbar.paddingStart + o.scrollbar.paddingEnd, n = (o.scrollbar.size - e) * t;\n  return Math.max(n, 18);\n}\nfunction Qn(o, t) {\n  const e = o / t;\n  return Number.isNaN(e) ? 0 : e;\n}\nfunction Bi(o, t = () => {\n}) {\n  let e = { left: o.scrollLeft, top: o.scrollTop }, n = 0;\n  return function s() {\n    const l = { left: o.scrollLeft, top: o.scrollTop }, i = e.left !== l.left, r = e.top !== l.top;\n    (i || r) && t(), e = l, n = window.requestAnimationFrame(s);\n  }(), () => window.cancelAnimationFrame(n);\n}\nfunction rn(o, t, e = \"ltr\") {\n  const n = Lt(t), s = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, l = t.scrollbar.size - s, i = t.content - t.viewport, r = l - n, u = e === \"ltr\" ? [0, i] : [i * -1, 0], d = $i(\n    o,\n    u\n  );\n  return Zn([0, i], [0, r])(d);\n}\nfunction Et(o) {\n  return o ? Number.parseInt(o, 10) : 0;\n}\nfunction Pi(o, t, e, n = \"ltr\") {\n  const s = Lt(e), l = s / 2, i = t || l, r = s - i, u = e.scrollbar.paddingStart + i, d = e.scrollbar.size - e.scrollbar.paddingEnd - r, c = e.content - e.viewport, p = n === \"ltr\" ? [0, c] : [c * -1, 0];\n  return Zn(\n    [u, d],\n    p\n  )(o);\n}\nfunction un(o, t) {\n  return o > 0 && o < t;\n}\nconst ea = /* @__PURE__ */ g({\n  __name: \"ScrollAreaScrollbarImpl\",\n  props: {\n    isHorizontal: { type: Boolean }\n  },\n  emits: [\"onDragScroll\", \"onWheelScroll\", \"onThumbPointerDown\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = me(), l = Kt(), i = Nt(), { primitiveElement: r, currentElement: u } = V(), d = be(), c = B(\"\"), p = B();\n    function f(E) {\n      var x, P;\n      if (p.value) {\n        const I = E.clientX - ((x = p.value) == null ? void 0 : x.left), A = E.clientY - ((P = p.value) == null ? void 0 : P.top);\n        n(\"onDragScroll\", { x: I, y: A });\n      }\n    }\n    function m(E) {\n      E.button === 0 && (E.target.setPointerCapture(E.pointerId), p.value = u.value.getBoundingClientRect(), c.value = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = \"none\", s.viewport && (s.viewport.value.style.scrollBehavior = \"auto\"), f(E));\n    }\n    function C(E) {\n      f(E);\n    }\n    function w(E) {\n      const x = E.target;\n      x.hasPointerCapture(E.pointerId) && x.releasePointerCapture(E.pointerId), document.body.style.webkitUserSelect = c.value, s.viewport && (s.viewport.value.style.scrollBehavior = \"\"), p.value = void 0;\n    }\n    function $(E) {\n      var A;\n      const x = E.target, P = (A = u.value) == null ? void 0 : A.contains(x), I = l.sizes.value.content - l.sizes.value.viewport;\n      P && l.handleWheelScroll(E, I);\n    }\n    U(() => {\n      document.addEventListener(\"wheel\", $, { passive: !1 });\n    }), fe(() => {\n      document.removeEventListener(\"wheel\", $);\n    });\n    function _() {\n      var E, x, P, I, A;\n      u.value && (e.isHorizontal ? l.handleSizeChange({\n        content: ((E = s.viewport.value) == null ? void 0 : E.scrollWidth) ?? 0,\n        viewport: ((x = s.viewport.value) == null ? void 0 : x.offsetWidth) ?? 0,\n        scrollbar: {\n          size: u.value.clientWidth ?? 0,\n          paddingStart: Et(getComputedStyle(u.value).paddingLeft),\n          paddingEnd: Et(getComputedStyle(u.value).paddingRight)\n        }\n      }) : l.handleSizeChange({\n        content: ((P = s.viewport.value) == null ? void 0 : P.scrollHeight) ?? 0,\n        viewport: ((I = s.viewport.value) == null ? void 0 : I.offsetHeight) ?? 0,\n        scrollbar: {\n          size: ((A = u.value) == null ? void 0 : A.clientHeight) ?? 0,\n          paddingStart: Et(getComputedStyle(u.value).paddingLeft),\n          paddingEnd: Et(getComputedStyle(u.value).paddingRight)\n        }\n      }));\n    }\n    return _e(u, _), _e(s.content, _), (E, x) => (h(), b(a(D), {\n      ref: (P) => {\n        a(d)(P), r.value = P;\n      },\n      style: { position: \"absolute\" },\n      \"data-scrollbarimpl\": \"\",\n      as: a(i).as.value,\n      \"as-child\": a(i).asChild.value,\n      onPointerdown: m,\n      onPointermove: C,\n      onPointerup: w\n    }, {\n      default: v(() => [\n        y(E.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), Si = /* @__PURE__ */ g({\n  __name: \"ScrollAreaScrollbarX\",\n  setup(o) {\n    const t = me(), e = Kt(), { primitiveElement: n, currentElement: s } = V(), l = be();\n    U(() => {\n      s.value && t.onScrollbarXChange(s.value);\n    });\n    const i = S(() => e.sizes.value);\n    return (r, u) => (h(), b(ea, {\n      ref: (d) => {\n        a(l)(d), n.value = d;\n      },\n      \"is-horizontal\": !0,\n      \"data-orientation\": \"horizontal\",\n      style: ae({\n        bottom: 0,\n        left: a(t).dir.value === \"rtl\" ? \"var(--radix-scroll-area-corner-width)\" : 0,\n        right: a(t).dir.value === \"ltr\" ? \"var(--radix-scroll-area-corner-width)\" : 0,\n        \"--radix-scroll-area-thumb-width\": i.value ? `${a(Lt)(i.value)}px` : void 0\n      }),\n      onOnDragScroll: u[0] || (u[0] = (d) => a(e).onDragScroll(d.x))\n    }, {\n      default: v(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"style\"]));\n  }\n}), Ti = /* @__PURE__ */ g({\n  __name: \"ScrollAreaScrollbarY\",\n  setup(o) {\n    const t = me(), e = Kt(), { primitiveElement: n, currentElement: s } = V(), l = be();\n    U(() => {\n      s.value && t.onScrollbarYChange(s.value);\n    });\n    const i = S(() => e.sizes.value);\n    return (r, u) => (h(), b(ea, {\n      ref: (d) => {\n        a(l)(d), n.value = d;\n      },\n      \"is-horizontal\": !1,\n      \"data-orientation\": \"vertical\",\n      style: ae({\n        top: 0,\n        right: a(t).dir.value === \"ltr\" ? 0 : void 0,\n        left: a(t).dir.value === \"rtl\" ? 0 : void 0,\n        bottom: \"var(--radix-scroll-area-corner-height)\",\n        \"--radix-scroll-area-thumb-height\": i.value ? `${a(Lt)(i.value)}px` : void 0\n      }),\n      onOnDragScroll: u[0] || (u[0] = (d) => a(e).onDragScroll(d.y))\n    }, {\n      default: v(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"style\"]));\n  }\n}), [Kt, Di] = H(\"ScrollAreaScrollbarVisible\"), Xo = /* @__PURE__ */ g({\n  __name: \"ScrollAreaScrollbarVisible\",\n  setup(o) {\n    const t = me(), e = Nt(), n = be(), s = B({\n      content: 0,\n      viewport: 0,\n      scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }\n    }), l = S(() => {\n      const _ = Qn(s.value.viewport, s.value.content);\n      return _ > 0 && _ < 1;\n    }), i = B(), r = B(0);\n    function u(_, E) {\n      if (m.value) {\n        const x = t.viewport.value.scrollLeft + _.deltaY;\n        t.viewport.value.scrollLeft = x, un(x, E) && _.preventDefault();\n      } else {\n        const x = t.viewport.value.scrollTop + _.deltaY;\n        t.viewport.value.scrollTop = x, un(x, E) && _.preventDefault();\n      }\n    }\n    function d(_, E) {\n      m.value ? r.value = E.x : r.value = E.y;\n    }\n    function c(_) {\n      r.value = 0;\n    }\n    function p(_) {\n      s.value = _;\n    }\n    function f(_, E) {\n      return Pi(\n        _,\n        r.value,\n        s.value,\n        E\n      );\n    }\n    const m = S(\n      () => e.isHorizontal.value\n    );\n    function C(_) {\n      m.value ? t.viewport.value.scrollLeft = f(\n        _,\n        t.dir.value\n      ) : t.viewport.value.scrollTop = f(_);\n    }\n    function w() {\n      if (m.value) {\n        if (t.viewport.value && i.value) {\n          const _ = t.viewport.value.scrollLeft, E = rn(\n            _,\n            s.value,\n            t.dir.value\n          );\n          i.value.style.transform = `translate3d(${E}px, 0, 0)`;\n        }\n      } else if (t.viewport.value && i.value) {\n        const _ = t.viewport.value.scrollTop, E = rn(_, s.value);\n        i.value.style.transform = `translate3d(0, ${E}px, 0)`;\n      }\n    }\n    function $(_) {\n      i.value = _;\n    }\n    return Di({\n      sizes: s,\n      hasThumb: l,\n      handleWheelScroll: u,\n      handleThumbDown: d,\n      handleThumbUp: c,\n      handleSizeChange: p,\n      onThumbPositionChange: w,\n      onThumbChange: $,\n      onDragScroll: C\n    }), (_, E) => m.value ? (h(), b(Si, T({ key: 0 }, _.$attrs, {\n      ref_key: \"forwardRef\",\n      ref: n\n    }), {\n      default: v(() => [\n        y(_.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : (h(), b(Ti, T({ key: 1 }, _.$attrs, {\n      ref_key: \"forwardRef\",\n      ref: n\n    }), {\n      default: v(() => [\n        y(_.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ta = /* @__PURE__ */ g({\n  __name: \"ScrollAreaScrollbarAuto\",\n  props: {\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = me(), e = Nt(), n = be(), s = B(!1), l = yo(() => {\n      if (t.viewport.value) {\n        const i = t.viewport.value.offsetWidth < t.viewport.value.scrollWidth, r = t.viewport.value.offsetHeight < t.viewport.value.scrollHeight;\n        s.value = e.isHorizontal.value ? i : r;\n      }\n    }, 10);\n    return U(() => l()), _e(t.viewport, l), _e(t.content, l), (i, r) => (h(), b(a(se), {\n      present: i.forceMount || s.value\n    }, {\n      default: v(() => [\n        k(Xo, T(i.$attrs, {\n          ref_key: \"forwardRef\",\n          ref: n,\n          \"data-state\": s.value ? \"visible\" : \"hidden\"\n        }), {\n          default: v(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Oi = /* @__PURE__ */ g({\n  inheritAttrs: !1,\n  __name: \"ScrollAreaScrollbarHover\",\n  props: {\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = me(), e = be();\n    let n;\n    const s = B(!1);\n    function l() {\n      window.clearTimeout(n), s.value = !0;\n    }\n    function i() {\n      n = window.setTimeout(() => {\n        s.value = !1;\n      }, t.scrollHideDelay.value);\n    }\n    return U(() => {\n      const r = t.scrollArea.value;\n      r && (r.addEventListener(\"pointerenter\", l), r.addEventListener(\"pointerleave\", i));\n    }), fe(() => {\n      const r = t.scrollArea.value;\n      r && (window.clearTimeout(n), r.removeEventListener(\"pointerenter\", l), r.removeEventListener(\"pointerleave\", i));\n    }), (r, u) => (h(), b(a(se), {\n      present: r.forceMount || s.value\n    }, {\n      default: v(() => [\n        k(ta, T(r.$attrs, {\n          ref_key: \"forwardRef\",\n          ref: e,\n          \"data-state\": s.value ? \"visible\" : \"hidden\"\n        }), {\n          default: v(() => [\n            y(r.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Ii = /* @__PURE__ */ g({\n  __name: \"ScrollAreaScrollbarScroll\",\n  props: {\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = me(), e = Nt(), n = be(), { state: s, dispatch: l } = $n(\"hidden\", {\n      hidden: {\n        SCROLL: \"scrolling\"\n      },\n      scrolling: {\n        SCROLL_END: \"idle\",\n        POINTER_ENTER: \"interacting\"\n      },\n      interacting: {\n        SCROLL: \"interacting\",\n        POINTER_LEAVE: \"idle\"\n      },\n      idle: {\n        HIDE: \"hidden\",\n        SCROLL: \"scrolling\",\n        POINTER_ENTER: \"interacting\"\n      }\n    });\n    ee(() => {\n      s.value === \"idle\" && window.setTimeout(\n        () => l(\"HIDE\"),\n        t.scrollHideDelay.value\n      );\n    });\n    const i = yo(() => l(\"SCROLL_END\"), 100);\n    return ee(() => {\n      const r = t.viewport.value, u = e.isHorizontal.value ? \"scrollLeft\" : \"scrollTop\";\n      if (r) {\n        let d = r[u];\n        const c = () => {\n          const p = r[u];\n          d !== p && (l(\"SCROLL\"), i()), d = p;\n        };\n        r.addEventListener(\"scroll\", c);\n      }\n    }), (r, u) => (h(), b(a(se), {\n      present: r.forceMount || a(s) !== \"hidden\"\n    }, {\n      default: v(() => [\n        k(Xo, T(r.$attrs, {\n          ref_key: \"forwardRef\",\n          ref: n\n        }), {\n          default: v(() => [\n            y(r.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), [Nt, Ai] = H(\"ScrollAreaScrollbar\"), cc = /* @__PURE__ */ g({\n  inheritAttrs: !1,\n  __name: \"ScrollAreaScrollbar\",\n  props: {\n    orientation: { default: \"vertical\" },\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(o) {\n    const t = o, e = me(), n = S(() => t.orientation === \"horizontal\");\n    Y(\n      n,\n      () => {\n        n.value ? e.onScrollbarXEnabledChange(!0) : e.onScrollbarYEnabledChange(!0);\n      },\n      { immediate: !0 }\n    ), fe(() => {\n      e.onScrollbarXEnabledChange(!1), e.onScrollbarYEnabledChange(!1);\n    });\n    const { orientation: s, forceMount: l, asChild: i, as: r } = z(t);\n    return Ai({\n      orientation: s,\n      forceMount: l,\n      isHorizontal: n,\n      as: r,\n      asChild: i\n    }), (u, d) => a(e).type.value === \"hover\" ? (h(), b(Oi, T({ key: 0 }, u.$attrs, { \"force-mount\": a(l) }), {\n      default: v(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"force-mount\"])) : a(e).type.value === \"scroll\" ? (h(), b(Ii, T({ key: 1 }, u.$attrs, { \"force-mount\": a(l) }), {\n      default: v(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"force-mount\"])) : a(e).type.value === \"auto\" ? (h(), b(ta, T({ key: 2 }, u.$attrs, { \"force-mount\": a(l) }), {\n      default: v(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"force-mount\"])) : a(e).type.value === \"always\" ? (h(), b(Xo, T({ key: 3 }, u.$attrs, { \"data-state\": \"visible\" }), {\n      default: v(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : J(\"\", !0);\n  }\n}), pc = /* @__PURE__ */ g({\n  __name: \"ScrollAreaThumb\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = me(), n = Kt();\n    function s(f) {\n      const C = f.target.getBoundingClientRect(), w = f.clientX - C.left, $ = f.clientY - C.top;\n      n.handleThumbDown(f, { x: w, y: $ });\n    }\n    function l(f) {\n      n.handleThumbUp(f);\n    }\n    const { primitiveElement: i, currentElement: r } = V(), u = B(), d = S(() => e.viewport.value);\n    function c() {\n      if (!u.value) {\n        const f = Bi(\n          d.value,\n          n.onThumbPositionChange\n        );\n        u.value = f, n.onThumbPositionChange();\n      }\n    }\n    const p = S(() => n.sizes.value);\n    return Qa(p, () => {\n      n.onThumbChange(r.value), d.value && (n.onThumbPositionChange(), d.value.addEventListener(\"scroll\", c));\n    }), fe(() => {\n      var f;\n      d.value.removeEventListener(\"scroll\", c), (f = e.viewport.value) == null || f.removeEventListener(\"scroll\", c);\n    }), (f, m) => (h(), b(a(D), {\n      ref_key: \"primitiveElement\",\n      ref: i,\n      \"data-state\": a(n).hasThumb ? \"visible\" : \"hidden\",\n      style: ae({\n        width: \"var(--radix-scroll-area-thumb-width)\",\n        height: \"var(--radix-scroll-area-thumb-height)\"\n      }),\n      \"as-child\": t.asChild,\n      as: f.as,\n      onPointerdown: s,\n      onPointerup: l\n    }, {\n      default: v(() => [\n        y(f.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"data-state\", \"style\", \"as-child\", \"as\"]));\n  }\n}), Mi = /* @__PURE__ */ g({\n  __name: \"ScrollAreaCornerImpl\",\n  setup(o) {\n    const t = me(), e = B(0), n = B(0), s = S(() => !!e.value && !!n.value);\n    function l() {\n      var u;\n      const r = ((u = t.scrollbarX.value) == null ? void 0 : u.offsetHeight) || 0;\n      t.onCornerHeightChange(r), n.value = r;\n    }\n    function i() {\n      var u;\n      const r = ((u = t.scrollbarY.value) == null ? void 0 : u.offsetWidth) || 0;\n      t.onCornerWidthChange(r), e.value = r;\n    }\n    return _e(t.scrollbarX.value, l), _e(t.scrollbarY.value, i), Y(() => t.scrollbarX.value, l), Y(() => t.scrollbarY.value, i), (r, u) => {\n      var d;\n      return s.value ? (h(), b(a(D), T({\n        key: 0,\n        style: {\n          width: `${e.value}px`,\n          height: `${n.value}px`,\n          position: \"absolute\",\n          right: a(t).dir.value === \"ltr\" ? 0 : void 0,\n          left: a(t).dir.value === \"rtl\" ? 0 : void 0,\n          bottom: 0\n        }\n      }, (d = r.$parent) == null ? void 0 : d.$props), {\n        default: v(() => [\n          y(r.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"style\"])) : J(\"\", !0);\n    };\n  }\n}), fc = /* @__PURE__ */ g({\n  __name: \"ScrollAreaCorner\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = me(), n = S(\n      () => !!e.scrollbarX.value && !!e.scrollbarY.value\n    ), s = S(\n      () => e.type.value !== \"scroll\" && n.value\n    );\n    return (l, i) => s.value ? (h(), b(Mi, R(T({ key: 0 }, t)), {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : J(\"\", !0);\n  }\n}), ki = [\"default-value\"], Ri = /* @__PURE__ */ g({\n  __name: \"BubbleSelect\",\n  props: {\n    autocomplete: {},\n    autofocus: { type: Boolean },\n    disabled: { type: Boolean },\n    form: {},\n    multiple: { type: Boolean },\n    name: {},\n    required: { type: Boolean },\n    size: {},\n    value: {}\n  },\n  setup(o) {\n    const t = o, { value: e } = z(t);\n    ls(e);\n    const n = B();\n    return (s, l) => (h(), b(a(Xe), { \"as-child\": \"\" }, {\n      default: v(() => [\n        fo(rt(\"select\", T({\n          ref_key: \"selectElement\",\n          ref: n\n        }, t, {\n          \"onUpdate:modelValue\": l[0] || (l[0] = (i) => ut(e) ? e.value = i : null),\n          \"default-value\": a(e)\n        }), [\n          y(s.$slots, \"default\")\n        ], 16, ki), [\n          [ka, a(e)]\n        ])\n      ]),\n      _: 3\n    }));\n  }\n}), Vi = {\n  key: 0,\n  value: \"\"\n}, [De, oa] = H(\"SelectRoot\"), [Fi, Li] = H(\"SelectRoot\"), vc = /* @__PURE__ */ g({\n  __name: \"SelectRoot\",\n  props: {\n    open: { type: Boolean, default: void 0 },\n    defaultOpen: { type: Boolean },\n    defaultValue: { default: \"\" },\n    modelValue: { default: void 0 },\n    orientation: { default: \"vertical\" },\n    dir: {},\n    name: {},\n    autocomplete: {},\n    disabled: { type: Boolean },\n    required: { type: Boolean }\n  },\n  emits: [\"update:modelValue\", \"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = X(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), l = X(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), i = B(), r = B(), u = B({\n      x: 0,\n      y: 0\n    }), d = B(!1), { required: c, disabled: p, dir: f } = z(e), m = de(f);\n    oa({\n      triggerElement: i,\n      onTriggerChange: (_) => {\n        i.value = _;\n      },\n      valueElement: r,\n      onValueElementChange: (_) => {\n        r.value = _;\n      },\n      valueElementHasChildren: d,\n      onValueElementHasChildrenChange: (_) => {\n        d.value = _;\n      },\n      contentId: te(),\n      modelValue: s,\n      onValueChange: (_) => {\n        s.value = _;\n      },\n      open: l,\n      required: c,\n      onOpenChange: (_) => {\n        l.value = _;\n      },\n      dir: m,\n      triggerPointerDownPosRef: u,\n      disabled: p\n    });\n    const C = Ke(i), w = B(/* @__PURE__ */ new Set()), $ = S(() => Array.from(w.value).map((_) => {\n      var E;\n      return (E = _.props) == null ? void 0 : E.value;\n    }).join(\";\"));\n    return Li({\n      onNativeOptionAdd: (_) => {\n        w.value.add(_);\n      },\n      onNativeOptionRemove: (_) => {\n        w.value.delete(_);\n      }\n    }), (_, E) => (h(), b(a(Ne), null, {\n      default: v(() => [\n        y(_.$slots, \"default\"),\n        a(C) ? (h(), b(Ri, T({ key: $.value }, _.$attrs, {\n          \"aria-hidden\": \"\",\n          tabindex: \"-1\",\n          required: a(c),\n          name: _.name,\n          autocomplete: _.autocomplete,\n          disabled: a(p),\n          value: a(s),\n          onChange: E[0] || (E[0] = (x) => s.value = x.target.value)\n        }), {\n          default: v(() => [\n            a(s) === void 0 ? (h(), Q(\"option\", Vi)) : J(\"\", !0),\n            (h(!0), Q(ie, null, po(Array.from(w.value), (x) => (h(), b($e(x), T(x.props, {\n              key: x.key ?? \"\"\n            }), null, 16))), 128))\n          ]),\n          _: 1\n        }, 16, [\"required\", \"name\", \"autocomplete\", \"disabled\", \"value\"])) : J(\"\", !0)\n      ]),\n      _: 3\n    }));\n  }\n}), Ki = [\" \", \"Enter\", \"ArrowUp\", \"ArrowDown\"], Ni = [\" \", \"Enter\"], Ce = 10;\nfunction na(o) {\n  return o === \"\" || o === void 0;\n}\nconst mc = /* @__PURE__ */ g({\n  __name: \"SelectTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = De(), n = S(() => {\n      var f;\n      return ((f = e.disabled) == null ? void 0 : f.value) || t.disabled;\n    }), { primitiveElement: s, currentElement: l } = V();\n    U(() => {\n      e.triggerElement = l;\n    });\n    const { injectCollection: i } = re(), r = i(), { search: u, handleTypeaheadSearch: d, resetTypeahead: c } = _o(r);\n    function p() {\n      n.value || (e.onOpenChange(!0), c());\n    }\n    return (f, m) => (h(), b(a(He), { \"as-child\": \"\" }, {\n      default: v(() => {\n        var C, w, $, _;\n        return [\n          k(a(D), {\n            ref_key: \"primitiveElement\",\n            ref: s,\n            role: \"combobox\",\n            type: f.as === \"button\" ? \"button\" : void 0,\n            \"aria-controls\": a(e).contentId,\n            \"aria-expanded\": a(e).open.value || !1,\n            \"aria-required\": (C = a(e).required) == null ? void 0 : C.value,\n            \"aria-autocomplete\": \"none\",\n            disabled: f.disabled,\n            dir: (w = a(e)) == null ? void 0 : w.dir.value,\n            \"data-state\": ($ = a(e)) != null && $.open.value ? \"open\" : \"closed\",\n            \"data-disabled\": n.value ? \"\" : void 0,\n            \"data-placeholder\": a(na)((_ = a(e).modelValue) == null ? void 0 : _.value) ? \"\" : void 0,\n            \"as-child\": f.asChild,\n            as: f.as,\n            onClick: m[0] || (m[0] = (E) => {\n              var x;\n              (x = E == null ? void 0 : E.currentTarget) == null || x.focus();\n            }),\n            onPointerdown: m[1] || (m[1] = (E) => {\n              const x = E.target;\n              x.hasPointerCapture(E.pointerId) && x.releasePointerCapture(E.pointerId), E.button === 0 && E.ctrlKey === !1 && (p(), a(e).triggerPointerDownPosRef.value = {\n                x: Math.round(E.pageX),\n                y: Math.round(E.pageY)\n              }, E.preventDefault());\n            }),\n            onPointerup: m[2] || (m[2] = ne(() => {\n            }, [\"prevent\"])),\n            onKeydown: m[3] || (m[3] = (E) => {\n              const x = a(u) !== \"\";\n              !(E.ctrlKey || E.altKey || E.metaKey) && E.key.length === 1 && x && E.key === \" \" || (a(d)(E.key), a(Ki).includes(E.key) && (p(), E.preventDefault()));\n            })\n          }, {\n            default: v(() => [\n              y(f.$slots, \"default\")\n            ]),\n            _: 3\n          }, 8, [\"type\", \"aria-controls\", \"aria-expanded\", \"aria-required\", \"disabled\", \"dir\", \"data-state\", \"data-disabled\", \"data-placeholder\", \"as-child\", \"as\"])\n        ];\n      }),\n      _: 3\n    }));\n  }\n}), hc = /* @__PURE__ */ g({\n  __name: \"SelectPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Pe), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Jo, Hi] = H(\"SelectItemAlignedPosition\"), Wi = /* @__PURE__ */ g({\n  inheritAttrs: !1,\n  __name: \"SelectItemAlignedPosition\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"placed\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { injectCollection: s } = re(), l = De(), i = Oe(), r = s(), u = B(!1), d = B(!0), c = B(), { primitiveElement: p, currentElement: f } = V(), { viewport: m, selectedItem: C, selectedItemText: w, focusSelectedItem: $ } = i;\n    function _() {\n      if (l.triggerElement.value && l.valueElement.value && c.value && f.value && (m != null && m.value) && (C != null && C.value) && (w != null && w.value)) {\n        const P = l.triggerElement.value.getBoundingClientRect(), I = f.value.getBoundingClientRect(), A = l.valueElement.value.getBoundingClientRect(), L = w.value.getBoundingClientRect();\n        if (l.dir.value !== \"rtl\") {\n          const Ie = L.left - I.left, Ee = A.left - Ie, Ae = P.left - Ee, Me = P.width + Ae, Gt = Math.max(Me, I.width), Yt = window.innerWidth - Ce, Xt = tn(Ee, Ce, Yt - Gt);\n          c.value.style.minWidth = `${Me}px`, c.value.style.left = `${Xt}px`;\n        } else {\n          const Ie = I.right - L.right, Ee = window.innerWidth - A.right - Ie, Ae = window.innerWidth - P.right - Ee, Me = P.width + Ae, Gt = Math.max(Me, I.width), Yt = window.innerWidth - Ce, Xt = tn(\n            Ee,\n            Ce,\n            Yt - Gt\n          );\n          c.value.style.minWidth = `${Me}px`, c.value.style.right = `${Xt}px`;\n        }\n        const M = r.value, W = window.innerHeight - Ce * 2, O = m.value.scrollHeight, K = window.getComputedStyle(f.value), j = Number.parseInt(\n          K.borderTopWidth,\n          10\n        ), Z = Number.parseInt(K.paddingTop, 10), F = Number.parseInt(\n          K.borderBottomWidth,\n          10\n        ), q = Number.parseInt(\n          K.paddingBottom,\n          10\n        ), oe = j + Z + O + q + F, tt = Math.min(\n          C.value.offsetHeight * 5,\n          oe\n        ), ot = window.getComputedStyle(m.value), ht = Number.parseInt(ot.paddingTop, 10), Ea = Number.parseInt(\n          ot.paddingBottom,\n          10\n        ), yt = P.top + P.height / 2 - Ce, xa = W - yt, qt = C.value.offsetHeight / 2, $a = C.value.offsetTop + qt, gt = j + Z + $a, Ba = oe - gt;\n        if (gt <= yt) {\n          const Ie = C.value === M[M.length - 1];\n          c.value.style.bottom = \"0px\";\n          const Ee = f.value.clientHeight - m.value.offsetTop - m.value.offsetHeight, Ae = Math.max(\n            xa,\n            qt + (Ie ? Ea : 0) + Ee + F\n          ), Me = gt + Ae;\n          c.value.style.height = `${Me}px`;\n        } else {\n          const Ie = C.value === M[0];\n          c.value.style.top = \"0px\";\n          const Ae = Math.max(\n            yt,\n            j + m.value.offsetTop + (Ie ? ht : 0) + qt\n          ) + Ba;\n          c.value.style.height = `${Ae}px`, m.value.scrollTop = gt - yt + m.value.offsetTop;\n        }\n        c.value.style.margin = `${Ce}px 0`, c.value.style.minHeight = `${tt}px`, c.value.style.maxHeight = `${W}px`, n(\"placed\"), requestAnimationFrame(() => u.value = !0);\n      }\n    }\n    const E = B(\"\");\n    U(async () => {\n      await G(), _(), f.value && (E.value = window.getComputedStyle(f.value).zIndex);\n    });\n    function x(P) {\n      P && d.value === !0 && (_(), $ == null || $(), d.value = !1);\n    }\n    return Hi({\n      contentWrapper: c,\n      shouldExpandOnScrollRef: u,\n      onScrollButtonChange: x\n    }), (P, I) => (h(), Q(\"div\", {\n      ref_key: \"contentWrapperElement\",\n      ref: c,\n      style: ae({\n        display: \"flex\",\n        flexDirection: \"column\",\n        position: \"fixed\",\n        zIndex: E.value\n      })\n    }, [\n      k(a(D), T({\n        ref_key: \"primitiveElement\",\n        ref: p,\n        style: {\n          // When we get the height of the content, it includes borders. If we were to set\n          // the height without having `boxSizing: 'border-box'` it would be too big.\n          boxSizing: \"border-box\",\n          // We need to ensure the content doesn't get taller than the wrapper\n          maxHeight: \"100%\"\n        }\n      }, { ...P.$attrs, ...e }), {\n        default: v(() => [\n          y(P.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"style\"])\n    ], 4));\n  }\n}), ji = /* @__PURE__ */ g({\n  __name: \"SelectPopperPosition\",\n  props: {\n    side: {},\n    sideOffset: {},\n    align: { default: \"start\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: { default: Ce },\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    onPlaced: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const e = It(o);\n    return (n, s) => (h(), b(a(Ge), T(a(e), { style: {\n      // Ensure border-box for floating-ui calculations\n      boxSizing: \"border-box\",\n      \"--radix-select-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-select-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-select-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-select-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-select-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    } }), {\n      default: v(() => [\n        y(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"style\"]));\n  }\n}), et = {\n  onViewportChange: () => {\n  },\n  itemTextRefCallback: () => {\n  },\n  itemRefCallback: () => {\n  }\n}, [Oe, zi] = H(\"SelectContent\"), Ui = /* @__PURE__ */ g({\n  __name: \"SelectContentImpl\",\n  props: {\n    position: {},\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    onPlaced: { type: Function },\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"closeAutoFocus\", \"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = De();\n    Co(), pt(!0);\n    const { createCollection: l } = re(), i = B();\n    ft(i);\n    const r = l(i), { search: u, handleTypeaheadSearch: d } = _o(r), c = B(), p = B(), f = B(), m = B(!1), C = B(!1);\n    function w() {\n      p.value && i.value && ao([p.value, i.value]);\n    }\n    Y(m, () => {\n      w();\n    });\n    const { onOpenChange: $, triggerPointerDownPosRef: _ } = s;\n    ee((P) => {\n      if (!i.value)\n        return;\n      let I = { x: 0, y: 0 };\n      const A = (M) => {\n        var W, O;\n        I = {\n          x: Math.abs(\n            Math.round(M.pageX) - (((W = _.value) == null ? void 0 : W.x) ?? 0)\n          ),\n          y: Math.abs(\n            Math.round(M.pageY) - (((O = _.value) == null ? void 0 : O.y) ?? 0)\n          )\n        };\n      }, L = (M) => {\n        var W;\n        I.x <= 10 && I.y <= 10 ? M.preventDefault() : (W = i.value) != null && W.contains(M.target) || $(!1), document.removeEventListener(\"pointermove\", A), _.value = null;\n      };\n      _.value !== null && (document.addEventListener(\"pointermove\", A), document.addEventListener(\"pointerup\", L, {\n        capture: !0,\n        once: !0\n      })), P(() => {\n        document.removeEventListener(\"pointermove\", A), document.removeEventListener(\"pointerup\", L, {\n          capture: !0\n        });\n      });\n    });\n    function E(P) {\n      const I = P.ctrlKey || P.altKey || P.metaKey;\n      if (P.key === \"Tab\" && P.preventDefault(), !I && P.key.length === 1 && d(P.key), [\"ArrowUp\", \"ArrowDown\", \"Home\", \"End\"].includes(P.key)) {\n        let A = r.value;\n        if ([\"ArrowUp\", \"End\"].includes(P.key) && (A = A.slice().reverse()), [\"ArrowUp\", \"ArrowDown\"].includes(P.key)) {\n          const L = P.target, M = A.indexOf(L);\n          A = A.slice(M + 1);\n        }\n        setTimeout(() => ao(A)), P.preventDefault();\n      }\n    }\n    const x = S(() => e.position === \"popper\" ? e : {});\n    return zi({\n      content: i,\n      viewport: c,\n      onViewportChange: (P) => {\n        c.value = P;\n      },\n      itemRefCallback: (P, I, A) => {\n        var W, O;\n        const L = !C.value && !A;\n        (((W = s.modelValue) == null ? void 0 : W.value) !== void 0 && ((O = s.modelValue) == null ? void 0 : O.value) === I || L) && (p.value = P, L && (C.value = !0));\n      },\n      selectedItem: p,\n      selectedItemText: f,\n      onItemLeave: () => {\n        var P;\n        (P = i.value) == null || P.focus();\n      },\n      itemTextRefCallback: (P, I, A) => {\n        var W, O;\n        const L = !C.value && !A;\n        (((W = s.modelValue) == null ? void 0 : W.value) !== void 0 && ((O = s.modelValue) == null ? void 0 : O.value) === I || L) && (f.value = P);\n      },\n      focusSelectedItem: w,\n      position: e.position,\n      isPositioned: m,\n      searchRef: u\n    }), (P, I) => (h(), b(a(Mt), {\n      \"as-child\": \"\",\n      onMountAutoFocus: I[6] || (I[6] = ne(() => {\n      }, [\"prevent\"])),\n      onUnmountAutoFocus: I[7] || (I[7] = (A) => {\n        var L;\n        n(\"closeAutoFocus\", A), !A.defaultPrevented && ((L = a(s).triggerElement.value) == null || L.focus({ preventScroll: !0 }), A.preventDefault());\n      })\n    }, {\n      default: v(() => [\n        k(a(Se), {\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": \"\",\n          onFocusOutside: I[2] || (I[2] = ne(() => {\n          }, [\"prevent\"])),\n          onDismiss: I[3] || (I[3] = (A) => a(s).onOpenChange(!1)),\n          onEscapeKeyDown: I[4] || (I[4] = (A) => n(\"escapeKeyDown\", A)),\n          onPointerDownOutside: I[5] || (I[5] = (A) => n(\"pointerDownOutside\", A))\n        }, {\n          default: v(() => [\n            (h(), b($e(\n              P.position === \"popper\" ? ji : Wi\n            ), T({ ...P.$attrs, ...x.value }, {\n              id: a(s).contentId,\n              ref: (A) => {\n                i.value = a(ve)(A);\n              },\n              role: \"listbox\",\n              \"data-state\": a(s).open.value ? \"open\" : \"closed\",\n              dir: a(s).dir.value,\n              style: {\n                // flex layout so we can place the scroll buttons properly\n                display: \"flex\",\n                flexDirection: \"column\",\n                // reset the outline by default as the content MAY get focused\n                outline: \"none\"\n              },\n              onContextmenu: I[0] || (I[0] = ne(() => {\n              }, [\"prevent\"])),\n              onPlaced: I[1] || (I[1] = (A) => m.value = !0),\n              onKeydown: E\n            }), {\n              default: v(() => [\n                y(P.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"id\", \"data-state\", \"dir\", \"onKeydown\"]))\n          ]),\n          _: 3\n        })\n      ]),\n      _: 3\n    }));\n  }\n}), qi = /* @__PURE__ */ g({\n  __name: \"SelectProvider\",\n  props: {\n    context: {}\n  },\n  setup(o) {\n    return oa(o.context), (e, n) => y(e.$slots, \"default\");\n  }\n}), yc = /* @__PURE__ */ g({\n  inheritAttrs: !1,\n  __name: \"SelectContent\",\n  props: {\n    forceMount: { type: Boolean },\n    position: { default: \"item-aligned\" },\n    side: {},\n    sideOffset: {},\n    align: { default: \"start\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    onPlaced: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"closeAutoFocus\", \"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(o, { emit: t }) {\n    const s = pe(o, t), l = De(), i = B();\n    U(() => {\n      i.value = new DocumentFragment();\n    });\n    const r = B();\n    return (u, d) => {\n      var c;\n      return h(), Q(ie, null, [\n        k(a(se), {\n          ref_key: \"presenceRef\",\n          ref: r,\n          present: u.forceMount || a(l).open.value\n        }, {\n          default: v(() => [\n            k(Ui, R(N({ ...a(s), ...u.$attrs })), {\n              default: v(() => [\n                y(u.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16)\n          ]),\n          _: 3\n        }, 8, [\"present\"]),\n        !((c = r.value) != null && c.present) && i.value ? (h(), b(Ue, {\n          key: 0,\n          to: i.value\n        }, [\n          k(qi, { context: a(l) }, {\n            default: v(() => [\n              rt(\"div\", null, [\n                y(u.$slots, \"default\")\n              ])\n            ]),\n            _: 3\n          }, 8, [\"context\"])\n        ], 8, [\"to\"])) : J(\"\", !0)\n      ], 64);\n    };\n  }\n}), gc = /* @__PURE__ */ g({\n  __name: \"SelectArrow\",\n  props: {\n    width: {},\n    height: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = De(), n = Oe();\n    return (s, l) => a(e).open.value && a(n).position === \"popper\" ? (h(), b(a(Ye), R(T({ key: 0 }, t)), {\n      default: v(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : J(\"\", !0);\n  }\n}), bc = /* @__PURE__ */ g({\n  __name: \"SelectSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(D), T({ \"aria-hidden\": \"\" }, t), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [aa, Gi] = H(\"SelectItem\"), Cc = /* @__PURE__ */ g({\n  __name: \"SelectItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { disabled: e } = z(t), n = De(), s = Oe(et), { primitiveElement: l, currentElement: i } = V(), r = S(() => {\n      var w;\n      return ((w = n.modelValue) == null ? void 0 : w.value) === t.value;\n    }), u = B(!1), d = B(t.textValue ?? \"\"), c = te();\n    async function p(w) {\n      await G(), !(w != null && w.defaultPrevented) && (e.value || (n.onValueChange(t.value), n.onOpenChange(!1)));\n    }\n    async function f(w) {\n      var $;\n      await G(), !w.defaultPrevented && (e.value ? ($ = s.onItemLeave) == null || $.call(s) : w.currentTarget.focus({ preventScroll: !0 }));\n    }\n    async function m(w) {\n      var $;\n      await G(), !w.defaultPrevented && w.currentTarget === document.activeElement && (($ = s.onItemLeave) == null || $.call(s));\n    }\n    async function C(w) {\n      var _;\n      await G(), !(w.defaultPrevented || ((_ = s.searchRef) == null ? void 0 : _.value) !== \"\" && w.key === \" \") && (Ni.includes(w.key) && p(), w.key === \" \" && w.preventDefault());\n    }\n    if (t.value === \"\")\n      throw new Error(\n        \"A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.\"\n      );\n    return U(() => {\n      i.value && s.itemRefCallback(\n        i.value,\n        t.value,\n        t.disabled\n      );\n    }), Gi({\n      value: t.value,\n      disabled: e,\n      textId: c,\n      isSelected: r,\n      onItemTextChange: (w) => {\n        d.value = ((d.value || (w == null ? void 0 : w.textContent)) ?? \"\").trim();\n      }\n    }), (w, $) => (h(), b(a(D), {\n      ref_key: \"primitiveElement\",\n      ref: l,\n      role: \"option\",\n      \"data-radix-vue-collection-item\": \"\",\n      \"aria-labelledby\": a(c),\n      \"data-highlighted\": u.value ? \"\" : void 0,\n      \"aria-selected\": r.value && u.value,\n      \"data-state\": r.value ? \"checked\" : \"unchecked\",\n      \"aria-disabled\": a(e) || void 0,\n      \"data-disabled\": a(e) ? \"\" : void 0,\n      tabindex: a(e) ? void 0 : -1,\n      as: w.as,\n      \"as-child\": w.asChild,\n      onFocus: $[0] || ($[0] = (_) => u.value = !0),\n      onBlur: $[1] || ($[1] = (_) => u.value = !1),\n      onPointerup: p,\n      onPointermove: f,\n      onPointerleave: m,\n      onKeydown: C\n    }, {\n      default: v(() => [\n        y(w.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"aria-labelledby\", \"data-highlighted\", \"aria-selected\", \"data-state\", \"aria-disabled\", \"data-disabled\", \"tabindex\", \"as\", \"as-child\"]));\n  }\n}), _c = /* @__PURE__ */ g({\n  __name: \"SelectItemIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = o, e = aa();\n    return (n, s) => a(e).isSelected.value ? (h(), b(a(D), T({\n      key: 0,\n      \"aria-hidden\": \"\"\n    }, t), {\n      default: v(() => [\n        y(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : J(\"\", !0);\n  }\n}), [Yi, Xi] = H(\"SelectGroup\"), wc = /* @__PURE__ */ g({\n  __name: \"SelectGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = te();\n    return Xi({ id: e }), (n, s) => (h(), b(a(D), T({ role: \"group\" }, t, { \"aria-labelledby\": a(e) }), {\n      default: v(() => [\n        y(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-labelledby\"]));\n  }\n}), Ec = /* @__PURE__ */ g({\n  __name: \"SelectLabel\",\n  props: {\n    for: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(o) {\n    const t = o, e = Yi({ id: \"\" });\n    return (n, s) => (h(), b(a(D), T(t, {\n      id: a(e).id\n    }), {\n      default: v(() => [\n        y(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), xc = /* @__PURE__ */ g({\n  inheritAttrs: !1,\n  __name: \"SelectItemText\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = o, e = De(), n = Oe(et), s = Fi(), l = aa(), { primitiveElement: i, currentElement: r } = V(), u = S(() => {\n      var d;\n      return Re(\"option\", {\n        key: l.value,\n        value: l.value,\n        disabled: l.disabled.value,\n        innerHTML: (d = r.value) == null ? void 0 : d.textContent\n      });\n    });\n    return U(() => {\n      r.value && (l.onItemTextChange(r.value), n.itemTextRefCallback(\n        r.value,\n        l.value,\n        l.disabled.value\n      ), s.onNativeOptionAdd(u.value));\n    }), co(() => {\n      s.onNativeOptionRemove(u.value);\n    }), (d, c) => (h(), Q(ie, null, [\n      k(a(D), T({\n        id: a(l).textId,\n        ref_key: \"primitiveElement\",\n        ref: i\n      }, { ...t, ...d.$attrs }), {\n        default: v(() => [\n          y(d.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\"]),\n      a(l).isSelected.value && a(e).valueElement.value && !a(e).valueElementHasChildren.value ? (h(), b(Ue, {\n        key: 0,\n        to: a(e).valueElement.value\n      }, [\n        y(d.$slots, \"default\")\n      ], 8, [\"to\"])) : J(\"\", !0)\n    ], 64));\n  }\n}), $c = /* @__PURE__ */ g({\n  __name: \"SelectViewport\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = Oe(et), n = e.position === \"item-aligned\" ? Jo() : void 0, { primitiveElement: s, currentElement: l } = V();\n    U(() => {\n      e == null || e.onViewportChange(l.value);\n    });\n    const i = B(0);\n    function r(u) {\n      const d = u.currentTarget, { shouldExpandOnScrollRef: c, contentWrapper: p } = n ?? {};\n      if (c != null && c.value && (p != null && p.value)) {\n        const f = Math.abs(i.value - d.scrollTop);\n        if (f > 0) {\n          const m = window.innerHeight - Ce * 2, C = Number.parseFloat(\n            p.value.style.minHeight\n          ), w = Number.parseFloat(p.value.style.height), $ = Math.max(C, w);\n          if ($ < m) {\n            const _ = $ + f, E = Math.min(m, _), x = _ - E;\n            p.value.style.height = `${E}px`, p.value.style.bottom === \"0px\" && (d.scrollTop = x > 0 ? x : 0, p.value.style.justifyContent = \"flex-end\");\n          }\n        }\n      }\n      i.value = d.scrollTop;\n    }\n    return (u, d) => (h(), Q(ie, null, [\n      k(a(D), { as: \"style\" }, {\n        default: v(() => [\n          ue(\" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-select-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-select-viewport]::-webkit-scrollbar { display: none; } \")\n        ]),\n        _: 1\n      }),\n      k(a(D), T({\n        ref_key: \"primitiveElement\",\n        ref: s,\n        \"data-radix-select-viewport\": \"\",\n        role: \"presentation\"\n      }, { ...u.$attrs, ...t }, {\n        style: {\n          // we use position: 'relative' here on the `viewport` so that when we call\n          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport\n          // (independent of the scrollUpButton).\n          position: \"relative\",\n          flex: 1,\n          overflow: \"auto\"\n        },\n        onScroll: r\n      }), {\n        default: v(() => [\n          y(u.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"style\"])\n    ], 64));\n  }\n}), sa = /* @__PURE__ */ g({\n  __name: \"SelectScrollButtonImpl\",\n  emits: [\"autoScroll\"],\n  setup(o, { emit: t }) {\n    const e = t, { injectCollection: n } = re(), s = n(), l = Oe(et), i = B(null);\n    function r() {\n      i.value !== null && (window.clearInterval(i.value), i.value = null);\n    }\n    ee(() => {\n      const c = s.value.find(\n        (p) => p === document.activeElement\n      );\n      c == null || c.scrollIntoView({ block: \"nearest\" });\n    });\n    function u() {\n      i.value === null && (i.value = window.setInterval(() => {\n        e(\"autoScroll\");\n      }, 50));\n    }\n    function d() {\n      var c;\n      (c = l.onItemLeave) == null || c.call(l), i.value === null && (i.value = window.setInterval(() => {\n        e(\"autoScroll\");\n      }, 50));\n    }\n    return co(() => r()), (c, p) => {\n      var f;\n      return h(), b(a(D), T({\n        \"aria-hidden\": \"\",\n        style: {\n          flexShrink: 0\n        }\n      }, (f = c.$parent) == null ? void 0 : f.$props, {\n        onPointerdown: u,\n        onPointermove: d,\n        onPointerleave: p[0] || (p[0] = () => {\n          r();\n        })\n      }), {\n        default: v(() => [\n          y(c.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16);\n    };\n  }\n}), Bc = /* @__PURE__ */ g({\n  __name: \"SelectScrollUpButton\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = Oe(et), e = t.position === \"item-aligned\" ? Jo() : void 0, { primitiveElement: n, currentElement: s } = V(), l = B(!1);\n    return ee((i) => {\n      var r, u;\n      if ((r = t.viewport) != null && r.value && ((u = t.isPositioned) != null && u.value)) {\n        let d = function() {\n          l.value = c.scrollTop > 0;\n        };\n        const c = t.viewport.value;\n        d(), c.addEventListener(\"scroll\", d), i(() => c.removeEventListener(\"scroll\", d));\n      }\n    }), Y(s, () => {\n      s.value && (e == null || e.onScrollButtonChange(s.value));\n    }), (i, r) => l.value ? (h(), b(sa, {\n      key: 0,\n      ref_key: \"primitiveElement\",\n      ref: n,\n      onAutoScroll: r[0] || (r[0] = () => {\n        const { viewport: u, selectedItem: d } = a(t);\n        u != null && u.value && (d != null && d.value) && (u.value.scrollTop = u.value.scrollTop - d.value.offsetHeight);\n      })\n    }, {\n      default: v(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 512)) : J(\"\", !0);\n  }\n}), Pc = /* @__PURE__ */ g({\n  __name: \"SelectScrollDownButton\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = Oe(et), e = t.position === \"item-aligned\" ? Jo() : void 0, { primitiveElement: n, currentElement: s } = V(), l = B(!1);\n    return ee((i) => {\n      var r, u;\n      if ((r = t.viewport) != null && r.value && ((u = t.isPositioned) != null && u.value)) {\n        let d = function() {\n          const p = c.scrollHeight - c.clientHeight;\n          l.value = Math.ceil(c.scrollTop) < p;\n        };\n        const c = t.viewport.value;\n        d(), c.addEventListener(\"scroll\", d), i(() => c.removeEventListener(\"scroll\", d));\n      }\n    }), Y(s, () => {\n      s.value && (e == null || e.onScrollButtonChange(s.value));\n    }), (i, r) => l.value ? (h(), b(sa, {\n      key: 0,\n      ref_key: \"primitiveElement\",\n      ref: n,\n      onAutoScroll: r[0] || (r[0] = () => {\n        const { viewport: u, selectedItem: d } = a(t);\n        u != null && u.value && (d != null && d.value) && (u.value.scrollTop = u.value.scrollTop + d.value.offsetHeight);\n      })\n    }, {\n      default: v(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 512)) : J(\"\", !0);\n  }\n}), Sc = /* @__PURE__ */ g({\n  __name: \"SelectValue\",\n  props: {\n    placeholder: { default: \"\" },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const { primitiveElement: t, currentElement: e } = V(), n = De(), s = Cn();\n    return bn(() => {\n      var i;\n      const l = !!Ot((i = s == null ? void 0 : s.default) == null ? void 0 : i.call(s)).length;\n      n.onValueElementHasChildrenChange(l);\n    }), U(() => {\n      n.valueElement = e;\n    }), (l, i) => (h(), b(a(D), {\n      ref_key: \"primitiveElement\",\n      ref: t,\n      as: l.as,\n      \"as-child\": l.asChild,\n      style: { pointerEvents: \"none\" }\n    }, {\n      default: v(() => {\n        var r;\n        return [\n          a(na)((r = a(n).modelValue) == null ? void 0 : r.value) ? (h(), Q(ie, { key: 0 }, [\n            ue(Le(l.placeholder), 1)\n          ], 64)) : y(l.$slots, \"default\", { key: 1 })\n        ];\n      }),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), Tc = /* @__PURE__ */ g({\n  __name: \"SelectIcon\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    return (t, e) => (h(), b(a(D), {\n      \"aria-hidden\": \"\",\n      as: t.as,\n      \"as-child\": t.asChild\n    }, {\n      default: v(() => [\n        y(t.$slots, \"default\", {}, () => [\n          ue(\"â–¼\")\n        ])\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), la = /* @__PURE__ */ g({\n  __name: \"BaseSeparator\",\n  props: {\n    orientation: { default: \"horizontal\" },\n    decorative: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = [\"horizontal\", \"vertical\"];\n    function n(r) {\n      return e.includes(r);\n    }\n    const s = S(\n      () => n(t.orientation) ? t.orientation : \"horizontal\"\n    ), l = S(\n      () => s.value === \"vertical\" ? t.orientation : void 0\n    ), i = S(\n      () => t.decorative ? { role: \"none\" } : { \"aria-orientation\": l.value, role: \"separator\" }\n    );\n    return (r, u) => (h(), b(a(D), T({\n      as: r.as,\n      \"as-child\": r.asChild,\n      \"data-orientation\": s.value\n    }, i.value), {\n      default: v(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"as\", \"as-child\", \"data-orientation\"]));\n  }\n}), Dc = /* @__PURE__ */ g({\n  __name: \"Separator\",\n  props: {\n    orientation: { default: \"horizontal\" },\n    decorative: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(la, R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n});\nfunction ia(o, [t, e]) {\n  return Math.min(e, Math.max(t, o));\n}\nfunction Ji(o = [], t, e) {\n  const n = [...o];\n  return n[e] = t, n.sort((s, l) => s - l);\n}\nfunction ra(o, t, e) {\n  const l = 100 / (e - t) * (o - t);\n  return ia(l, [0, 100]);\n}\nfunction Zi(o, t) {\n  return t > 2 ? `Value ${o + 1} of ${t}` : t === 2 ? [\"Minimum\", \"Maximum\"][o] : void 0;\n}\nfunction Qi(o, t) {\n  if (o.length === 1)\n    return 0;\n  const e = o.map((s) => Math.abs(s - t)), n = Math.min(...e);\n  return e.indexOf(n);\n}\nfunction er(o, t, e) {\n  const n = o / 2, l = Zo([0, 50], [0, n]);\n  return (n - l(t) * e) * e;\n}\nfunction tr(o) {\n  return o.slice(0, -1).map((t, e) => o[e + 1] - t);\n}\nfunction or(o, t) {\n  if (t > 0) {\n    const e = tr(o);\n    return Math.min(...e) >= t;\n  }\n  return !0;\n}\nfunction Zo(o, t) {\n  return (e) => {\n    if (o[0] === o[1] || t[0] === t[1])\n      return t[0];\n    const n = (t[1] - t[0]) / (o[1] - o[0]);\n    return t[0] + n * (e - o[0]);\n  };\n}\nfunction nr(o) {\n  return (String(o).split(\".\")[1] || \"\").length;\n}\nfunction ar(o, t) {\n  const e = 10 ** t;\n  return Math.round(o * e) / e;\n}\nconst ua = [\"PageUp\", \"PageDown\"], da = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"], ca = {\n  \"from-left\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowLeft\"],\n  \"from-right\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowRight\"],\n  \"from-bottom\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowLeft\"],\n  \"from-top\": [\"Home\", \"PageDown\", \"ArrowUp\", \"ArrowLeft\"]\n}, [pa, fa] = H([\"SliderVertical\", \"SliderHorizontal\"]), va = /* @__PURE__ */ g({\n  __name: \"SliderImpl\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  emits: [\"slideStart\", \"slideMove\", \"slideEnd\", \"homeKeyDown\", \"endKeyDown\", \"stepKeyDown\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = Ht();\n    return (l, i) => (h(), b(a(D), T({ \"data-slider-impl\": \"\" }, e, {\n      onKeydown: i[0] || (i[0] = (r) => {\n        r.key === \"Home\" ? (n(\"homeKeyDown\", r), r.preventDefault()) : r.key === \"End\" ? (n(\"endKeyDown\", r), r.preventDefault()) : a(ua).concat(a(da)).includes(r.key) && (n(\"stepKeyDown\", r), r.preventDefault());\n      }),\n      onPointerdown: i[1] || (i[1] = (r) => {\n        const u = r.target;\n        u.setPointerCapture(r.pointerId), r.preventDefault(), a(s).thumbElements.value.includes(u) ? u.focus() : n(\"slideStart\", r);\n      }),\n      onPointermove: i[2] || (i[2] = (r) => {\n        r.target.hasPointerCapture(r.pointerId) && n(\"slideMove\", r);\n      }),\n      onPointerup: i[3] || (i[3] = (r) => {\n        const u = r.target;\n        u.hasPointerCapture(r.pointerId) && (u.releasePointerCapture(r.pointerId), n(\"slideEnd\", r));\n      })\n    }), {\n      default: v(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), sr = /* @__PURE__ */ g({\n  __name: \"SliderHorizontal\",\n  props: {\n    dir: {},\n    min: {},\n    max: {},\n    inverted: { type: Boolean }\n  },\n  emits: [\"slideEnd\", \"slideStart\", \"slideMove\", \"homeKeyDown\", \"endKeyDown\", \"stepKeyDown\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { max: s, min: l, dir: i, inverted: r } = z(e), { primitiveElement: u, currentElement: d } = V(), c = B(), p = S(() => (i == null ? void 0 : i.value) === \"ltr\" && !r.value || (i == null ? void 0 : i.value) !== \"ltr\" && r.value);\n    function f(m) {\n      const C = c.value || d.value.getBoundingClientRect(), w = [0, C.width], $ = p.value ? [l.value, s.value] : [s.value, l.value], _ = Zo(w, $);\n      return c.value = C, _(m - C.left);\n    }\n    return fa({\n      startEdge: p.value ? \"left\" : \"right\",\n      endEdge: p.value ? \"right\" : \"left\",\n      direction: p.value ? 1 : -1,\n      size: \"width\"\n    }), (m, C) => (h(), b(va, {\n      ref_key: \"primitiveElement\",\n      ref: u,\n      dir: a(i),\n      \"data-orientation\": \"horizontal\",\n      style: ae({\n        \"--radix-slider-thumb-transform\": \"translateX(-50%)\"\n      }),\n      onSlideStart: C[0] || (C[0] = (w) => {\n        const $ = f(w.clientX);\n        n(\"slideStart\", $);\n      }),\n      onSlideMove: C[1] || (C[1] = (w) => {\n        const $ = f(w.clientX);\n        n(\"slideMove\", $);\n      }),\n      onSlideEnd: C[2] || (C[2] = () => {\n        c.value = void 0, n(\"slideEnd\");\n      }),\n      onStepKeyDown: C[3] || (C[3] = (w) => {\n        const $ = p.value ? \"from-left\" : \"from-right\", _ = a(ca)[$].includes(w.key);\n        n(\"stepKeyDown\", w, _ ? -1 : 1);\n      }),\n      onEndKeyDown: C[4] || (C[4] = (w) => n(\"endKeyDown\", w)),\n      onHomeKeyDown: C[5] || (C[5] = (w) => n(\"homeKeyDown\", w))\n    }, {\n      default: v(() => [\n        y(m.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"dir\", \"style\"]));\n  }\n}), lr = /* @__PURE__ */ g({\n  __name: \"SliderVertical\",\n  props: {\n    min: {},\n    max: {},\n    inverted: { type: Boolean }\n  },\n  emits: [\"slideEnd\", \"slideStart\", \"slideMove\", \"homeKeyDown\", \"endKeyDown\", \"stepKeyDown\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { max: s, min: l, inverted: i } = z(e), { primitiveElement: r, currentElement: u } = V(), d = B(), c = S(() => !i.value);\n    function p(f) {\n      const m = d.value || u.value.getBoundingClientRect(), C = [0, m.height], w = c.value ? [s.value, l.value] : [l.value, s.value], $ = Zo(C, w);\n      return d.value = m, $(f - m.top);\n    }\n    return fa({\n      startEdge: c.value ? \"bottom\" : \"top\",\n      endEdge: c.value ? \"top\" : \"bottom\",\n      size: \"height\",\n      direction: c.value ? 1 : -1\n    }), (f, m) => (h(), b(va, {\n      ref_key: \"primitiveElement\",\n      ref: r,\n      \"data-orientation\": \"vertical\",\n      style: ae({\n        \"--radix-slider-thumb-transform\": \"translateY(50%)\"\n      }),\n      onSlideStart: m[0] || (m[0] = (C) => {\n        const w = p(C.clientY);\n        n(\"slideStart\", w);\n      }),\n      onSlideMove: m[1] || (m[1] = (C) => {\n        const w = p(C.clientY);\n        n(\"slideMove\", w);\n      }),\n      onSlideEnd: m[2] || (m[2] = () => {\n        d.value = void 0, n(\"slideEnd\");\n      }),\n      onStepKeyDown: m[3] || (m[3] = (C) => {\n        const w = c.value ? \"from-bottom\" : \"from-top\", $ = a(ca)[w].includes(C.key);\n        n(\"stepKeyDown\", C, $ ? -1 : 1);\n      }),\n      onEndKeyDown: m[4] || (m[4] = (C) => n(\"endKeyDown\", C)),\n      onHomeKeyDown: m[5] || (m[5] = (C) => n(\"homeKeyDown\", C))\n    }, {\n      default: v(() => [\n        y(f.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"style\"]));\n  }\n}), ir = [\"value\", \"name\", \"disabled\"], [Ht, rr] = H(\"SliderRoot\"), Oc = /* @__PURE__ */ g({\n  inheritAttrs: !1,\n  __name: \"SliderRoot\",\n  props: {\n    name: {},\n    defaultValue: { default: () => [0] },\n    modelValue: {},\n    disabled: { type: Boolean, default: !1 },\n    orientation: { default: \"horizontal\" },\n    dir: {},\n    inverted: { type: Boolean, default: !1 },\n    min: { default: 0 },\n    max: { default: 100 },\n    step: { default: 1 },\n    minStepsBetweenThumbs: { default: 0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"valueCommit\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { min: s, max: l, step: i, minStepsBetweenThumbs: r, orientation: u, disabled: d, dir: c } = z(e), p = de(c), { createCollection: f } = re(\"sliderThumb\"), { primitiveElement: m, currentElement: C } = V();\n    f(C);\n    const w = Ke(C), $ = X(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), _ = B(0), E = B($.value);\n    function x(M) {\n      const W = Qi($.value, M);\n      A(M, W);\n    }\n    function P(M) {\n      A(M, _.value);\n    }\n    function I() {\n      const M = E.value[_.value];\n      $.value[_.value] !== M && n(\"valueCommit\", $.value);\n    }\n    function A(M, W, { commit: O } = { commit: !1 }) {\n      var q;\n      const K = nr(i.value), j = ar(Math.round((M - s.value) / i.value) * i.value + s.value, K), Z = ia(j, [s.value, l.value]), F = Ji($.value, Z, W);\n      if (or(F, r.value * i.value)) {\n        _.value = F.indexOf(Z);\n        const oe = String(F) !== String($.value);\n        oe && O && n(\"valueCommit\", F), oe && ((q = L.value[_.value]) == null || q.focus(), $.value = F);\n      }\n    }\n    const L = B([]);\n    return rr({\n      modelValue: $,\n      valueIndexToChangeRef: _,\n      thumbElements: L,\n      orientation: u,\n      min: s,\n      max: l,\n      disabled: d\n    }), (M, W) => (h(), Q(ie, null, [\n      (h(), b($e(a(u) === \"horizontal\" ? sr : lr), T(M.$attrs, {\n        ref_key: \"primitiveElement\",\n        ref: m,\n        \"as-child\": M.asChild,\n        as: M.as,\n        min: a(s),\n        max: a(l),\n        dir: a(p),\n        inverted: M.inverted,\n        \"aria-disabled\": a(d),\n        \"data-disabled\": a(d),\n        onPointerdown: W[0] || (W[0] = () => {\n          a(d) || (E.value = a($));\n        }),\n        onSlideStart: W[1] || (W[1] = (O) => !a(d) && x(O)),\n        onSlideMove: W[2] || (W[2] = (O) => !a(d) && P(O)),\n        onSlideEnd: W[3] || (W[3] = (O) => !a(d) && I),\n        onHomeKeyDown: W[4] || (W[4] = (O) => !a(d) && A(a(s), 0, { commit: !0 })),\n        onEndKeyDown: W[5] || (W[5] = (O) => !a(d) && A(a(l), a($).length - 1, { commit: !0 })),\n        onStepKeyDown: W[6] || (W[6] = (O, K) => {\n          if (!a(d)) {\n            const F = a(ua).includes(O.key) || O.shiftKey && a(da).includes(O.key) ? 10 : 1, q = _.value, oe = a($)[q], tt = a(i) * F * K;\n            A(oe + tt, q, { commit: !0 });\n          }\n        })\n      }), {\n        default: v(() => [\n          y(M.$slots, \"default\", { modelValue: a($) })\n        ]),\n        _: 3\n      }, 16, [\"as-child\", \"as\", \"min\", \"max\", \"dir\", \"inverted\", \"aria-disabled\", \"data-disabled\"])),\n      a(w) ? (h(!0), Q(ie, { key: 0 }, po(a($), (O, K) => (h(), Q(\"input\", {\n        key: K,\n        value: O,\n        type: \"number\",\n        style: { display: \"none\" },\n        name: M.name ? M.name + (a($).length > 1 ? \"[]\" : \"\") : void 0,\n        disabled: a(d)\n      }, null, 8, ir))), 128)) : J(\"\", !0)\n    ], 64));\n  }\n}), ur = /* @__PURE__ */ g({\n  inheritAttrs: !1,\n  __name: \"SliderThumbImpl\",\n  props: {\n    index: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o, { expose: t }) {\n    const e = o, n = Ht(), s = pa(), { primitiveElement: l, currentElement: i } = V(), r = S(() => {\n      var C, w;\n      return (w = (C = n.modelValue) == null ? void 0 : C.value) == null ? void 0 : w[e.index];\n    }), u = S(() => r.value === void 0 ? 0 : ra(r.value, n.min.value ?? 0, n.max.value ?? 100)), d = S(() => {\n      var C, w;\n      return Zi(e.index, ((w = (C = n.modelValue) == null ? void 0 : C.value) == null ? void 0 : w.length) ?? 0);\n    }), c = xn(i), p = S(() => c[s.size].value), f = S(() => p.value ? er(p.value, u.value, s.direction) : 0), m = Dt();\n    return U(() => {\n      n.thumbElements.value.push(i.value);\n    }), fe(() => {\n      const C = n.thumbElements.value.findIndex((w) => w === i.value) ?? -1;\n      n.thumbElements.value.splice(C, 1);\n    }), t({\n      $el: i\n    }), (C, w) => (h(), b(a(D), T(C.$attrs, {\n      ref_key: \"primitiveElement\",\n      ref: l,\n      role: \"slider\",\n      \"data-radix-vue-collection-item\": \"\",\n      tabindex: a(n).disabled.value ? void 0 : 0,\n      \"aria-label\": C.$attrs[\"aria-label\"] || d.value,\n      \"data-disabled\": a(n).disabled.value,\n      \"data-orientation\": a(n).orientation.value,\n      \"aria-valuenow\": r.value,\n      \"aria-valuemin\": a(n).min.value,\n      \"aria-valuemax\": a(n).max.value,\n      \"aria-orientation\": a(n).orientation.value,\n      \"as-child\": C.asChild,\n      as: C.as,\n      style: {\n        transform: \"var(--radix-slider-thumb-transform)\",\n        position: \"absolute\",\n        [a(s).startEdge]: `calc(${u.value}% + ${f.value}px)`,\n        /**\n         * There will be no value on initial render while we work out the index so we hide thumbs\n         * without a value, otherwise SSR will render them in the wrong position before they\n         * snap into the correct position during hydration which would be visually jarring for\n         * slower connections.\n         */\n        display: !a(m) && r.value === void 0 ? \"none\" : void 0\n      },\n      onFocus: w[0] || (w[0] = () => {\n        a(n).valueIndexToChangeRef.value = C.index;\n      })\n    }), {\n      default: v(() => [\n        y(C.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"tabindex\", \"aria-label\", \"data-disabled\", \"data-orientation\", \"aria-valuenow\", \"aria-valuemin\", \"aria-valuemax\", \"aria-orientation\", \"as-child\", \"as\", \"style\"]));\n  }\n}), Ic = /* @__PURE__ */ g({\n  __name: \"SliderThumb\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { injectCollection: e } = re(\"sliderThumb\"), n = e(), { primitiveElement: s, currentElement: l } = V(), i = S(() => l.value ? n.value.findIndex((r) => r === l.value) : -1);\n    return (r, u) => (h(), b(ur, T({\n      ref_key: \"primitiveElement\",\n      ref: s\n    }, t, { index: i.value }), {\n      default: v(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"index\"]));\n  }\n}), Ac = /* @__PURE__ */ g({\n  __name: \"SliderTrack\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = o, e = Ht();\n    return (n, s) => (h(), b(a(D), {\n      \"as-child\": t.asChild,\n      as: n.as,\n      \"data-disabled\": a(e).disabled.value,\n      \"data-orientation\": a(e).orientation.value\n    }, {\n      default: v(() => [\n        y(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"data-disabled\", \"data-orientation\"]));\n  }\n}), Mc = /* @__PURE__ */ g({\n  __name: \"SliderRange\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = Ht(), e = pa(), n = S(() => {\n      var i, r;\n      return (r = (i = t.modelValue) == null ? void 0 : i.value) == null ? void 0 : r.map(\n        (u) => ra(u, t.min.value, t.max.value)\n      );\n    }), s = S(() => t.modelValue.value.length > 1 ? Math.min(...n.value) : 0), l = S(() => 100 - Math.max(...n.value));\n    return (i, r) => (h(), b(a(D), {\n      \"data-disabled\": a(t).disabled.value,\n      \"data-orientation\": a(t).orientation.value,\n      \"as-child\": i.asChild,\n      as: i.as,\n      style: ae({\n        [a(e).startEdge]: `${s.value}%`,\n        [a(e).endEdge]: `${l.value}%`\n      })\n    }, {\n      default: v(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"data-disabled\", \"data-orientation\", \"as-child\", \"as\", \"style\"]));\n  }\n}), dr = [\"name\", \"disabled\", \"required\", \"value\", \"checked\", \"data-state\", \"data-disabled\"], [cr, pr] = H(\"SwitchRoot\"), kc = /* @__PURE__ */ g({\n  __name: \"SwitchRoot\",\n  props: {\n    defaultChecked: { type: Boolean },\n    checked: { type: Boolean, default: void 0 },\n    disabled: { type: Boolean },\n    required: { type: Boolean },\n    name: {},\n    id: {},\n    value: { default: \"on\" },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:checked\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { disabled: s } = z(e), l = X(e, \"checked\", n, {\n      defaultValue: e.defaultChecked,\n      passive: e.checked === void 0\n    });\n    function i() {\n      s.value || (l.value = !l.value);\n    }\n    const { primitiveElement: r, currentElement: u } = V(), d = Ke(u), c = S(() => {\n      var p;\n      return e.id && u.value ? (p = document.querySelector(`[for=\"${e.id}\"]`)) == null ? void 0 : p.innerText : void 0;\n    });\n    return pr({\n      checked: l,\n      toggleCheck: i,\n      disabled: s\n    }), (p, f) => (h(), Q(ie, null, [\n      k(a(D), T(p.$attrs, {\n        id: p.id,\n        ref_key: \"primitiveElement\",\n        ref: r,\n        role: \"switch\",\n        type: p.as === \"button\" ? \"button\" : void 0,\n        value: p.value,\n        \"aria-label\": p.$attrs[\"aria-label\"] || c.value,\n        \"aria-checked\": a(l),\n        \"aria-required\": p.required,\n        \"data-state\": a(l) ? \"checked\" : \"unchecked\",\n        \"data-disabled\": a(s) ? \"\" : void 0,\n        \"as-child\": p.asChild,\n        as: p.as,\n        disabled: a(s),\n        onClick: i,\n        onKeydown: le(ne(i, [\"prevent\"]), [\"enter\"])\n      }), {\n        default: v(() => [\n          y(p.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\", \"type\", \"value\", \"aria-label\", \"aria-checked\", \"aria-required\", \"data-state\", \"data-disabled\", \"as-child\", \"as\", \"disabled\", \"onKeydown\"]),\n      a(d) ? (h(), Q(\"input\", {\n        key: 0,\n        type: \"checkbox\",\n        name: p.name,\n        tabindex: \"-1\",\n        \"aria-hidden\": \"\",\n        disabled: a(s),\n        required: p.required,\n        value: p.value,\n        checked: !!a(l),\n        \"data-state\": a(l) ? \"checked\" : \"unchecked\",\n        \"data-disabled\": a(s) ? \"\" : void 0,\n        style: ae({\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        })\n      }, null, 12, dr)) : J(\"\", !0)\n    ], 64));\n  }\n}), Rc = /* @__PURE__ */ g({\n  __name: \"SwitchThumb\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = cr();\n    return (e, n) => {\n      var s;\n      return h(), b(a(D), {\n        \"data-state\": (s = a(t).checked) != null && s.value ? \"checked\" : \"unchecked\",\n        \"data-disabled\": a(t).disabled.value ? \"\" : void 0,\n        \"as-child\": e.asChild,\n        as: e.as\n      }, {\n        default: v(() => [\n          y(e.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"data-state\", \"data-disabled\", \"as-child\", \"as\"]);\n    };\n  }\n}), [Wt, fr] = H(\"TabsRoot\"), Vc = /* @__PURE__ */ g({\n  __name: \"TabsRoot\",\n  props: {\n    defaultValue: {},\n    orientation: { default: \"horizontal\" },\n    dir: {},\n    activationMode: { default: \"automatic\" },\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { orientation: s, dir: l } = z(e), i = de(l), r = X(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), u = B();\n    return fr({\n      modelValue: r,\n      changeModelValue: (d) => {\n        r.value = d;\n      },\n      orientation: s,\n      dir: i,\n      activationMode: e.activationMode,\n      baseId: te(),\n      tabsList: u\n    }), (d, c) => (h(), b(a(D), {\n      dir: a(i),\n      \"data-orientation\": a(s),\n      \"as-child\": d.asChild,\n      as: d.as\n    }, {\n      default: v(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"dir\", \"data-orientation\", \"as-child\", \"as\"]));\n  }\n}), Fc = /* @__PURE__ */ g({\n  __name: \"TabsList\",\n  props: {\n    loop: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { loop: e } = z(t), n = Wt();\n    return (s, l) => (h(), b(a(Je), {\n      \"as-child\": \"\",\n      orientation: a(n).orientation.value,\n      dir: a(n).dir.value,\n      loop: a(e)\n    }, {\n      default: v(() => [\n        k(a(D), {\n          ref: (i) => {\n            i && \"$el\" in i && (a(n).tabsList.value = i.$el);\n          },\n          role: \"tablist\",\n          \"as-child\": s.asChild,\n          as: s.as,\n          \"aria-orientation\": a(n).orientation.value\n        }, {\n          default: v(() => [\n            y(s.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as-child\", \"as\", \"aria-orientation\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n});\nfunction ma(o, t) {\n  return `${o}-trigger-${t}`;\n}\nfunction ha(o, t) {\n  return `${o}-content-${t}`;\n}\nconst Lc = /* @__PURE__ */ g({\n  __name: \"TabsContent\",\n  props: {\n    value: {},\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = Wt(), n = S(() => ma(e.baseId, t.value)), s = S(() => ha(e.baseId, t.value)), l = S(() => t.value === e.modelValue.value), i = B(l.value);\n    return U(() => {\n      requestAnimationFrame(() => {\n        i.value = !1;\n      });\n    }), (r, u) => (h(), b(a(se), {\n      present: l.value,\n      \"force-mount\": \"\"\n    }, {\n      default: v(({ present: d }) => [\n        k(a(D), {\n          id: s.value,\n          \"as-child\": r.asChild,\n          as: r.as,\n          role: \"tabpanel\",\n          \"data-state\": l.value ? \"active\" : \"inactive\",\n          \"data-orientation\": a(e).orientation.value,\n          \"aria-labelledby\": n.value,\n          hidden: !d.value,\n          tabindex: \"0\",\n          style: ae({\n            animationDuration: i.value ? \"0s\" : void 0\n          })\n        }, {\n          default: v(() => [\n            r.forceMount || l.value ? y(r.$slots, \"default\", { key: 0 }) : J(\"\", !0)\n          ]),\n          _: 2\n        }, 1032, [\"id\", \"as-child\", \"as\", \"data-state\", \"data-orientation\", \"aria-labelledby\", \"hidden\", \"style\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Kc = /* @__PURE__ */ g({\n  __name: \"TabsTrigger\",\n  props: {\n    value: {},\n    disabled: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = Wt(), n = S(() => ma(e.baseId, t.value)), s = S(() => ha(e.baseId, t.value)), l = S(() => t.value === e.modelValue.value);\n    return (i, r) => (h(), b(a(Ze), {\n      \"as-child\": \"\",\n      focusable: !i.disabled,\n      active: l.value\n    }, {\n      default: v(() => [\n        k(a(D), {\n          id: n.value,\n          role: \"tab\",\n          type: i.as === \"button\" ? \"button\" : void 0,\n          as: i.as,\n          \"as-child\": i.asChild,\n          \"aria-selected\": l.value ? \"true\" : \"false\",\n          \"aria-controls\": s.value,\n          \"data-state\": l.value ? \"active\" : \"inactive\",\n          disabled: i.disabled,\n          \"data-disabled\": i.disabled ? \"\" : void 0,\n          \"data-orientation\": a(e).orientation.value,\n          onMousedown: r[0] || (r[0] = ne((u) => {\n            !i.disabled && u.ctrlKey === !1 ? a(e).changeModelValue(i.value) : u.preventDefault();\n          }, [\"left\"])),\n          onKeydown: r[1] || (r[1] = le((u) => a(e).changeModelValue(i.value), [\"enter\", \"space\"])),\n          onFocus: r[2] || (r[2] = () => {\n            const u = a(e).activationMode !== \"manual\";\n            !l.value && !i.disabled && u && a(e).changeModelValue(i.value);\n          })\n        }, {\n          default: v(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"id\", \"type\", \"as\", \"as-child\", \"aria-selected\", \"aria-controls\", \"data-state\", \"disabled\", \"data-disabled\", \"data-orientation\"])\n      ]),\n      _: 3\n    }, 8, [\"focusable\", \"active\"]));\n  }\n}), Nc = /* @__PURE__ */ g({\n  __name: \"TabsIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = Wt(), n = B({\n      size: null,\n      position: null\n    });\n    return Y(() => e.modelValue.value, async (s) => {\n      var i;\n      await G();\n      const l = (i = e.tabsList.value) == null ? void 0 : i.querySelector('[role=\"tab\"][data-state=\"active\"]');\n      e.orientation.value === \"horizontal\" ? n.value = {\n        size: l.offsetWidth,\n        position: l.offsetLeft\n      } : n.value = {\n        size: l.offsetHeight,\n        position: l.offsetTop\n      };\n    }, { immediate: !0 }), (s, l) => (h(), b(a(D), T(t, {\n      style: {\n        \"--radix-tabs-indicator-size\": `${n.value.size}px`,\n        \"--radix-tabs-indicator-position\": `${n.value.position}px`\n      }\n    }), {\n      default: v(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"style\"]));\n  }\n}), [jt, vr] = H(\"TagsInputRoot\"), Hc = /* @__PURE__ */ g({\n  __name: \"TagsInputRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: { default: () => [] },\n    addOnPaste: { type: Boolean },\n    duplicate: { type: Boolean },\n    disabled: { type: Boolean },\n    delimiter: { default: \",\" },\n    dir: {},\n    max: { default: 0 },\n    required: { type: Boolean },\n    name: {},\n    id: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"invalid\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { addOnPaste: s, disabled: l, delimiter: i, max: r, id: u, dir: d } = z(e), c = de(d), p = X(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: !0,\n      deep: !0\n    }), { primitiveElement: f, currentElement: m } = V(), { focused: C } = ss(m), w = Ke(m), { getItems: $ } = Vn(), _ = B(), E = B(!1);\n    return vr({\n      modelValue: p,\n      onAddValue: (x) => {\n        if (p.value.length >= r.value && r.value)\n          return n(\"invalid\", x), !1;\n        if (e.duplicate)\n          return p.value.push(x), !0;\n        if (p.value.includes(x))\n          E.value = !0;\n        else\n          return p.value.push(x), !0;\n        return n(\"invalid\", x), !1;\n      },\n      onRemoveValue: (x) => {\n        x !== -1 && p.value.splice(x, 1);\n      },\n      onInputKeydown: (x) => {\n        const P = x.target, I = $().map((L) => L.ref).filter((L) => L.dataset.disabled !== \"\");\n        if (!I.length)\n          return;\n        const A = I.at(-1);\n        switch (x.key) {\n          case \"Delete\":\n          case \"Backspace\": {\n            if (P.selectionStart !== 0 || P.selectionEnd !== 0)\n              break;\n            if (_.value) {\n              const L = I.findIndex((M) => M === _.value);\n              p.value.splice(L, 1), _.value = _.value === A ? I.at(L - 1) : I.at(L + 1), x.preventDefault();\n            } else\n              x.key === \"Backspace\" && (_.value = A, x.preventDefault());\n            break;\n          }\n          case \"Home\":\n          case \"End\":\n          case \"ArrowRight\":\n          case \"ArrowLeft\": {\n            const L = x.key === \"ArrowRight\" && c.value === \"ltr\" || x.key === \"ArrowLeft\" && c.value === \"rtl\", M = !L;\n            if (P.selectionStart !== 0 || P.selectionEnd !== 0)\n              break;\n            if (M && !_.value)\n              _.value = A, x.preventDefault();\n            else if (L && A && _.value === A)\n              _.value = void 0, x.preventDefault();\n            else if (_.value) {\n              const W = qe(x, _.value, void 0, {\n                itemsArray: I,\n                loop: !1,\n                dir: c.value\n              });\n              W && (_.value = W), x.preventDefault();\n            }\n            break;\n          }\n          case \"ArrowUp\":\n          case \"ArrowDown\": {\n            _.value && x.preventDefault();\n            break;\n          }\n          default:\n            _.value = void 0;\n        }\n      },\n      selectedElement: _,\n      isInvalidInput: E,\n      addOnPaste: s,\n      dir: c,\n      disabled: l,\n      delimiter: i,\n      max: r,\n      id: u\n    }), (x, P) => (h(), b(a(Fn), null, {\n      default: v(() => [\n        k(a(D), {\n          ref_key: \"primitiveElement\",\n          ref: f,\n          dir: a(c),\n          as: x.as,\n          \"as-child\": x.asChild,\n          \"data-invalid\": E.value ? \"\" : void 0,\n          \"data-disabled\": a(l) ? \"\" : void 0,\n          \"data-focused\": a(C) ? \"\" : void 0\n        }, {\n          default: v(() => [\n            y(x.$slots, \"default\", { values: a(p) }),\n            a(w) && x.name ? (h(), b(a(Rn), {\n              key: 0,\n              name: x.name,\n              value: a(p),\n              required: x.required,\n              disabled: a(l)\n            }, null, 8, [\"name\", \"value\", \"required\", \"disabled\"])) : J(\"\", !0)\n          ]),\n          _: 3\n        }, 8, [\"dir\", \"as\", \"as-child\", \"data-invalid\", \"data-disabled\", \"data-focused\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Wc = /* @__PURE__ */ g({\n  __name: \"TagsInputInput\",\n  props: {\n    placeholder: {},\n    autoFocus: { type: Boolean },\n    maxLength: {},\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(o) {\n    const t = o, e = jt(), { primitiveElement: n, currentElement: s } = V();\n    async function l(u) {\n      if (await G(), u.defaultPrevented)\n        return;\n      const d = u.target;\n      if (!d.value)\n        return;\n      e.onAddValue(d.value) && (d.value = \"\"), u.preventDefault();\n    }\n    function i(u) {\n      e.isInvalidInput.value = !1;\n      const d = e.delimiter.value;\n      if (d === u.data) {\n        const c = u.target;\n        c.value = c.value.replaceAll(d, \"\"), e.onAddValue(c.value) && (c.value = \"\");\n      }\n    }\n    function r(u) {\n      if (e.addOnPaste.value) {\n        u.preventDefault();\n        const d = u.clipboardData;\n        if (!d)\n          return;\n        const c = d.getData(\"text\");\n        e.delimiter.value ? c.split(e.delimiter.value).forEach((f) => {\n          e.onAddValue(f);\n        }) : e.onAddValue(c);\n      }\n    }\n    return U(() => {\n      const u = s.value.nodeName === \"INPUT\" ? s.value : s.value.querySelector(\"input\");\n      u && setTimeout(() => {\n        t.autoFocus && (u == null || u.focus());\n      }, 1);\n    }), (u, d) => {\n      var c;\n      return h(), b(a(D), T(t, {\n        id: (c = a(e).id) == null ? void 0 : c.value,\n        ref_key: \"primitiveElement\",\n        ref: n,\n        type: \"text\",\n        autocomplete: \"off\",\n        autocorrect: \"off\",\n        autocapitalize: \"off\",\n        maxlength: u.maxLength,\n        disabled: a(e).disabled.value,\n        \"data-invalid\": a(e).isInvalidInput.value ? \"\" : void 0,\n        onInput: i,\n        onKeydown: [\n          le(l, [\"enter\"]),\n          a(e).onInputKeydown\n        ],\n        onPaste: r\n      }), {\n        default: v(() => [\n          y(u.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\", \"maxlength\", \"disabled\", \"data-invalid\", \"onKeydown\"]);\n    };\n  }\n}), [ya, mr] = H(\"TagsInputItem\"), jc = /* @__PURE__ */ g({\n  __name: \"TagsInputItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { value: e } = z(t), n = jt(), { primitiveElement: s, currentElement: l } = V(), i = S(() => n.selectedElement.value === l.value), r = te(), u = S(() => t.disabled || n.disabled.value);\n    return mr({\n      value: e,\n      isSelected: i,\n      disabled: u,\n      textId: r\n    }), (d, c) => (h(), b(a(Ln), null, {\n      default: v(() => [\n        k(a(D), {\n          ref_key: \"primitiveElement\",\n          ref: s,\n          as: d.as,\n          \"as-child\": d.asChild,\n          \"aria-labelledby\": a(r),\n          \"aria-current\": i.value,\n          \"data-disabled\": u.value ? \"\" : void 0,\n          \"data-state\": i.value ? \"active\" : \"inactive\"\n        }, {\n          default: v(() => [\n            y(d.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\", \"aria-labelledby\", \"aria-current\", \"data-disabled\", \"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), zc = /* @__PURE__ */ g({\n  __name: \"TagsInputItemText\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = o, e = ya();\n    return (n, s) => (h(), b(a(D), T(t, {\n      id: a(e).textId\n    }), {\n      default: v(() => [\n        y(n.$slots, \"default\", {}, () => [\n          ue(Le(a(e).value.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), Uc = /* @__PURE__ */ g({\n  __name: \"TagsInputItemDelete\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = jt(), n = ya(), s = S(() => {\n      var i;\n      return ((i = n.disabled) == null ? void 0 : i.value) || e.disabled.value;\n    });\n    function l() {\n      if (s.value)\n        return;\n      const i = e.modelValue.value.findIndex((r) => r === n.value.value);\n      e.onRemoveValue(i);\n    }\n    return (i, r) => (h(), b(a(D), T({ tabindex: \"-1\" }, t, {\n      \"aria-labelledby\": a(n).textId,\n      \"aria-current\": a(n).isSelected.value,\n      \"data-state\": a(n).isSelected.value ? \"active\" : \"inactive\",\n      \"data-disabled\": s.value ? \"\" : void 0,\n      type: i.as === \"button\" ? \"button\" : void 0,\n      onClick: l\n    }), {\n      default: v(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-labelledby\", \"aria-current\", \"data-state\", \"data-disabled\", \"type\"]));\n  }\n}), qc = /* @__PURE__ */ g({\n  __name: \"TagsInputClear\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = jt();\n    function n() {\n      e.disabled.value || (e.modelValue.value = []);\n    }\n    return (s, l) => (h(), b(a(D), T(t, {\n      type: s.as === \"button\" ? \"button\" : void 0,\n      \"data-disabled\": a(e).disabled.value ? \"\" : void 0,\n      onClick: n\n    }), {\n      default: v(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"data-disabled\"]));\n  }\n}), [zt, hr] = H(\"ToastProvider\"), Gc = /* @__PURE__ */ g({\n  __name: \"ToastProvider\",\n  props: {\n    label: { default: \"Notification\" },\n    duration: { default: 5e3 },\n    swipeDirection: { default: \"right\" },\n    swipeThreshold: { default: 50 }\n  },\n  setup(o) {\n    const t = o, { label: e, duration: n, swipeDirection: s, swipeThreshold: l } = z(t), i = B(), r = B(0), u = B(!1), d = B(!1);\n    if (t.label && typeof t.label == \"string\" && !t.label.trim()) {\n      const c = \"Invalid prop `label` supplied to `ToastProvider`. Expected non-empty `string`.\";\n      throw new Error(c);\n    }\n    return hr({\n      label: e,\n      duration: n,\n      swipeDirection: s,\n      swipeThreshold: l,\n      toastCount: r,\n      viewport: i,\n      onViewportChange(c) {\n        i.value = c;\n      },\n      onToastAdd() {\n        r.value++;\n      },\n      onToastRemove() {\n        r.value--;\n      },\n      isFocusedToastEscapeKeyDownRef: u,\n      isClosePausedRef: d\n    }), (c, p) => y(c.$slots, \"default\");\n  }\n}), yr = \"toast.swipeStart\", gr = \"toast.swipeMove\", br = \"toast.swipeCancel\", Cr = \"toast.swipeEnd\", _r = [\"F8\"], io = \"toast.viewportPause\", ro = \"toast.viewportResume\";\nfunction xt(o, t, e) {\n  const n = e.originalEvent.currentTarget, s = new CustomEvent(o, {\n    bubbles: !1,\n    cancelable: !0,\n    detail: e\n  });\n  t && n.addEventListener(o, t, { once: !0 }), n.dispatchEvent(s);\n}\nfunction dn(o, t, e = 0) {\n  const n = Math.abs(o.x), s = Math.abs(o.y), l = n > s;\n  return t === \"left\" || t === \"right\" ? l && n > e : !l && s > e;\n}\nfunction wr(o) {\n  return o.nodeType === o.ELEMENT_NODE;\n}\nfunction ga(o) {\n  const t = [];\n  return Array.from(o.childNodes).forEach((n) => {\n    if (n.nodeType === n.TEXT_NODE && n.textContent && t.push(n.textContent), wr(n)) {\n      const s = n.ariaHidden || n.hidden || n.style.display === \"none\", l = n.dataset.radixToastAnnounceExclude === \"\";\n      if (!s)\n        if (l) {\n          const i = n.dataset.radixToastAnnounceAlt;\n          i && t.push(i);\n        } else\n          t.push(...ga(n));\n    }\n  }), t;\n}\nconst Er = /* @__PURE__ */ g({\n  __name: \"ToastAnnounce\",\n  setup(o) {\n    const t = zt(), e = Za(1e3), n = B(!1);\n    return ns(() => {\n      n.value = !0;\n    }), (s, l) => a(e) || n.value ? (h(), b(a(Xe), { key: 0 }, {\n      default: v(() => [\n        ue(Le(a(t).label.value) + \" \", 1),\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    })) : J(\"\", !0);\n  }\n}), [xr, $r] = H(\"ToastRoot\"), Br = /* @__PURE__ */ g({\n  inheritAttrs: !1,\n  __name: \"ToastRootImpl\",\n  props: {\n    type: {},\n    open: { type: Boolean, default: !1 },\n    duration: {},\n    asChild: { type: Boolean },\n    as: { default: \"li\" }\n  },\n  emits: [\"close\", \"escapeKeyDown\", \"pause\", \"resume\", \"swipeStart\", \"swipeMove\", \"swipeCancel\", \"swipeEnd\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = be(), { primitiveElement: l, currentElement: i } = V(), r = zt(), u = B(null), d = B(null), c = S(() => e.duration || r.duration.value), p = B(0), f = B(c.value), m = B(0);\n    function C(_) {\n      !_ || _ === Number.POSITIVE_INFINITY || (window.clearTimeout(m.value), p.value = (/* @__PURE__ */ new Date()).getTime(), m.value = window.setTimeout(w, _));\n    }\n    function w() {\n      var E, x;\n      ((E = i.value) == null ? void 0 : E.contains(document.activeElement)) && ((x = r.viewport.value) == null || x.focus()), n(\"close\");\n    }\n    const $ = S(() => i.value ? ga(i.value) : null);\n    if (e.type && ![\"foreground\", \"background\"].includes(e.type)) {\n      const _ = \"Invalid prop `type` supplied to `Toast`. Expected `foreground | background`.\";\n      throw new Error(_);\n    }\n    return ee((_) => {\n      const E = r.viewport.value;\n      if (E) {\n        const x = () => {\n          C(f.value), n(\"resume\");\n        }, P = () => {\n          const I = (/* @__PURE__ */ new Date()).getTime() - p.value;\n          f.value = f.value - I, window.clearTimeout(m.value), n(\"pause\");\n        };\n        return E.addEventListener(io, P), E.addEventListener(ro, x), () => {\n          E.removeEventListener(io, P), E.removeEventListener(ro, x);\n        };\n      }\n    }), ee(() => {\n      e.open && !r.isClosePausedRef.value && C(c.value);\n    }), bo(\"Escape\", (_) => {\n      n(\"escapeKeyDown\", _), _.defaultPrevented || (r.isFocusedToastEscapeKeyDownRef.value = !0, w());\n    }), U(() => {\n      r.onToastAdd();\n    }), fe(() => {\n      r.onToastRemove();\n    }), $r({ onClose: w }), (_, E) => (h(), Q(ie, null, [\n      $.value ? (h(), b(Er, {\n        key: 0,\n        role: \"status\",\n        \"aria-live\": _.type === \"foreground\" ? \"assertive\" : \"polite\",\n        \"aria-atomic\": \"\"\n      }, {\n        default: v(() => [\n          ue(Le($.value), 1)\n        ]),\n        _: 1\n      }, 8, [\"aria-live\"])) : J(\"\", !0),\n      (h(), b(Ue, {\n        to: a(r).viewport.value\n      }, [\n        k(a(D), T({\n          ref: (x) => {\n            a(s)(x), l.value = x;\n          },\n          role: \"status\",\n          \"aria-live\": \"off\",\n          \"aria-atomic\": \"\",\n          tabindex: \"0\",\n          \"data-radix-vue-collection-item\": \"\"\n        }, _.$attrs, {\n          as: _.as,\n          \"as-child\": _.asChild,\n          \"data-state\": _.open ? \"open\" : \"closed\",\n          \"data-swipe-direction\": a(r).swipeDirection.value,\n          style: { userSelect: \"none\", touchAction: \"none\" },\n          onPointerdown: E[0] || (E[0] = ne((x) => {\n            u.value = { x: x.clientX, y: x.clientY };\n          }, [\"left\"])),\n          onPointermove: E[1] || (E[1] = (x) => {\n            if (!u.value)\n              return;\n            const P = x.clientX - u.value.x, I = x.clientY - u.value.y, A = !!d.value, L = [\"left\", \"right\"].includes(a(r).swipeDirection.value), M = [\"left\", \"up\"].includes(a(r).swipeDirection.value) ? Math.min : Math.max, W = L ? M(0, P) : 0, O = L ? 0 : M(0, I), K = x.pointerType === \"touch\" ? 10 : 2, j = { x: W, y: O }, Z = { originalEvent: x, delta: j };\n            A ? (d.value = j, a(xt)(a(gr), (F) => n(\"swipeMove\", F), Z)) : a(dn)(j, a(r).swipeDirection.value, K) ? (d.value = j, a(xt)(a(yr), (F) => n(\"swipeStart\", F), Z), x.target.setPointerCapture(x.pointerId)) : (Math.abs(P) > K || Math.abs(I) > K) && (u.value = null);\n          }),\n          onPointerup: E[2] || (E[2] = (x) => {\n            const P = d.value, I = x.target;\n            if (I.hasPointerCapture(x.pointerId) && I.releasePointerCapture(x.pointerId), d.value = null, u.value = null, P) {\n              const A = x.currentTarget, L = { originalEvent: x, delta: P };\n              a(dn)(P, a(r).swipeDirection.value, a(r).swipeThreshold.value) ? a(xt)(a(Cr), (M) => n(\"swipeEnd\", M), L) : a(xt)(a(br), (M) => n(\"swipeCancel\", M), L), A == null || A.addEventListener(\"click\", (M) => M.preventDefault(), {\n                once: !0\n              });\n            }\n          })\n        }), {\n          default: v(() => [\n            y(_.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\", \"data-state\", \"data-swipe-direction\"])\n      ], 8, [\"to\"]))\n    ], 64));\n  }\n}), Yc = /* @__PURE__ */ g({\n  __name: \"ToastRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !0 },\n    forceMount: { type: Boolean },\n    type: { default: \"foreground\" },\n    open: { type: Boolean, default: void 0 },\n    duration: {},\n    asChild: { type: Boolean },\n    as: { default: \"li\" }\n  },\n  emits: [\"close\", \"escapeKeyDown\", \"pause\", \"resume\", \"swipeStart\", \"swipeMove\", \"swipeCancel\", \"swipeEnd\", \"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = X(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    });\n    return (l, i) => (h(), b(a(se), {\n      present: l.forceMount || a(s)\n    }, {\n      default: v(() => [\n        k(Br, T({\n          open: a(s),\n          type: l.type,\n          as: l.as,\n          \"as-child\": l.asChild,\n          duration: l.duration\n        }, l.$attrs, {\n          onClose: i[0] || (i[0] = (r) => s.value = !1),\n          onPause: i[1] || (i[1] = (r) => n(\"pause\")),\n          onResume: i[2] || (i[2] = (r) => n(\"resume\")),\n          onEscapeKeyDown: i[3] || (i[3] = (r) => n(\"escapeKeyDown\", r)),\n          onSwipeStart: i[4] || (i[4] = (r) => {\n            n(\"swipeStart\", r), r.currentTarget.setAttribute(\"data-swipe\", \"start\");\n          }),\n          onSwipeMove: i[5] || (i[5] = (r) => {\n            const { x: u, y: d } = r.detail.delta, c = r.currentTarget;\n            c.setAttribute(\"data-swipe\", \"move\"), c.style.setProperty(\"--radix-toast-swipe-move-x\", `${u}px`), c.style.setProperty(\"--radix-toast-swipe-move-y\", `${d}px`);\n          }),\n          onSwipeCancel: i[6] || (i[6] = (r) => {\n            const u = r.currentTarget;\n            u.setAttribute(\"data-swipe\", \"cancel\"), u.style.removeProperty(\"--radix-toast-swipe-move-x\"), u.style.removeProperty(\"--radix-toast-swipe-move-y\"), u.style.removeProperty(\"--radix-toast-swipe-end-x\"), u.style.removeProperty(\"--radix-toast-swipe-end-y\");\n          }),\n          onSwipeEnd: i[7] || (i[7] = (r) => {\n            const { x: u, y: d } = r.detail.delta, c = r.currentTarget;\n            c.setAttribute(\"data-swipe\", \"end\"), c.style.removeProperty(\"--radix-toast-swipe-move-x\"), c.style.removeProperty(\"--radix-toast-swipe-move-y\"), c.style.setProperty(\"--radix-toast-swipe-end-x\", `${u}px`), c.style.setProperty(\"--radix-toast-swipe-end-y\", `${d}px`), s.value = !1;\n          })\n        }), {\n          default: v(() => [\n            y(l.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"open\", \"type\", \"as\", \"as-child\", \"duration\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), ba = /* @__PURE__ */ g({\n  __name: \"ToastAnnounceExclude\",\n  props: {\n    altText: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    return (t, e) => (h(), b(a(D), {\n      as: t.as,\n      \"as-child\": t.asChild,\n      \"data-radix-toast-announce-exclude\": \"\",\n      \"data-radix-toast-announce-alt\": t.altText || void 0\n    }, {\n      default: v(() => [\n        y(t.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-radix-toast-announce-alt\"]));\n  }\n}), Pr = /* @__PURE__ */ g({\n  __name: \"ToastClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = xr();\n    return (n, s) => (h(), b(ba, { \"as-child\": \"\" }, {\n      default: v(() => [\n        k(a(D), T(t, {\n          type: n.as === \"button\" ? \"button\" : void 0,\n          onClick: s[0] || (s[0] = (l) => a(e).onClose())\n        }), {\n          default: v(() => [\n            y(n.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"type\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Xc = /* @__PURE__ */ g({\n  __name: \"ToastAction\",\n  props: {\n    altText: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    if (!o.altText)\n      throw new Error(\"Missing prop `altText` expected on `ToastAction`\");\n    return (e, n) => e.altText ? (h(), b(ba, {\n      key: 0,\n      \"alt-text\": e.altText,\n      \"as-child\": \"\"\n    }, {\n      default: v(() => [\n        k(Pr, {\n          as: e.as,\n          \"as-child\": e.asChild\n        }, {\n          default: v(() => [\n            y(e.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\"])\n      ]),\n      _: 3\n    }, 8, [\"alt-text\"])) : J(\"\", !0);\n  }\n}), cn = /* @__PURE__ */ g({\n  __name: \"FocusProxy\",\n  emits: [\"focusFromOutsideViewport\"],\n  setup(o, { emit: t }) {\n    const e = t, n = zt();\n    return (s, l) => (h(), b(a(Xe), {\n      \"aria-hidden\": \"\",\n      tabindex: \"0\",\n      style: { position: \"'fixed'\" },\n      onFocus: l[0] || (l[0] = (i) => {\n        var d;\n        const r = i.relatedTarget;\n        !((d = a(n).viewport.value) != null && d.contains(r)) && e(\"focusFromOutsideViewport\");\n      })\n    }, {\n      default: v(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), Jc = /* @__PURE__ */ g({\n  inheritAttrs: !1,\n  __name: \"ToastViewport\",\n  props: {\n    hotkey: { default: () => _r },\n    label: { default: \"Notifications ({hotkey})\" },\n    asChild: { type: Boolean },\n    as: { default: \"ol\" }\n  },\n  setup(o) {\n    const t = o, { hotkey: e, label: n } = z(t), { primitiveElement: s, currentElement: l } = V(), { createCollection: i } = re(), r = i(l), u = zt(), d = S(() => u.toastCount.value > 0), c = B(), p = B();\n    bo(e.value, () => {\n      l.value.focus();\n    }), U(() => {\n      u.onViewportChange(l.value);\n    }), ee((m) => {\n      const C = l.value;\n      if (d.value && C) {\n        const w = () => {\n          if (!u.isClosePausedRef.value) {\n            const P = new CustomEvent(io);\n            C.dispatchEvent(P), u.isClosePausedRef.value = !0;\n          }\n        }, $ = () => {\n          if (u.isClosePausedRef.value) {\n            const P = new CustomEvent(ro);\n            C.dispatchEvent(P), u.isClosePausedRef.value = !1;\n          }\n        }, _ = (P) => {\n          !C.contains(P.relatedTarget) && $();\n        }, E = () => {\n          C.contains(document.activeElement) || $();\n        }, x = (P) => {\n          var L, M, W;\n          const I = P.altKey || P.ctrlKey || P.metaKey;\n          if (P.key === \"Tab\" && !I) {\n            const O = document.activeElement, K = P.shiftKey;\n            if (P.target === C && K) {\n              (L = c.value) == null || L.focus();\n              return;\n            }\n            const F = f({ tabbingDirection: K ? \"backwards\" : \"forwards\" }), q = F.findIndex((oe) => oe === O);\n            $t(F.slice(q + 1)) ? P.preventDefault() : K ? (M = c.value) == null || M.focus() : (W = p.value) == null || W.focus();\n          }\n        };\n        C.addEventListener(\"focusin\", w), C.addEventListener(\"focusout\", _), C.addEventListener(\"pointermove\", w), C.addEventListener(\"pointerleave\", E), C.addEventListener(\"keydown\", x), window.addEventListener(\"blur\", w), window.addEventListener(\"focus\", $), m(() => {\n          C.removeEventListener(\"focusin\", w), C.removeEventListener(\"focusout\", _), C.removeEventListener(\"pointermove\", w), C.removeEventListener(\"pointerleave\", E), C.removeEventListener(\"keydown\", x), window.removeEventListener(\"blur\", w), window.removeEventListener(\"focus\", $);\n        });\n      }\n    });\n    function f({ tabbingDirection: m }) {\n      const w = r.value.map(($) => {\n        const _ = [$, ...$o($)];\n        return m === \"forwards\" ? _ : _.reverse();\n      });\n      return (m === \"forwards\" ? w.reverse() : w).flat();\n    }\n    return (m, C) => (h(), b(a(ks), {\n      role: \"region\",\n      \"aria-label\": a(n).replace(\"{hotkey}\", a(e).join(\"+\").replace(/Key/g, \"\").replace(/Digit/g, \"\")),\n      tabindex: \"-1\",\n      style: ae({\n        // incase list has size when empty (e.g. padding), we remove pointer events so\n        // it doesn't prevent interactions with page elements that it overlays\n        pointerEvents: d.value ? void 0 : \"none\"\n      })\n    }, {\n      default: v(() => [\n        d.value ? (h(), b(cn, {\n          key: 0,\n          ref: (w) => {\n            c.value = a(ve)(w);\n          },\n          onFocusFromOutsideViewport: C[0] || (C[0] = () => {\n            const w = f({\n              tabbingDirection: \"forwards\"\n            });\n            a($t)(w);\n          })\n        }, null, 512)) : J(\"\", !0),\n        k(a(D), T({\n          ref_key: \"primitiveElement\",\n          ref: s,\n          tabindex: \"-1\",\n          as: m.as,\n          \"as-child\": m.asChild\n        }, m.$attrs), {\n          default: v(() => [\n            y(m.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\"]),\n        d.value ? (h(), b(cn, {\n          key: 1,\n          ref: (w) => {\n            p.value = a(ve)(w);\n          },\n          onFocusFromOutsideViewport: C[1] || (C[1] = () => {\n            const w = f({\n              tabbingDirection: \"backwards\"\n            });\n            a($t)(w);\n          })\n        }, null, 512)) : J(\"\", !0)\n      ]),\n      _: 3\n    }, 8, [\"aria-label\", \"style\"]));\n  }\n}), Zc = /* @__PURE__ */ g({\n  __name: \"ToastTitle\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(D), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Qc = /* @__PURE__ */ g({\n  __name: \"ToastDescription\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(D), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Sr = /* @__PURE__ */ g({\n  __name: \"ToggleRoot\",\n  props: {\n    defaultValue: { type: Boolean },\n    pressed: { type: Boolean, default: void 0 },\n    disabled: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:pressed\"],\n  setup(o, { emit: t }) {\n    const e = o, s = X(e, \"pressed\", t, {\n      defaultValue: e.defaultValue,\n      passive: e.pressed === void 0\n    });\n    function l() {\n      s.value = !s.value;\n    }\n    const i = S(() => s.value ? \"on\" : \"off\");\n    return (r, u) => (h(), b(a(D), {\n      type: r.as === \"button\" ? \"button\" : void 0,\n      \"as-child\": e.asChild,\n      as: r.as,\n      \"aria-pressed\": a(s),\n      \"data-state\": i.value,\n      \"data-disabled\": r.disabled ? \"\" : void 0,\n      disabled: r.disabled,\n      onClick: l,\n      onKeydown: le(l, [\"enter\"])\n    }, {\n      default: v(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"type\", \"as-child\", \"as\", \"aria-pressed\", \"data-state\", \"data-disabled\", \"disabled\", \"onKeydown\"]));\n  }\n}), [Tr, Dr] = H(\"ToggleGroupRoot\"), Or = /* @__PURE__ */ g({\n  __name: \"ToggleGroupRoot\",\n  props: {\n    type: { default: \"single\" },\n    defaultValue: {},\n    modelValue: {},\n    rovingFocus: { type: Boolean, default: !0 },\n    disabled: { type: Boolean, default: !1 },\n    orientation: { default: \"horizontal\" },\n    dir: {},\n    loop: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, { loop: s, rovingFocus: l, disabled: i, dir: r } = z(e), u = de(r), { modelValue: d, changeModelValue: c } = Pn(e, n);\n    return Dr({\n      type: e.type,\n      modelValue: d,\n      changeModelValue: c,\n      dir: u,\n      orientation: e.orientation,\n      loop: s,\n      rovingFocus: l,\n      disabled: i\n    }), (p, f) => (h(), b($e(a(l) ? a(Je) : a(D)), {\n      \"as-child\": \"\",\n      orientation: a(l) ? p.orientation : void 0,\n      dir: a(u),\n      loop: a(l) ? a(s) : void 0\n    }, {\n      default: v(() => [\n        k(a(D), {\n          role: \"group\",\n          \"as-child\": p.asChild,\n          as: p.as\n        }, {\n          default: v(() => [\n            y(p.$slots, \"default\", { modelValue: a(d) })\n          ]),\n          _: 3\n        }, 8, [\"as-child\", \"as\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n}), Ir = /* @__PURE__ */ g({\n  __name: \"ToggleGroupItem\",\n  props: {\n    value: {},\n    defaultValue: { type: Boolean },\n    pressed: { type: Boolean },\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = Tr(), n = S(() => {\n      var l;\n      return ((l = e.disabled) == null ? void 0 : l.value) || t.disabled;\n    }), s = S(() => {\n      var l;\n      return (l = e.modelValue.value) == null ? void 0 : l.includes(t.value);\n    });\n    return (l, i) => (h(), b($e(a(e).rovingFocus.value ? a(Ze) : a(D)), {\n      \"as-child\": \"\",\n      focusable: !n.value,\n      active: s.value\n    }, {\n      default: v(() => {\n        var r;\n        return [\n          k(a(Sr), T(t, {\n            disabled: n.value,\n            pressed: a(e).type === \"single\" ? a(e).modelValue.value === l.value : (r = a(e).modelValue.value) == null ? void 0 : r.includes(l.value),\n            \"onUpdate:pressed\": i[0] || (i[0] = (u) => a(e).changeModelValue(l.value))\n          }), {\n            default: v(() => [\n              y(l.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16, [\"disabled\", \"pressed\"])\n        ];\n      }),\n      _: 3\n    }, 8, [\"focusable\", \"active\"]));\n  }\n}), [Ca, Ar] = H(\"ToolbarRoot\"), ep = /* @__PURE__ */ g({\n  __name: \"ToolbarRoot\",\n  props: {\n    orientation: { default: \"horizontal\" },\n    dir: {},\n    loop: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { orientation: e, dir: n } = z(t), s = de(n);\n    return Ar({ orientation: e, dir: s }), (l, i) => (h(), b(a(Je), {\n      \"as-child\": \"\",\n      orientation: a(e),\n      dir: a(s),\n      loop: l.loop\n    }, {\n      default: v(() => [\n        k(a(D), {\n          role: \"toolbar\",\n          \"aria-orientation\": a(e),\n          \"as-child\": l.asChild,\n          as: l.as\n        }, {\n          default: v(() => [\n            y(l.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"aria-orientation\", \"as-child\", \"as\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n}), Mr = /* @__PURE__ */ g({\n  __name: \"ToolbarButton\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Ze), {\n      \"as-child\": \"\",\n      focusable: !e.disabled\n    }, {\n      default: v(() => [\n        k(a(D), T({\n          type: e.as === \"button\" ? \"button\" : void 0\n        }, t), {\n          default: v(() => [\n            y(e.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"type\"])\n      ]),\n      _: 3\n    }, 8, [\"focusable\"]));\n  }\n}), tp = /* @__PURE__ */ g({\n  __name: \"ToolbarLink\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"a\" }\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Ze), {\n      \"as-child\": \"\",\n      focusable: \"\"\n    }, {\n      default: v(() => [\n        k(a(D), T(t, {\n          onKeydown: n[0] || (n[0] = (s) => {\n            var l;\n            s.key === \" \" && ((l = s.currentTarget) == null || l.click());\n          })\n        }), {\n          default: v(() => [\n            y(e.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }));\n  }\n}), op = /* @__PURE__ */ g({\n  __name: \"ToolbarToggleGroup\",\n  props: {\n    type: {},\n    defaultValue: {},\n    modelValue: {},\n    rovingFocus: { type: Boolean },\n    disabled: { type: Boolean },\n    orientation: {},\n    dir: {},\n    loop: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = Ca(), l = ce(n);\n    return (i, r) => (h(), b(a(Or), T({ ...e, ...a(l) }, {\n      \"data-orientation\": a(s).orientation.value,\n      dir: a(s).dir.value,\n      \"roving-focus\": !1\n    }), {\n      default: v(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"data-orientation\", \"dir\"]));\n  }\n}), np = /* @__PURE__ */ g({\n  __name: \"ToolbarToggleItem\",\n  props: {\n    value: {},\n    defaultValue: { type: Boolean },\n    pressed: { type: Boolean },\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(Mr, { \"as-child\": \"\" }, {\n      default: v(() => [\n        k(a(Ir), R(N(t)), {\n          default: v(() => [\n            y(e.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }));\n  }\n}), ap = /* @__PURE__ */ g({\n  __name: \"ToolbarSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = Ca();\n    return (n, s) => (h(), b(la, {\n      orientation: a(e).orientation.value,\n      \"as-child\": t.asChild,\n      as: n.as\n    }, {\n      default: v(() => [\n        y(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"as-child\", \"as\"]));\n  }\n}), _a = \"tooltip.open\";\nfunction kr(o, t) {\n  const e = Math.abs(t.top - o.y), n = Math.abs(t.bottom - o.y), s = Math.abs(t.right - o.x), l = Math.abs(t.left - o.x);\n  switch (Math.min(e, n, s, l)) {\n    case l:\n      return \"left\";\n    case s:\n      return \"right\";\n    case e:\n      return \"top\";\n    case n:\n      return \"bottom\";\n    default:\n      throw new Error(\"unreachable\");\n  }\n}\nfunction Rr(o, t, e = 5) {\n  const n = [];\n  switch (t) {\n    case \"top\":\n      n.push(\n        { x: o.x - e, y: o.y + e },\n        { x: o.x + e, y: o.y + e }\n      );\n      break;\n    case \"bottom\":\n      n.push(\n        { x: o.x - e, y: o.y - e },\n        { x: o.x + e, y: o.y - e }\n      );\n      break;\n    case \"left\":\n      n.push(\n        { x: o.x + e, y: o.y - e },\n        { x: o.x + e, y: o.y + e }\n      );\n      break;\n    case \"right\":\n      n.push(\n        { x: o.x - e, y: o.y - e },\n        { x: o.x - e, y: o.y + e }\n      );\n      break;\n  }\n  return n;\n}\nfunction Vr(o) {\n  const { top: t, right: e, bottom: n, left: s } = o;\n  return [\n    { x: s, y: t },\n    { x: e, y: t },\n    { x: e, y: n },\n    { x: s, y: n }\n  ];\n}\nfunction Fr(o, t) {\n  const { x: e, y: n } = o;\n  let s = !1;\n  for (let l = 0, i = t.length - 1; l < t.length; i = l++) {\n    const r = t[l].x, u = t[l].y, d = t[i].x, c = t[i].y;\n    u > n != c > n && e < (d - r) * (n - u) / (c - u) + r && (s = !s);\n  }\n  return s;\n}\nfunction Lr(o) {\n  const t = o.slice();\n  return t.sort((e, n) => e.x < n.x ? -1 : e.x > n.x ? 1 : e.y < n.y ? -1 : e.y > n.y ? 1 : 0), Kr(t);\n}\nfunction Kr(o) {\n  if (o.length <= 1)\n    return o.slice();\n  const t = [];\n  for (let n = 0; n < o.length; n++) {\n    const s = o[n];\n    for (; t.length >= 2; ) {\n      const l = t[t.length - 1], i = t[t.length - 2];\n      if ((l.x - i.x) * (s.y - i.y) >= (l.y - i.y) * (s.x - i.x))\n        t.pop();\n      else\n        break;\n    }\n    t.push(s);\n  }\n  t.pop();\n  const e = [];\n  for (let n = o.length - 1; n >= 0; n--) {\n    const s = o[n];\n    for (; e.length >= 2; ) {\n      const l = e[e.length - 1], i = e[e.length - 2];\n      if ((l.x - i.x) * (s.y - i.y) >= (l.y - i.y) * (s.x - i.x))\n        e.pop();\n      else\n        break;\n    }\n    e.push(s);\n  }\n  return e.pop(), t.length === 1 && e.length === 1 && t[0].x === e[0].x && t[0].y === e[0].y ? t : t.concat(e);\n}\nconst [Qo, Nr] = H(\"TooltipProvider\"), sp = /* @__PURE__ */ g({\n  __name: \"TooltipProvider\",\n  props: {\n    delayDuration: { default: 700 },\n    skipDelayDuration: { default: 300 },\n    disableHoverableContent: { type: Boolean, default: !1 },\n    disableClosingTrigger: { type: Boolean }\n  },\n  setup(o) {\n    const t = o, { delayDuration: e, skipDelayDuration: n, disableHoverableContent: s, disableClosingTrigger: l } = z(t), i = B(!0), r = B(!1), { start: u, stop: d } = go(() => {\n      i.value = !0;\n    }, n, { immediate: !1 });\n    return Nr({\n      isOpenDelayed: i,\n      delayDuration: e,\n      onOpen() {\n        d(), i.value = !1;\n      },\n      onClose() {\n        u();\n      },\n      isPointerInTransitRef: r,\n      onPointerInTransitChange(c) {\n        r.value = c;\n      },\n      disableHoverableContent: s,\n      disableClosingTrigger: l\n    }), (c, p) => y(c.$slots, \"default\");\n  }\n}), [Ut, Hr] = H(\"TooltipRoot\"), lp = /* @__PURE__ */ g({\n  __name: \"TooltipRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    delayDuration: { default: void 0 },\n    disableHoverableContent: { type: Boolean, default: void 0 },\n    disableClosingTrigger: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = Qo(), l = S(() => e.disableHoverableContent ?? s.disableHoverableContent.value), i = S(() => e.disableClosingTrigger ?? s.disableClosingTrigger.value), r = S(() => e.delayDuration ?? s.delayDuration.value), u = X(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    });\n    Y(u, (_) => {\n      s.onClose && (_ ? (s.onOpen(), document.dispatchEvent(new CustomEvent(_a))) : s.onClose());\n    });\n    const d = B(!1), c = B(), p = S(() => u.value ? d.value ? \"delayed-open\" : \"instant-open\" : \"closed\"), { start: f, stop: m } = go(() => {\n      d.value = !0, u.value = !0;\n    }, r, { immediate: !1 });\n    function C() {\n      m(), d.value = !1, u.value = !0;\n    }\n    function w() {\n      m(), u.value = !1;\n    }\n    function $() {\n      f();\n    }\n    return Hr({\n      contentId: te(),\n      open: u,\n      stateAttribute: p,\n      trigger: c,\n      onTriggerChange(_) {\n        c.value = _;\n      },\n      onTriggerEnter() {\n        s.isOpenDelayed.value ? $() : C();\n      },\n      onTriggerLeave() {\n        l.value ? w() : m();\n      },\n      onOpen: C,\n      onClose: w,\n      disableHoverableContent: l,\n      disableClosingTrigger: i\n    }), (_, E) => (h(), b(a(Ne), null, {\n      default: v(() => [\n        y(_.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), ip = /* @__PURE__ */ g({\n  __name: \"TooltipTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = Ut(), n = Qo(), { primitiveElement: s, currentElement: l } = V(), i = B(!1), r = B(!1);\n    function u() {\n      i.value = !1;\n    }\n    function d() {\n      i.value = !0, document.addEventListener(\"pointerup\", u, { once: !0 });\n    }\n    return U(() => {\n      e.onTriggerChange(l.value);\n    }), (c, p) => (h(), b(a(He), { \"as-child\": \"\" }, {\n      default: v(() => [\n        k(a(D), {\n          ref_key: \"primitiveElement\",\n          ref: s,\n          \"aria-describedby\": a(e).open.value ? a(e).contentId : void 0,\n          \"data-state\": a(e).stateAttribute.value,\n          as: c.as,\n          \"as-child\": t.asChild,\n          onPointermove: p[0] || (p[0] = (f) => {\n            f.pointerType !== \"touch\" && !r.value && !a(n).isPointerInTransitRef.value && (a(e).onTriggerEnter(), r.value = !0);\n          }),\n          onPointerleave: p[1] || (p[1] = (f) => {\n            a(e).onTriggerLeave(), r.value = !1;\n          }),\n          onPointerdown: d,\n          onFocus: p[2] || (p[2] = () => {\n            i.value || a(e).onOpen();\n          }),\n          onBlur: p[3] || (p[3] = (f) => a(e).onClose()),\n          onClick: p[4] || (p[4] = () => {\n            a(e).disableClosingTrigger.value || a(e).onClose();\n          })\n        }, {\n          default: v(() => [\n            y(c.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"aria-describedby\", \"data-state\", \"as\", \"as-child\"])\n      ]),\n      _: 3\n    }));\n  }\n}), wa = /* @__PURE__ */ g({\n  __name: \"TooltipContentImpl\",\n  props: {\n    ariaLabel: {},\n    asChild: { type: Boolean, default: !1 },\n    as: {},\n    side: { default: \"top\" },\n    sideOffset: { default: 0 },\n    align: { default: \"center\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean, default: !0 },\n    collisionBoundary: { default: () => [] },\n    collisionPadding: { default: 0 },\n    arrowPadding: { default: 0 },\n    sticky: { default: \"partial\" },\n    hideWhenDetached: { type: Boolean, default: !1 }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = B(), l = Ut(), i = S(() => {\n      var p, f;\n      if (e.ariaLabel)\n        return e.ariaLabel;\n      const u = (f = (p = Cn()).default) == null ? void 0 : f.call(p);\n      let d = \"\";\n      function c(m) {\n        typeof m.children == \"string\" ? d += m.children : Array.isArray(m.children) && m.children.forEach((C) => c(C));\n      }\n      return u == null || u.forEach((m) => c(m)), d;\n    }), r = S(() => {\n      const { ariaLabel: u, ...d } = e;\n      return d;\n    });\n    return U(() => {\n      Ve(window, \"scroll\", (u) => {\n        const d = u.target;\n        d != null && d.contains(l.trigger.value) && l.onClose();\n      }), Ve(window, _a, l.onClose);\n    }), (u, d) => (h(), b(a(Se), {\n      \"as-child\": \"\",\n      \"disable-outside-pointer-events\": !1,\n      onEscapeKeyDown: d[0] || (d[0] = (c) => n(\"escapeKeyDown\", c)),\n      onPointerDownOutside: d[1] || (d[1] = (c) => {\n        var p;\n        a(l).disableClosingTrigger.value && ((p = a(l).trigger.value) != null && p.contains(c.target)) && c.preventDefault(), n(\"pointerDownOutside\", c);\n      }),\n      onFocusOutside: d[2] || (d[2] = ne(() => {\n      }, [\"prevent\"])),\n      onDismiss: d[3] || (d[3] = (c) => a(l).onClose())\n    }, {\n      default: v(() => [\n        k(a(Ge), T({\n          ref_key: \"contentElement\",\n          ref: s,\n          \"data-state\": a(l).stateAttribute.value\n        }, { ...u.$attrs, ...r.value }, { style: {\n          \"--radix-tooltip-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n          \"--radix-tooltip-content-available-width\": \"var(--radix-popper-available-width)\",\n          \"--radix-tooltip-content-available-height\": \"var(--radix-popper-available-height)\",\n          \"--radix-tooltip-trigger-width\": \"var(--radix-popper-anchor-width)\",\n          \"--radix-tooltip-trigger-height\": \"var(--radix-popper-anchor-height)\"\n        } }), {\n          default: v(() => [\n            y(u.$slots, \"default\"),\n            k(a(Xe), {\n              id: a(l).contentId,\n              role: \"tooltip\"\n            }, {\n              default: v(() => [\n                ue(Le(i.value), 1)\n              ]),\n              _: 1\n            }, 8, [\"id\"])\n          ]),\n          _: 3\n        }, 16, [\"data-state\", \"style\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Wr = /* @__PURE__ */ g({\n  __name: \"TooltipContentHoverable\",\n  props: {\n    ariaLabel: {},\n    asChild: { type: Boolean },\n    as: {},\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean }\n  },\n  setup(o) {\n    const t = o, { primitiveElement: e, currentElement: n } = V(), { trigger: s, onClose: l } = Ut(), i = Qo(), r = B(null);\n    function u() {\n      r.value = null, i.onPointerInTransitChange(!1);\n    }\n    function d(c, p) {\n      const f = c.currentTarget, m = { x: c.clientX, y: c.clientY }, C = kr(m, f.getBoundingClientRect()), w = Rr(m, C), $ = Vr(p.getBoundingClientRect()), _ = Lr([...w, ...$]);\n      r.value = _, i.onPointerInTransitChange(!0);\n    }\n    return ee((c) => {\n      if (s.value && n.value) {\n        const p = (m) => d(m, n.value), f = (m) => d(m, s.value);\n        s.value.addEventListener(\"pointerleave\", p), n.value.addEventListener(\"pointerleave\", f), c(() => {\n          var m, C;\n          (m = s.value) == null || m.removeEventListener(\"pointerleave\", p), (C = n.value) == null || C.removeEventListener(\"pointerleave\", f);\n        });\n      }\n    }), ee((c) => {\n      if (r.value) {\n        const p = (f) => {\n          var _, E;\n          if (!r.value)\n            return;\n          const m = f.target, C = { x: f.clientX, y: f.clientY }, w = ((_ = s.value) == null ? void 0 : _.contains(m)) || ((E = n.value) == null ? void 0 : E.contains(m)), $ = !Fr(C, r.value);\n          w ? u() : $ && (u(), l());\n        };\n        document.addEventListener(\"pointermove\", p), c(() => document.removeEventListener(\"pointermove\", p));\n      }\n    }), (c, p) => (h(), b(wa, T({\n      ref_key: \"primitiveElement\",\n      ref: e\n    }, t), {\n      default: v(() => [\n        y(c.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), rp = /* @__PURE__ */ g({\n  __name: \"TooltipContent\",\n  props: {\n    ariaLabel: {},\n    asChild: { type: Boolean },\n    as: {},\n    side: { default: \"top\" },\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(o, { emit: t }) {\n    const e = o, n = t, s = Ut(), l = pe(e, n);\n    return (i, r) => a(s).open.value ? (h(), b($e(a(s).disableHoverableContent.value ? wa : Wr), R(T({ key: 0 }, a(l))), {\n      default: v(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : J(\"\", !0);\n  }\n}), up = /* @__PURE__ */ g({\n  __name: \"TooltipArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Ye), R(N(t)), null, 16));\n  }\n}), dp = /* @__PURE__ */ g({\n  __name: \"TooltipPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = o;\n    return (e, n) => (h(), b(a(Pe), R(N(t)), {\n      default: v(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n});\nexport {\n  Jr as AccordionContent,\n  Zr as AccordionHeader,\n  Xr as AccordionItem,\n  Yr as AccordionRoot,\n  Qr as AccordionTrigger,\n  uu as AlertDialogAction,\n  lu as AlertDialogCancel,\n  au as AlertDialogContent,\n  ru as AlertDialogDescription,\n  su as AlertDialogOverlay,\n  nu as AlertDialogPortal,\n  tu as AlertDialogRoot,\n  iu as AlertDialogTitle,\n  ou as AlertDialogTrigger,\n  du as AspectRatio,\n  fu as AvatarFallback,\n  pu as AvatarImage,\n  cu as AvatarRoot,\n  mu as CheckboxIndicator,\n  vu as CheckboxRoot,\n  Es as CollapsibleContent,\n  Cs as CollapsibleRoot,\n  _s as CollapsibleTrigger,\n  gu as ComboboxAnchor,\n  Tu as ComboboxArrow,\n  Cu as ComboboxCancel,\n  Eu as ComboboxContent,\n  xu as ComboboxEmpty,\n  _u as ComboboxGroup,\n  yu as ComboboxInput,\n  Bu as ComboboxItem,\n  Pu as ComboboxItemIndicator,\n  wu as ComboboxLabel,\n  Du as ComboboxPortal,\n  hu as ComboboxRoot,\n  Su as ComboboxSeparator,\n  bu as ComboboxTrigger,\n  $u as ComboboxViewport,\n  qr as ConfigProvider,\n  ku as ContextMenuArrow,\n  Lu as ContextMenuCheckboxItem,\n  Mu as ContextMenuContent,\n  Vu as ContextMenuGroup,\n  Ru as ContextMenuItem,\n  Ku as ContextMenuItemIndicator,\n  Nu as ContextMenuLabel,\n  Au as ContextMenuPortal,\n  Hu as ContextMenuRadioGroup,\n  Wu as ContextMenuRadioItem,\n  Ou as ContextMenuRoot,\n  Fu as ContextMenuSeparator,\n  ju as ContextMenuSub,\n  zu as ContextMenuSubContent,\n  Uu as ContextMenuSubTrigger,\n  Iu as ContextMenuTrigger,\n  On as DialogClose,\n  Zs as DialogContent,\n  ol as DialogDescription,\n  el as DialogOverlay,\n  eu as DialogPortal,\n  Ts as DialogRoot,\n  tl as DialogTitle,\n  Ds as DialogTrigger,\n  Ju as DropdownMenuArrow,\n  td as DropdownMenuCheckboxItem,\n  Xu as DropdownMenuContent,\n  Qu as DropdownMenuGroup,\n  Zu as DropdownMenuItem,\n  od as DropdownMenuItemIndicator,\n  nd as DropdownMenuLabel,\n  Yu as DropdownMenuPortal,\n  ad as DropdownMenuRadioGroup,\n  sd as DropdownMenuRadioItem,\n  qu as DropdownMenuRoot,\n  ed as DropdownMenuSeparator,\n  ld as DropdownMenuSub,\n  id as DropdownMenuSubContent,\n  rd as DropdownMenuSubTrigger,\n  Gu as DropdownMenuTrigger,\n  fd as HoverCardArrow,\n  pd as HoverCardContent,\n  cd as HoverCardPortal,\n  ud as HoverCardRoot,\n  dd as HoverCardTrigger,\n  vd as Label,\n  Cd as MenubarArrow,\n  xd as MenubarCheckboxItem,\n  bd as MenubarContent,\n  wd as MenubarGroup,\n  _d as MenubarItem,\n  $d as MenubarItemIndicator,\n  Bd as MenubarLabel,\n  hd as MenubarMenu,\n  gd as MenubarPortal,\n  Pd as MenubarRadioGroup,\n  Sd as MenubarRadioItem,\n  md as MenubarRoot,\n  Ed as MenubarSeparator,\n  Td as MenubarSub,\n  Dd as MenubarSubContent,\n  Od as MenubarSubTrigger,\n  yd as MenubarTrigger,\n  Md as NavigationMenuContent,\n  kd as NavigationMenuIndicator,\n  Ad as NavigationMenuItem,\n  Rd as NavigationMenuLink,\n  Vd as NavigationMenuList,\n  Id as NavigationMenuRoot,\n  Fd as NavigationMenuSub,\n  Ld as NavigationMenuTrigger,\n  Kd as NavigationMenuViewport,\n  Hd as PaginationEllipsis,\n  Wd as PaginationFirst,\n  jd as PaginationLast,\n  zd as PaginationList,\n  Ud as PaginationListItem,\n  qd as PaginationNext,\n  Gd as PaginationPrev,\n  Nd as PaginationRoot,\n  Xd as PinInputInput,\n  Yd as PinInputRoot,\n  nc as PopoverAnchor,\n  tc as PopoverArrow,\n  oc as PopoverClose,\n  ec as PopoverContent,\n  Qd as PopoverPortal,\n  Jd as PopoverRoot,\n  Zd as PopoverTrigger,\n  D as Primitive,\n  sc as ProgressIndicator,\n  ac as ProgressRoot,\n  rc as RadioGroupIndicator,\n  ic as RadioGroupItem,\n  lc as RadioGroupRoot,\n  fc as ScrollAreaCorner,\n  uc as ScrollAreaRoot,\n  cc as ScrollAreaScrollbar,\n  pc as ScrollAreaThumb,\n  dc as ScrollAreaViewport,\n  gc as SelectArrow,\n  yc as SelectContent,\n  wc as SelectGroup,\n  Tc as SelectIcon,\n  Cc as SelectItem,\n  _c as SelectItemIndicator,\n  xc as SelectItemText,\n  Ec as SelectLabel,\n  hc as SelectPortal,\n  vc as SelectRoot,\n  Pc as SelectScrollDownButton,\n  Bc as SelectScrollUpButton,\n  bc as SelectSeparator,\n  mc as SelectTrigger,\n  Sc as SelectValue,\n  $c as SelectViewport,\n  Dc as Separator,\n  Mc as SliderRange,\n  Oc as SliderRoot,\n  Ic as SliderThumb,\n  Ac as SliderTrack,\n  Eo as Slot,\n  kc as SwitchRoot,\n  Rc as SwitchThumb,\n  Lc as TabsContent,\n  Nc as TabsIndicator,\n  Fc as TabsList,\n  Vc as TabsRoot,\n  Kc as TabsTrigger,\n  qc as TagsInputClear,\n  Wc as TagsInputInput,\n  jc as TagsInputItem,\n  Uc as TagsInputItemDelete,\n  zc as TagsInputItemText,\n  Hc as TagsInputRoot,\n  Xc as ToastAction,\n  Pr as ToastClose,\n  Qc as ToastDescription,\n  Gc as ToastProvider,\n  Yc as ToastRoot,\n  Zc as ToastTitle,\n  Jc as ToastViewport,\n  Sr as Toggle,\n  Ir as ToggleGroupItem,\n  Or as ToggleGroupRoot,\n  Mr as ToolbarButton,\n  tp as ToolbarLink,\n  ep as ToolbarRoot,\n  ap as ToolbarSeparator,\n  op as ToolbarToggleGroup,\n  np as ToolbarToggleItem,\n  up as TooltipArrow,\n  rp as TooltipContent,\n  dp as TooltipPortal,\n  sp as TooltipProvider,\n  lp as TooltipRoot,\n  ip as TooltipTrigger,\n  Xe as VisuallyHidden,\n  ce as useEmitAsProps,\n  It as useForwardProps,\n  pe as useForwardPropsEmits,\n  te as useId,\n  $n as useStateMachine,\n  Gr as withDefault\n};\n"],"names":["sides","min","max","round","floor","createCoords","v","oppositeSideMap","oppositeAlignmentMap","clamp","start","value","end","evaluate","param","getSide","placement","getAlignment","getOppositeAxis","axis","getAxisLength","getSideAxis","getAlignmentAxis","getAlignmentSides","rects","rtl","alignment","alignmentAxis","length","mainAlignmentSide","getOppositePlacement","getExpandedPlacements","oppositePlacement","getOppositeAlignmentPlacement","getSideList","side","isStart","lr","rl","tb","bt","getOppositeAxisPlacements","flipAlignment","direction","list","expandPaddingObject","padding","getPaddingObject","rectToClientRect","rect","computeCoordsFromPlacement","_ref","reference","floating","sideAxis","alignLength","isVertical","commonX","commonY","commonAlign","coords","computePosition","config","strategy","middleware","platform","validMiddleware","x","y","statefulPlacement","middlewareData","resetCount","i","name","fn","nextX","nextY","data","reset","detectOverflow","state","options","_await$platform$isEle","elements","boundary","rootBoundary","elementContext","altBoundary","paddingObject","element","clippingClientRect","offsetParent","offsetScale","elementClientRect","arrow","arrowDimensions","isYAxis","minProp","maxProp","clientProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","largestPossiblePadding","minPadding","maxPadding","min$1","center","offset","shouldAddOffset","alignmentOffset","flip","_middlewareData$arrow","_middlewareData$flip","initialPlacement","checkMainAxis","checkCrossAxis","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","detectOverflowOptions","isBasePlacement","fallbackPlacements","placements","overflow","overflows","overflowsData","_middlewareData$flip2","_overflowsData$filter","nextIndex","nextPlacement","resetPlacement","d","a","b","_overflowsData$map$so","acc","getSideOffsets","isAnySideFullyClipped","hide","offsets","convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","mainAxis","crossAxis","diffCoords","shift","limiter","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","limitShift","rawOffset","computedOffset","len","limitMin","limitMax","_middlewareData$offse","_middlewareData$offse2","isOriginSide","size","apply","width","height","heightSide","widthSide","overflowAvailableHeight","overflowAvailableWidth","noShift","availableHeight","availableWidth","maximumClippingWidth","maximumClippingHeight","xMin","xMax","yMin","yMax","nextDimensions","getNodeName","node","isNode","getWindow","_node$ownerDocument","getDocumentElement","isElement","isHTMLElement","isShadowRoot","isOverflowElement","overflowX","overflowY","display","getComputedStyle","isTableElement","isContainingBlock","webkit","isWebKit","css","getContainingBlock","currentNode","getParentNode","isLastTraversableNode","getNodeScroll","result","getNearestOverflowAncestor","parentNode","getOverflowAncestors","traverseIframes","_node$ownerDocument2","scrollableAncestor","isBody","win","getCssDimensions","hasOffset","offsetWidth","offsetHeight","shouldFallback","unwrapElement","getScale","domElement","$","noOffsets","getVisualOffsets","shouldAddVisualOffsets","isFixed","floatingOffsetParent","getBoundingClientRect","includeScale","isFixedStrategy","clientRect","scale","visualOffsets","offsetWin","currentIFrame","iframeScale","iframeRect","left","top","convertOffsetParentRelativeRectToViewportRelativeRect","isOffsetParentAnElement","documentElement","scroll","offsetRect","getClientRects","getWindowScrollBarX","getDocumentRect","html","body","getViewportRect","visualViewport","visualViewportBased","getInnerBoundingClientRect","getClientRectFromClippingAncestor","clippingAncestor","hasFixedPositionAncestor","stopNode","getClippingElementAncestors","cache","cachedResult","el","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","ancestor","getClippingRect","clippingAncestors","firstClippingAncestor","clippingRect","accRect","getDimensions","getRectRelativeToOffsetParent","getTrueOffsetParent","polyfill","getOffsetParent","window","getElementRects","getOffsetParentFn","getDimensionsFn","isRTL","observeMove","onMove","io","timeoutId","root","cleanup","refresh","skip","threshold","insetTop","insetRight","insetBottom","insetLeft","isFirstUpdate","handleObserve","entries","ratio","autoUpdate","update","ancestorScroll","ancestorResize","elementResize","layoutShift","animationFrame","referenceEl","ancestors","cleanupIo","reobserveFrame","resizeObserver","firstEntry","frameId","prevRefRect","frameLoop","nextRefRect","mergedOptions","platformWithCache","computePosition$1","_$el","args","unref","arrow$1","getDPR","roundByDPR","dpr","useFloating","whileElementsMountedOption","openOption","computed","_unref","middlewareOption","placementOption","_unref2","strategyOption","_unref3","transformOption","_unref4","referenceElement","floatingElement","ref","shallowRef","isPositioned","floatingStyles","initialStyles","xVal","yVal","whileElementsMountedCleanup","position","attach","watch","getCurrentScope","onScopeDispose","shallowReadonly","H","o","e","n","r","pn","vo","s","za","vn","ee","it","dt","Sa","Ta","Tt","Pa","ge","Be","Ua","qa","Ga","at","uo","l","ve","ct","Ve","c","p","f","m","u","Y","C","es","Dt","B","Fe","U","as","X","w","_","E","P","I","A","G","S","Ot","ie","qe","_n","Jt","oo","is","rs","wn","us","ds","cs","pt","co","ps","re","Oa","Ia","de","ce","Aa","mn","Zt","Co","on","Ke","be","fs","ze","Ct","Qt","En","vs","ms","hs","ft","fe","ys","te","xn","$n","_o","gs","wo","Eo","g","T","Ma","D","Re","V","ws","_t","se","z","ye","Ss","Ts","Ds","h","Pe","Ue","J","eu","R","N","Os","Is","Sn","As","Ms","he","hn","Se","ae","eo","to","nn","$t","xe","Rs","$o","an","Vs","Fs","Ls","Ks","sn","Ns","Mt","Ws","Tn","js","Bo","ao","qs","Gs","st","Dn","k","Xs","Js","Zs","Qs","On","tl","ol","Mn","dl","cl","pl","so","kn","fl","vl","Ge","yn","Fa","La","Ka","Na","Ha","O","K","j","Z","F","q","oe","Wa","ja","Ra","Va","L","M","W","Q","We","Nn","vt","Ol","Il","Al","Hn","Fl","Ll","Je","Io","Kl","ia","Ji","ra","Zi","Qi","er","Zo","tr","or","nr","ar","ua","da","ca","pa","fa","va","Ht","sr","ir","rr","Oc","$e","tt","po","ur","Ic","Ac","Mc"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5]}